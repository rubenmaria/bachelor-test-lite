{
    "__assert": "__assert (const char *assertion, const char *file, int line){\n  __assert_fail (assertion, file, line, (const char *) 0);\n}",
    "__assert_perror_fail": "__assert_perror_fail (int errnum,\n\t\t      const char *file, unsigned int line,\n\t\t      const char *function){\n  char errbuf[400];\n  _dl_fatal_printf (\"\\\nInconsistency detected by ld.so: %s: %u: %s%sUnexpected error: %s.\\n\",\n\t\t    file, line, function ?: \"\", function ? \": \" : \"\",\n\t\t    __strerror_r (errnum, errbuf, sizeof errbuf));\n\n}",
    "__assert_fail": "__assert_fail (const char *assertion,\n\t       const char *file, unsigned int line, const char *function){\n  _dl_fatal_printf (\"\\\nInconsistency detected by ld.so: %s: %u: %s%sAssertion `%s' failed!\\n\",\n\t\t    file, line, function ?: \"\", function ? \": \" : \"\",\n\t\t    assertion);\n\n}",
    "catopen": "catopen (const char *cat_name, int flag){\n  __nl_catd result;\n  const char *env_var = NULL;\n  const char *nlspath = NULL;\n  char *tmp = NULL;\n\n  if (strchr (cat_name, '/') == NULL)\n    {\n      if (flag == NL_CAT_LOCALE)\n\t/* Use the current locale setting for LC_MESSAGES.  */\n\tenv_var = setlocale (LC_MESSAGES, NULL);\n      else\n\t/* Use the LANG environment variable.  */\n\tenv_var = getenv (\"LANG\");\n\n      if (env_var == NULL || *env_var == '\\0'\n\t  || (__libc_enable_secure && strchr (env_var, '/') != NULL))\n\tenv_var = \"C\";\n\n      nlspath = getenv (\"NLSPATH\");\n      if (nlspath != NULL && *nlspath != '\\0')\n\t{\n\t  /* Append the system dependent directory.  */\n\t  size_t len = strlen (nlspath) + 1 + sizeof NLSPATH;\n\t  tmp = malloc (len);\n\n\t  if (__glibc_unlikely (tmp == NULL))\n\t    return (nl_catd) -1;\n\n\t  __stpcpy (__stpcpy (__stpcpy (tmp, nlspath), \":\"), NLSPATH);\n\t  nlspath = tmp;\n\t}\n      else\n\tnlspath = NLSPATH;\n    }\n\n  result = (__nl_catd) malloc (sizeof (*result));\n  if (result == NULL)\n    {\n      /* We cannot get enough memory.  */\n      result = (nl_catd) -1;\n    }\n  else if (__open_catalog (cat_name, nlspath, env_var, result) != 0)\n    {\n      /* Couldn't open the file.  */\n      free ((void *) result);\n      result = (nl_catd) -1;\n    }\n\n  free (tmp);\n  return (nl_catd) result;\n}",
    "catgets": "*\ncatgets (nl_catd catalog_desc, int set, int message, const char *string){\n  __nl_catd catalog;\n  size_t idx;\n  size_t cnt;\n\n  /* Be generous if catalog which failed to be open is used.  */\n  if (catalog_desc == (nl_catd) -1 || ++set <= 0 || message < 0)\n    return (char *) string;\n\n  catalog = (__nl_catd) catalog_desc;\n\n  idx = ((set * message) % catalog->plane_size) * 3;\n  cnt = 0;\n  do\n    {\n      if (catalog->name_ptr[idx + 0] == (uint32_t) set\n\t  && catalog->name_ptr[idx + 1] == (uint32_t) message)\n\treturn (char *) &catalog->strings[catalog->name_ptr[idx + 2]];\n\n      idx += catalog->plane_size * 3;\n    }\n  while (++cnt < catalog->plane_depth);\n\n  __set_errno (ENOMSG);\n  return (char *) string;\n}",
    "catclose": "catclose (nl_catd catalog_desc){\n  __nl_catd catalog;\n\n  /* Be generous if catalog which failed to be open is used.  */\n  if (catalog_desc == (nl_catd) -1)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  catalog = (__nl_catd) catalog_desc;\n\n#ifdef _POSIX_MAPPED_FILES\n  if (catalog->status == mmapped)\n    __munmap ((void *) catalog->file_ptr, catalog->file_size);\n  else\n#endif\t/* _POSIX_MAPPED_FILES */\n    if (catalog->status == malloced)\n      free ((void *) catalog->file_ptr);\n    else\n      {\n\t__set_errno (EBADF);\n\treturn -1;\n      }\n\n  free ((void *) catalog);\n\n  return 0;\n}",
    "__open_catalog": "__open_catalog (const char *cat_name, const char *nlspath, const char *env_var,\n\t\t__nl_catd catalog){\n  int fd = -1;\n  struct __stat64_t64 st;\n  int swapping;\n  size_t cnt;\n  size_t max_offset;\n  size_t tab_size;\n  const char *lastp;\n  int result = -1;\n  char *buf = NULL;\n\n  if (strchr (cat_name, '/') != NULL || nlspath == NULL)\n    fd = __open_nocancel (cat_name, O_RDONLY | O_CLOEXEC);\n  else\n    {\n      const char *run_nlspath = nlspath;\n#define ENOUGH(n)\t\t\t\t\t\t\t      \\\n  if (__glibc_unlikely (bufact + (n) >= bufmax))\t\t\t      \\\n    {\t\t\t\t\t\t\t\t\t      \\\n      char *old_buf = buf;\t\t\t\t\t\t      \\\n      bufmax += (bufmax < 256 + (n)) ? 256 + (n) : bufmax;\t\t      \\\n      buf = realloc (buf, bufmax);\t\t\t\t\t      \\\n      if (__glibc_unlikely (buf == NULL))\t\t\t\t      \\\n\t{\t\t\t\t\t\t\t\t      \\\n\t  free (old_buf);\t\t\t\t\t\t      \\\n\t  return -1;\t\t\t\t\t\t\t      \\\n\t}\t\t\t\t\t\t\t\t      \\\n    }\n\n      /* The RUN_NLSPATH variable contains a colon separated list of\n\t descriptions where we expect to find catalogs.  We have to\n\t recognize certain % substitutions and stop when we found the\n\t first existing file.  */\n      size_t bufact;\n      size_t bufmax = 0;\n      size_t len;\n\n      fd = -1;\n      while (*run_nlspath != '\\0')\n\t{\n\t  bufact = 0;\n\n\t  if (*run_nlspath == ':')\n\t    {\n\t      /* Leading colon or adjacent colons - treat same as %N.  */\n\t      len = strlen (cat_name);\n\t      ENOUGH (len);\n\t      memcpy (&buf[bufact], cat_name, len);\n\t      bufact += len;\n\t    }\n\t  else\n\t    while (*run_nlspath != ':' && *run_nlspath != '\\0')\n\t      if (*run_nlspath == '%')\n\t\t{\n\t\t  const char *tmp;\n\n\t\t  ++run_nlspath;\t/* We have seen the `%'.  */\n\t\t  switch (*run_nlspath++)\n\t\t    {\n\t\t    case 'N':\n\t\t      /* Use the catalog name.  */\n\t\t      len = strlen (cat_name);\n\t\t      ENOUGH (len);\n\t\t      memcpy (&buf[bufact], cat_name, len);\n\t\t      bufact += len;\n\t\t      break;\n\t\t    case 'L':\n\t\t      /* Use the current locale category value.  */\n\t\t      len = strlen (env_var);\n\t\t      ENOUGH (len);\n\t\t      memcpy (&buf[bufact], env_var, len);\n\t\t      bufact += len;\n\t\t      break;\n\t\t    case 'l':\n\t\t      /* Use language element of locale category value.  */\n\t\t      tmp = env_var;\n\t\t      do\n\t\t\t{\n\t\t\t  ENOUGH (1);\n\t\t\t  buf[bufact++] = *tmp++;\n\t\t\t}\n\t\t      while (*tmp != '\\0' && *tmp != '_' && *tmp != '.');\n\t\t      break;\n\t\t    case 't':\n\t\t      /* Use territory element of locale category value.  */\n\t\t      tmp = env_var;\n\t\t      do\n\t\t\t++tmp;\n\t\t      while (*tmp != '\\0' && *tmp != '_' && *tmp != '.');\n\t\t      if (*tmp == '_')\n\t\t\t{\n\t\t\t  ++tmp;\n\t\t\t  do\n\t\t\t    {\n\t\t\t      ENOUGH (1);\n\t\t\t      buf[bufact++] = *tmp++;\n\t\t\t    }\n\t\t\t  while (*tmp != '\\0' && *tmp != '.');\n\t\t\t}\n\t\t      break;\n\t\t    case 'c':\n\t\t      /* Use code set element of locale category value.  */\n\t\t      tmp = env_var;\n\t\t      do\n\t\t\t++tmp;\n\t\t      while (*tmp != '\\0' && *tmp != '.');\n\t\t      if (*tmp == '.')\n\t\t\t{\n\t\t\t  ++tmp;\n\t\t\t  do\n\t\t\t    {\n\t\t\t      ENOUGH (1);\n\t\t\t      buf[bufact++] = *tmp++;\n\t\t\t    }\n\t\t\t  while (*tmp != '\\0');\n\t\t\t}\n\t\t      break;\n\t\t    case '%':\n\t\t      ENOUGH (1);\n\t\t      buf[bufact++] = '%';\n\t\t      break;\n\t\t    default:\n\t\t      /* Unknown variable: ignore this path element.  */\n\t\t      bufact = 0;\n\t\t      while (*run_nlspath != '\\0' && *run_nlspath != ':')\n\t\t\t++run_nlspath;\n\t\t      break;\n\t\t    }\n\t\t}\n\t      else\n\t\t{\n\t\t  ENOUGH (1);\n\t\t  buf[bufact++] = *run_nlspath++;\n\t\t}\n\n\t  ENOUGH (1);\n\t  buf[bufact] = '\\0';\n\n\t  if (bufact != 0)\n\t    {\n\t      fd = __open_nocancel (buf, O_RDONLY | O_CLOEXEC);\n\t      if (fd >= 0)\n\t\tbreak;\n\t    }\n\n\t  ++run_nlspath;\n\t}\n    }\n\n  /* Avoid dealing with directories and block devices */\n  if (__builtin_expect (fd, 0) < 0)\n    {\n      free (buf);\n      return -1;\n    }\n\n  if (__glibc_unlikely (__fstat64_time64 (fd, &st) < 0))\n    goto close_unlock_return;\n\n  if (__builtin_expect (!S_ISREG (st.st_mode), 0)\n      || (size_t) st.st_size < sizeof (struct catalog_obj))\n    {\n      /* `errno' is not set correctly but the file is not usable.\n\t Use an reasonable error value.  */\n      __set_errno (EINVAL);\n      goto close_unlock_return;\n    }\n\n  catalog->file_size = st.st_size;\n#ifdef _POSIX_MAPPED_FILES\n# ifndef MAP_COPY\n    /* Linux seems to lack read-only copy-on-write.  */\n#  define MAP_COPY MAP_PRIVATE\n# endif\n# ifndef MAP_FILE\n    /* Some systems do not have this flag; it is superfluous.  */\n#  define MAP_FILE 0\n# endif\n  catalog->file_ptr =\n    (struct catalog_obj *) __mmap (NULL, st.st_size, PROT_READ,\n\t\t\t\t   MAP_FILE|MAP_COPY, fd, 0);\n  if (__builtin_expect (catalog->file_ptr != (struct catalog_obj *) MAP_FAILED,\n\t\t\t1))\n    /* Tell the world we managed to mmap the file.  */\n    catalog->status = mmapped;\n  else\n#endif /* _POSIX_MAPPED_FILES */\n    {\n      /* mmap failed perhaps because the system call is not\n\t implemented.  Try to load the file.  */\n      size_t todo;\n      catalog->file_ptr = malloc (st.st_size);\n      if (catalog->file_ptr == NULL)\n\tgoto close_unlock_return;\n\n      todo = st.st_size;\n      /* Save read, handle partial reads.  */\n      do\n\t{\n\t  size_t now = __read_nocancel (fd, (((char *) catalog->file_ptr)\n\t\t\t\t\t     + (st.st_size - todo)), todo);\n\t  if (now == 0 || now == (size_t) -1)\n\t    {\n#ifdef EINTR\n\t      if (now == (size_t) -1 && errno == EINTR)\n\t\tcontinue;\n#endif\n\t      free ((void *) catalog->file_ptr);\n\t      goto close_unlock_return;\n\t    }\n\t  todo -= now;\n\t}\n      while (todo > 0);\n      catalog->status = malloced;\n    }\n\n  /* Determine whether the file is a catalog file and if yes whether\n     it is written using the correct byte order.  Else we have to swap\n     the values.  */\n  if (__glibc_likely (catalog->file_ptr->magic == CATGETS_MAGIC))\n    swapping = 0;\n  else if (catalog->file_ptr->magic == SWAPU32 (CATGETS_MAGIC))\n    swapping = 1;\n  else\n    {\n    invalid_file:\n      /* Invalid file.  Free the resources and mark catalog as not\n\t usable.  */\n#ifdef _POSIX_MAPPED_FILES\n      if (catalog->status == mmapped)\n\t__munmap ((void *) catalog->file_ptr, catalog->file_size);\n      else\n#endif\t/* _POSIX_MAPPED_FILES */\n\tfree (catalog->file_ptr);\n      goto close_unlock_return;\n    }\n\n#define SWAP(x) (swapping ? SWAPU32 (x) : (x))\n\n  /* Get dimensions of the used hashing table.  */\n  catalog->plane_size = SWAP (catalog->file_ptr->plane_size);\n  catalog->plane_depth = SWAP (catalog->file_ptr->plane_depth);\n\n  /* The file contains two versions of the pointer tables.  Pick the\n     right one for the local byte order.  */\n#if __BYTE_ORDER == __LITTLE_ENDIAN\n  catalog->name_ptr = &catalog->file_ptr->name_ptr[0];\n#elif __BYTE_ORDER == __BIG_ENDIAN\n  catalog->name_ptr = &catalog->file_ptr->name_ptr[catalog->plane_size\n\t\t\t\t\t\t  * catalog->plane_depth\n\t\t\t\t\t\t  * 3];\n#else\n# error Cannot handle __BYTE_ORDER byte order\n#endif\n\n  /* The rest of the file contains all the strings.  They are\n     addressed relative to the position of the first string.  */\n  catalog->strings =\n    (const char *) &catalog->file_ptr->name_ptr[catalog->plane_size\n\t\t\t\t\t       * catalog->plane_depth * 3 * 2];\n\n  /* Determine the largest string offset mentioned in the table.  */\n  max_offset = 0;\n  tab_size = 3 * catalog->plane_size * catalog->plane_depth;\n  for (cnt = 2; cnt < tab_size; cnt += 3)\n    if (catalog->name_ptr[cnt] > max_offset)\n      max_offset = catalog->name_ptr[cnt];\n\n  /* Now we can check whether the file is large enough to contain the\n     tables it says it contains.  */\n  if ((size_t) st.st_size\n      <= (sizeof (struct catalog_obj) + 2 * tab_size + max_offset))\n    /* The last string is not contained in the file.  */\n    goto invalid_file;\n\n  lastp = catalog->strings + max_offset;\n  max_offset = (st.st_size\n\t\t- sizeof (struct catalog_obj) + 2 * tab_size + max_offset);\n  while (*lastp != '\\0')\n    {\n      if (--max_offset == 0)\n\tgoto invalid_file;\n      ++lastp;\n    }\n\n  /* We succeeded.  */\n  result = 0;\n\n  /* Release the lock again.  */\n close_unlock_return:\n  __close_nocancel_nostatus (fd);\n  free (buf);\n\n  return result;\n}",
    "__errno_location": "*\n__errno_location (void){\n  return &errno;\n}",
    "__gmon_start__": "__gmon_start__ (void){\n  /* Protect from being called more than once.  Since crti.o is linked\n     into every shared library, each of their init functions will call us.  */\n  static int called;\n\n  if (called)\n    return;\n\n  called = 1;\n\n  /* Start keeping profiling records.  */\n  __monstartup ((u_long) &__executable_start, (u_long) &etext);\n\n  /* Call _mcleanup before exiting; it will write out gmon.out from the\n     collected data.  */\n  atexit (&_mcleanup);\n}",
    "__libc_init_first": "__libc_init_first (int argc, char **argv, char **envp){\n  /* Everything was done in the shared library initializer, _init.  */\n}",
    "isblank": "isblank (int c){\n  return __isctype (c, _ISblank);\n}",
    "__isblank_l": "__isblank_l (int c, locale_t l){\n  return __isctype_l (c, _ISblank, l);\n}",
    "_tolower": "_tolower (int c){\n  return __ctype_tolower[c];\n}",
    "_toupper": "_toupper (int c){\n  return __ctype_toupper[c];\n}",
    "toascii": "toascii (int c){\n  return __toascii (c);\n}",
    "isascii": "isascii (int c){\n  return __isascii (c);\n}",
    "tolower": "tolower (int c){\n  return c >= -128 && c < 256 ? __ctype_tolower[c] : c;\n}",
    "toupper": "toupper (int c){\n  return c >= -128 && c < 256 ? __ctype_toupper[c] : c;\n}",
    "__isctype": "__isctype (int ch, int mask){\n  return (((uint16_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_CLASS) + 128)\n\t  [(int) (ch)] & mask);\n}",
    "__backtrace": "__backtrace (void **array, int size){\n  int count;\n  struct trace_arg arg =\n    {\n     .array = array,\n     .unwind_link = __libc_unwind_link_get (),\n     .size = size,\n     .cnt = -1,\n    };\n\n  if (size <= 0)\n    return 0;\n\n  if (arg.unwind_link == NULL)\n    {\n      struct layout *current;\n      unsigned long fp, i7;\n\n      asm volatile (\"mov %%fp, %0\" : \"=r\"(fp));\n      asm volatile (\"mov %%i7, %0\" : \"=r\"(i7));\n      current = (struct layout *) (fp + BACKTRACE_STACK_BIAS);\n\n      array[0] = (void *) i7;\n\n      if (size == 1)\n\treturn 1;\n\n      backtrace_flush_register_windows();\n      for (count = 1; count < size; count++)\n\t{\n\t  array[count] = current->return_address;\n\t  if (!current->next)\n\t    break;\n\t  current = (struct layout *) (current->next + BACKTRACE_STACK_BIAS);\n\t}\n    }\n  else\n    {\n      UNWIND_LINK_PTR (arg.unwind_link, _Unwind_Backtrace)\n\t(backtrace_helper, &arg);\n\n      /* _Unwind_Backtrace seems to put NULL address above\n\t _start.  Fix it up here.  */\n      if (arg.cnt > 1 && arg.array[arg.cnt - 1] == NULL)\n\t--arg.cnt;\n      count = arg.cnt != -1 ? arg.cnt : 0;\n    }\n  return count;\n}",
    "__backtrace_symbols": "**\n__backtrace_symbols (void *const *array, int size){\n  Dl_info info[size];\n  int status[size];\n  int cnt;\n  size_t total = 0;\n  char **result;\n\n  /* Fill in the information we can get from `dladdr'.  */\n  for (cnt = 0; cnt < size; ++cnt)\n    {\n      struct link_map *map;\n      status[cnt] = _dl_addr (array[cnt], &info[cnt], &map, NULL);\n      if (status[cnt] && info[cnt].dli_fname && info[cnt].dli_fname[0] != '\\0')\n\t{\n\t  /* We have some info, compute the length of the string which will be\n\t     \"<file-name>(<sym-name>+offset) [address].  */\n\t  total += (strlen (info[cnt].dli_fname ?: \"\")\n\t\t    + strlen (info[cnt].dli_sname ?: \"\")\n\t\t    + 3 + WORD_WIDTH + 3 + WORD_WIDTH + 5);\n\n\t  /* The load bias is more useful to the user than the load\n\t     address.  The use of these addresses is to calculate an\n\t     address in the ELF file, so its prelinked bias is not\n\t     something we want to subtract out.  */\n\t  info[cnt].dli_fbase = (void *) map->l_addr;\n\t}\n      else\n\ttotal += 5 + WORD_WIDTH;\n    }\n\n  /* Allocate memory for the result.  */\n  result = (char **) malloc (size * sizeof (char *) + total);\n  if (result != NULL)\n    {\n      char *last = (char *) (result + size);\n\n      for (cnt = 0; cnt < size; ++cnt)\n\t{\n\t  result[cnt] = last;\n\n\t  if (status[cnt]\n\t      && info[cnt].dli_fname != NULL && info[cnt].dli_fname[0] != '\\0')\n\t    {\n\t      if (info[cnt].dli_sname == NULL)\n\t\t/* We found no symbol name to use, so describe it as\n\t\t   relative to the file.  */\n\t\tinfo[cnt].dli_saddr = info[cnt].dli_fbase;\n\n\t      if (info[cnt].dli_sname == NULL && info[cnt].dli_saddr == 0)\n\t\tlast += 1 + sprintf (last, \"%s(%s) [%p]\",\n\t\t\t\t     info[cnt].dli_fname ?: \"\",\n\t\t\t\t     info[cnt].dli_sname ?: \"\",\n\t\t\t\t     array[cnt]);\n\t      else\n\t\t{\n\t\t  char sign;\n\t\t  ptrdiff_t offset;\n\t\t  if (array[cnt] >= (void *) info[cnt].dli_saddr)\n\t\t    {\n\t\t      sign = '+';\n\t\t      offset = array[cnt] - info[cnt].dli_saddr;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      sign = '-';\n\t\t      offset = info[cnt].dli_saddr - array[cnt];\n\t\t    }\n\n\t\t  last += 1 + sprintf (last, \"%s(%s%c%#tx) [%p]\",\n\t\t\t\t       info[cnt].dli_fname ?: \"\",\n\t\t\t\t       info[cnt].dli_sname ?: \"\",\n\t\t\t\t       sign, offset, array[cnt]);\n\t\t}\n\t    }\n\t  else\n\t    last += 1 + sprintf (last, \"[%p]\", array[cnt]);\n\t}\n      assert (last <= (char *) result + size * sizeof (char *) + total);\n    }\n\n  return result;\n}",
    "__backtrace_symbols_fd": "__backtrace_symbols_fd (void *const *array, int size, int fd){\n  struct iovec iov[9];\n  int cnt;\n\n  for (cnt = 0; cnt < size; ++cnt)\n    {\n      char buf[WORD_WIDTH];\n      char buf2[WORD_WIDTH];\n      Dl_info info;\n      struct link_map *map;\n      size_t last = 0;\n\n      if (_dl_addr (array[cnt], &info, &map, NULL)\n\t  && info.dli_fname != NULL && info.dli_fname[0] != '\\0')\n\t{\n\t  /* Name of the file.  */\n\t  iov[0].iov_base = (void *) info.dli_fname;\n\t  iov[0].iov_len = strlen (info.dli_fname);\n\t  last = 1;\n\n\t  if (info.dli_sname != NULL || map->l_addr != 0)\n\t    {\n\t      size_t diff;\n\n\t      iov[last].iov_base = (void *) \"(\";\n\t      iov[last].iov_len = 1;\n\t      ++last;\n\n\t      if (info.dli_sname != NULL)\n\t\t{\n\t\t  /* We have a symbol name.  */\n\t\t  iov[last].iov_base = (void *) info.dli_sname;\n\t\t  iov[last].iov_len = strlen (info.dli_sname);\n\t\t  ++last;\n\t\t}\n\t      else\n\t\t/* We have no symbol, so describe it as relative to the file.\n\t\t   The load bias is more useful to the user than the load\n\t\t   address.  The use of these addresses is to calculate an\n\t\t   address in the ELF file, so its prelinked bias is not\n\t\t   something we want to subtract out.  */\n\t\tinfo.dli_saddr = (void *) map->l_addr;\n\n\t      if (array[cnt] >= (void *) info.dli_saddr)\n\t\t{\n\t\t  iov[last].iov_base = (void *) \"+0x\";\n\t\t  diff = array[cnt] - info.dli_saddr;\n\t\t}\n\t      else\n\t\t{\n\t\t  iov[last].iov_base = (void *) \"-0x\";\n\t\t  diff = info.dli_saddr - array[cnt];\n\t\t}\n\t      iov[last].iov_len = 3;\n\t      ++last;\n\n\t      iov[last].iov_base = _itoa_word ((unsigned long int) diff,\n\t\t\t\t\t       &buf2[WORD_WIDTH], 16, 0);\n\t      iov[last].iov_len = (&buf2[WORD_WIDTH]\n\t\t\t\t   - (char *) iov[last].iov_base);\n\t      ++last;\n\n\t      iov[last].iov_base = (void *) \")\";\n\t      iov[last].iov_len = 1;\n\t      ++last;\n\t    }\n\t}\n\n      iov[last].iov_base = (void *) \"[0x\";\n      iov[last].iov_len = 3;\n      ++last;\n\n      iov[last].iov_base = _itoa_word ((unsigned long int) array[cnt],\n\t\t\t\t       &buf[WORD_WIDTH], 16, 0);\n      iov[last].iov_len = &buf[WORD_WIDTH] - (char *) iov[last].iov_base;\n      ++last;\n\n      iov[last].iov_base = (void *) \"]\\n\";\n      iov[last].iov_len = 2;\n      ++last;\n\n      __writev (fd, iov, last);\n    }\n}",
    "__chk_fail": "__chk_fail (void){\n  __fortify_fail (\"buffer overflow detected\");\n}",
    "__confstr_chk": "__confstr_chk (int name, char *buf, size_t len, size_t buflen){\n  if (__glibc_unlikely (buflen < len))\n    __chk_fail ();\n\n  return confstr (name, buf, len);\n}",
    "__dprintf_chk": "__dprintf_chk (int d, int flag, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vdprintf_chk (d, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__explicit_bzero_chk": "__explicit_bzero_chk (void *dst, size_t len, size_t dstlen){\n  /* Inline __memset_chk to avoid a PLT reference to __memset_chk.  */\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n  memset (dst, '\\0', len);\n  /* Compiler barrier.  */\n  asm volatile (\"\" ::: \"memory\");\n}",
    "__fdelt_chk": "__fdelt_chk (long int d){\n  if (d < 0 || d >= FD_SETSIZE)\n    __fortify_fail (\"bit out of range 0 - FD_SETSIZE on fd_set\");\n\n  return d / __NFDBITS;\n}",
    "__fgets_chk": "*\n__fgets_chk (char *buf, size_t size, int n, FILE *fp){\n  size_t count;\n  char *result;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  int old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getline (fp, buf, MIN ((size_t) n - 1, size), '\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "__fgets_unlocked_chk": "*\n__fgets_unlocked_chk (char *buf, size_t size, int n, FILE *fp){\n  size_t count;\n  char *result;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  int old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getline (fp, buf, MIN ((size_t) n - 1, size), '\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  return result;\n}",
    "__fgetws_chk": "*\n__fgetws_chk (wchar_t *buf, size_t size, int n, FILE *fp){\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, MIN ((size_t) n - 1, size), L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || (_IO_ferror_unlocked (fp) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "__fgetws_unlocked_chk": "*\n__fgetws_unlocked_chk (wchar_t *buf, size_t size, int n, FILE *fp){\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, MIN ((size_t) n - 1, size), L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else if (count >= size)\n    __chk_fail ();\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  return result;\n}",
    "__fortify_fail": "__fortify_fail (const char *msg){\n  __libc_message (\"*** %s ***: terminated\\n\", msg);\n}",
    "__fread_chk": "__fread_chk (void *__restrict ptr, size_t ptrlen,\n\t     size_t size, size_t n, FILE *__restrict stream){\n  size_t bytes_requested = size * n;\n  if (__builtin_expect ((n | size)\n\t\t\t>= (((size_t) 1) << (8 * sizeof (size_t) / 2)), 0))\n    {\n      if (size != 0 && bytes_requested / size != n)\n\t__chk_fail ();\n    }\n\n  if (__glibc_unlikely (bytes_requested > ptrlen))\n    __chk_fail ();\n\n  CHECK_FILE (stream, 0);\n  if (bytes_requested == 0)\n    return 0;\n\n  size_t bytes_read;\n  _IO_acquire_lock (stream);\n  bytes_read = _IO_sgetn (stream, (char *) ptr, bytes_requested);\n  _IO_release_lock (stream);\n  return bytes_requested == bytes_read ? n : bytes_read / size;\n}",
    "__fread_unlocked_chk": "__fread_unlocked_chk (void *__restrict ptr, size_t ptrlen,\n\t\t      size_t size, size_t n, FILE *__restrict stream){\n  size_t bytes_requested = size * n;\n  if (__builtin_expect ((n | size)\n\t\t\t>= (((size_t) 1) << (8 * sizeof (size_t) / 2)), 0))\n    {\n      if (size != 0 && bytes_requested / size != n)\n\t__chk_fail ();\n    }\n\n  if (__glibc_unlikely (bytes_requested > ptrlen))\n    __chk_fail ();\n\n  CHECK_FILE (stream, 0);\n  if (bytes_requested == 0)\n    return 0;\n\n  size_t bytes_read = _IO_sgetn (stream, (char *) ptr, bytes_requested);\n  return bytes_requested == bytes_read ? n : bytes_read / size;\n}",
    "__fwprintf_chk": "attribute_hidden\n__fwprintf_chk (FILE *stream, int flag, const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vfwprintf_chk (stream, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__getcwd_chk": "*\n__getcwd_chk (char *buf, size_t size, size_t buflen){\n  if (size > buflen)\n    __chk_fail ();\n\n  return __getcwd (buf, size);\n}",
    "__getdomainname_chk": "__getdomainname_chk (char *buf, size_t buflen, size_t nreal){\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return getdomainname (buf, buflen);\n}",
    "__getgroups_chk": "__getgroups_chk (int size, __gid_t list[], size_t listlen){\n  if (__glibc_unlikely (size < 0))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (__glibc_unlikely (size * sizeof (__gid_t) > listlen))\n    __chk_fail ();\n\n  return __getgroups (size, list);\n}",
    "__gethostname_chk": "__gethostname_chk (char *buf, size_t buflen, size_t nreal){\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return __gethostname (buf, buflen);\n}",
    "__gets_chk": "*\n__gets_chk (char *buf, size_t size){\n  size_t count;\n  int ch;\n  char *retval;\n\n  if (size == 0)\n    __chk_fail ();\n\n  _IO_acquire_lock (stdin);\n  ch = _IO_getc_unlocked (stdin);\n  if (ch == EOF)\n    {\n      retval = NULL;\n      goto unlock_return;\n    }\n  if (ch == '\\n')\n    count = 0;\n  else\n    {\n      /* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */\n      int old_error = stdin->_flags & _IO_ERR_SEEN;\n      stdin->_flags &= ~_IO_ERR_SEEN;\n      buf[0] = (char) ch;\n      count = _IO_getline (stdin, buf + 1, size - 1, '\\n', 0) + 1;\n      if (stdin->_flags & _IO_ERR_SEEN)\n\t{\n\t  retval = NULL;\n\t  goto unlock_return;\n\t}\n      else\n\tstdin->_flags |= old_error;\n    }\n  if (count >= size)\n    __chk_fail ();\n  buf[count] = 0;\n  retval = buf;\nunlock_return:\n  _IO_release_lock (stdin);\n  return retval;\n}",
    "__getwd_chk": "*\n__getwd_chk (char *buf, size_t buflen){\n  char *res = __getcwd (buf, buflen);\n  if (res == NULL && errno == ERANGE)\n    __chk_fail ();\n  return res;\n}",
    "__mbsnrtowcs_chk": "__mbsnrtowcs_chk (wchar_t *dst, const char **src, size_t nmc, size_t len,\n\t\t  mbstate_t *ps, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __mbsnrtowcs (dst, src, nmc, len, ps);\n}",
    "__mbsrtowcs_chk": "__mbsrtowcs_chk (wchar_t *dst, const char **src, size_t len,\n\t\t mbstate_t *ps, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __mbsrtowcs (dst, src, len, ps);\n}",
    "__mbstowcs_chk": "__mbstowcs_chk (wchar_t *dst, const char *src, size_t len, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n  /* Return how many we wrote (or maybe an error).  */\n  return __mbsrtowcs (dst, &src, len, &state);\n}",
    "__memcpy_chk": "*\n__memcpy_chk (void *dstpp, const void *srcpp, size_t len, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return memcpy (dstpp, srcpp, len);\n}",
    "__mempcpy_chk": "*\n__mempcpy_chk (void *dstpp, const void *srcpp, size_t len, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __mempcpy (dstpp, srcpp, len);\n}",
    "__memset_chk": "*\n__memset_chk (void *dstpp, int c, size_t len, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return memset (dstpp, c, len);\n}",
    "__cyg_profile_func_enter": "__cyg_profile_func_enter (void *this_fn, void *call_site){\n  void *buf[2];\n\n  if (! active)\n    return;\n\n  /* Now write out the current position and that of the caller.  We do\n     this now, and don't cache the because we want real-time output.  */\n  buf[0] = this_fn;\n  buf[1] = call_site;\n\n  write (fd, buf, sizeof buf);\n}",
    "__obstack_printf_chk": "__obstack_printf_chk (struct obstack *obstack, int flag, const char *fmt, ...){\n  int result;\n  va_list ap;\n  va_start (ap, fmt);\n  result = __nldbl___obstack_vprintf_chk (obstack, flag, fmt, ap);\n  va_end (ap);\n  return result;\n}",
    "__poll_chk": "__poll_chk (struct pollfd *fds, nfds_t nfds, int timeout, __SIZE_TYPE__ fdslen){\n  if (fdslen / sizeof (*fds) < nfds)\n    __chk_fail ();\n\n  return __poll (fds, nfds, timeout);\n}",
    "__ppoll_chk": "__ppoll_chk (struct pollfd *fds, nfds_t nfds, const struct timespec *tmo,\n\t     const __sigset_t *ss, __SIZE_TYPE__ fdslen){\n  if (fdslen / sizeof (*fds) < nfds)\n    __chk_fail ();\n\n  return ppoll (fds, nfds, tmo, ss);\n}",
    "__pread64_chk": "__pread64_chk (int fd, void *buf, size_t nbytes, off64_t offset, size_t buflen){\n  if (nbytes > buflen)\n    __chk_fail ();\n\n  return __libc_pread64 (fd, buf, nbytes, offset);\n}",
    "__pread_chk": "__pread_chk (int fd, void *buf, size_t nbytes, off_t offset, size_t buflen){\n  if (nbytes > buflen)\n    __chk_fail ();\n\n  return __pread (fd, buf, nbytes, offset);\n}",
    "__read_chk": "__read_chk (int fd, void *buf, size_t nbytes, size_t buflen){\n  if (nbytes > buflen)\n    __chk_fail ();\n\n  return __read (fd, buf, nbytes);\n}",
    "__readlink_chk": "__readlink_chk (const char *__restrict path, char *__restrict buf, size_t len,\n\t\tsize_t buflen){\n  if (len > buflen)\n    __chk_fail ();\n\n  return __readlink (path, buf, len);\n}",
    "__readlinkat_chk": "__readlinkat_chk (int fd, const char *__restrict path,\n\t\t  char *__restrict buf, size_t len,\n\t\t  size_t buflen){\n  if (len > buflen)\n    __chk_fail ();\n\n  return readlinkat (fd, path, buf, len);\n}",
    "__realpath_chk": "*\n__realpath_chk (const char *buf, char *resolved, size_t resolvedlen){\n#ifdef PATH_MAX\n  if (resolvedlen < PATH_MAX)\n    __chk_fail ();\n\n  return __realpath (buf, resolved);\n#else\n  long int pathmax;\n\n  if (buf == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  pathmax = __pathconf (buf, _PC_PATH_MAX);\n  if (pathmax != -1)\n    {\n      /* We do have a fixed limit.  */\n      if (resolvedlen < pathmax)\n\t__chk_fail ();\n\n      return __realpath (buf, resolved);\n    }\n\n  /* Since there is no fixed limit we check whether the size is large\n     enough.  */\n  char *res = __realpath (buf, NULL);\n  if (res != NULL)\n    {\n      size_t actlen = strlen (res) + 1;\n      if (actlen > resolvedlen)\n\t__chk_fail ();\n\n      memcpy (resolved, res, actlen);\n      free (res);\n      res = resolved;\n    }\n\n  return res;\n#endif\n}",
    "__recv_chk": "__recv_chk (int fd, void *buf, size_t n, size_t buflen, int flags){\n  if (n > buflen)\n    __chk_fail ();\n\n  return __recv (fd, buf, n, flags);\n}",
    "__recvfrom_chk": "__recvfrom_chk (int fd, void *buf, size_t n, size_t buflen, int flags,\n\t\t__SOCKADDR_ARG addr, socklen_t *addr_len){\n  if (n > buflen)\n    __chk_fail ();\n\n  return __recvfrom (fd, buf, n, flags, addr, addr_len);\n}",
    "__stack_chk_fail": "__stack_chk_fail (void){\n  __fortify_fail (\"stack smashing detected\");\n}",
    "__stpcpy_chk": "*\n__stpcpy_chk (char *dest, const char *src, size_t destlen){\n  size_t len = strlen (src);\n  if (len >= destlen)\n    __chk_fail ();\n\n  return memcpy (dest, src, len + 1) + len;\n}",
    "__stpncpy_chk": "*\n__stpncpy_chk (char *dest, const char *src, size_t n, size_t destlen){\n  if (__builtin_expect (destlen < n, 0))\n    __chk_fail ();\n\n  return __stpncpy (dest, src, n);\n}",
    "__strcat_chk": "*\n__strcat_chk (char *dest, const char *src, size_t destlen){\n  char *s1 = dest;\n  const char *s2 = src;\n  char c;\n\n  /* Find the end of the string.  */\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s1++;\n    }\n  while (c != '\\0');\n\n  /* Make S1 point before the next character, so we can increment\n     it while memory is read (wins on pipelined cpus).  */\n  ++destlen;\n  s1 -= 2;\n\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s2++;\n      *++s1 = c;\n    }\n  while (c != '\\0');\n\n  return dest;\n}",
    "__strcpy_chk": "*\n__strcpy_chk (char *dest, const char *src, size_t destlen){\n  size_t len = strlen (src);\n  if (len >= destlen)\n    __chk_fail ();\n\n  return memcpy (dest, src, len + 1);\n}",
    "__strlcat_chk": "__strlcat_chk (char *__restrict s1, const char *__restrict s2,\n\t       size_t n, size_t s1len){\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __strlcat (s1, s2, n);\n}",
    "__strlcpy_chk": "__strlcpy_chk (char *__restrict s1, const char *__restrict s2,\n\t       size_t n, size_t s1len){\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __strlcpy (s1, s2, n);\n}",
    "__strncat_chk": "*\n__strncat_chk (char *s1, const char *s2, size_t n, size_t s1len){\n  char c;\n  char *s = s1;\n\n  /* Find the end of S1.  */\n  do\n    {\n      if (__glibc_unlikely (s1len-- == 0))\n\t__chk_fail ();\n      c = *s1++;\n    }\n  while (c != '\\0');\n\n  /* Make S1 point before next character, so we can increment\n     it while memory is read (wins on pipelined cpus).  */\n  ++s1len;\n  s1 -= 2;\n\n  if (n >= 4)\n    {\n      size_t n4 = n >> 2;\n      do\n\t{\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t  if (__glibc_unlikely (s1len-- == 0))\n\t    __chk_fail ();\n\t  c = *s2++;\n\t  *++s1 = c;\n\t  if (c == '\\0')\n\t    return s;\n\t} while (--n4 > 0);\n      n &= 3;\n    }\n\n  while (n > 0)\n    {\n      if (__glibc_unlikely (s1len-- == 0))\n\t__chk_fail ();\n      c = *s2++;\n      *++s1 = c;\n      if (c == '\\0')\n\treturn s;\n      n--;\n    }\n\n  if (c != '\\0')\n    {\n      if (__glibc_unlikely (s1len-- == 0))\n\t__chk_fail ();\n      *++s1 = '\\0';\n    }\n\n  return s;\n}",
    "__strncpy_chk": "*\n__strncpy_chk (char *s1, const char *s2, size_t n, size_t s1len){\n  if (__builtin_expect (s1len < n, 0))\n    __chk_fail ();\n\n  return strncpy (s1, s2, n);\n}",
    "__swprintf_chk": "attribute_hidden\n__swprintf_chk (wchar_t *s, size_t n, int flag, size_t slen,\n\t\tconst wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vswprintf_chk (s, n, flag, slen, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__ttyname_r_chk": "__ttyname_r_chk (int fd, char *buf, size_t buflen, size_t nreal){\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return __ttyname_r (fd, buf, buflen);\n}",
    "__vasprintf_chk": "attribute_hidden\n__vasprintf_chk (char **result_ptr, int flag, const char *fmt, va_list ap){\n  return __nldbl___vasprintf_chk (result_ptr, flag, fmt, ap);\n}",
    "__vdprintf_chk": "attribute_hidden\n__vdprintf_chk (int d, int flag, const char *fmt, va_list arg){\n  return __nldbl___vdprintf_chk (d, flag, fmt, arg);\n}",
    "__vfwprintf_chk": "attribute_hidden\n__vfwprintf_chk (FILE *s, int flag, const wchar_t *fmt, va_list ap){\n  return __nldbl___vfwprintf_chk (s, flag, fmt, ap);\n}",
    "__obstack_vprintf_chk": "__obstack_vprintf_chk (struct obstack *obstack, int flag, const char *fmt,\n\t\t       va_list ap){\n  return __nldbl___obstack_vprintf_chk (obstack, flag, fmt, ap);\n}",
    "__vswprintf_chk": "attribute_hidden\n__vswprintf_chk (wchar_t *string, size_t maxlen, int flag, size_t slen,\n\t\t const wchar_t *fmt, va_list ap){\n  return __nldbl___vswprintf_chk (string, maxlen, flag, slen, fmt, ap);\n}",
    "__vwprintf_chk": "attribute_hidden\n__vwprintf_chk (int flag, const wchar_t *fmt, va_list ap){\n  return __nldbl___vfwprintf_chk (stdout, flag, fmt, ap);\n}",
    "__wcpcpy_chk": "*\n__wcpcpy_chk (wchar_t *dest, const wchar_t *src, size_t destlen){\n  do\n    if (destlen-- == 0)\n      __chk_fail ();\n  while ((*dest++ = *src++));\n\n  return dest - 1;\n}",
    "__wcpncpy_chk": "*\n__wcpncpy_chk (wchar_t *dest, const wchar_t *src, size_t n, size_t destlen){\n  if (__glibc_unlikely (destlen < n))\n    __chk_fail ();\n\n  /* This function is not often enough used to justify not using a\n     tail call.  */\n  return __wcpncpy (dest, src, n);\n}",
    "__wcrtomb_chk": "__wcrtomb_chk (char *s, wchar_t wchar, mbstate_t *ps, size_t buflen){\n  return __wcrtomb_internal (s, wchar, ps, buflen);\n}",
    "__wcscat_chk": "*\n__wcscat_chk (wchar_t *dest, const wchar_t *src, size_t destlen){\n  wchar_t *s1 = dest;\n  const wchar_t *s2 = src;\n  wchar_t c;\n\n  /* Find the end of the string.  */\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s1++;\n    }\n  while (c != L'\\0');\n\n  /* Make S1 point before the next character, so we can increment\n     it while memory is read (wins on pipelined cpus).\t*/\n  s1 -= 2;\n  ++destlen;\n\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *s2++;\n      *++s1 = c;\n    }\n  while (c != L'\\0');\n\n  return dest;\n}",
    "__wcscpy_chk": "*\n__wcscpy_chk (wchar_t *dest, const wchar_t *src, size_t n){\n  wint_t c;\n  wchar_t *wcp = dest;\n\n  do\n    {\n      if (__glibc_unlikely (n-- == 0))\n        __chk_fail ();\n      c = *src++;\n      *wcp++ = c;\n    }\n  while (c != L'\\0');\n\n  return dest;\n}",
    "__wcslcat_chk": "__wcslcat_chk (wchar_t *__restrict s1, const wchar_t *__restrict s2,\n               size_t n, size_t s1len){\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __wcslcat (s1, s2, n);\n}",
    "__wcslcpy_chk": "__wcslcpy_chk (wchar_t *__restrict s1, const wchar_t *__restrict s2,\n\t       size_t n, size_t s1len){\n  if (__glibc_unlikely (s1len < n))\n    __chk_fail ();\n\n  return __wcslcpy (s1, s2, n);\n}",
    "__wcsncat_chk": "*\n__wcsncat_chk (wchar_t *dest, const wchar_t *src, size_t n, size_t destlen){\n  wchar_t c;\n  wchar_t * const s = dest;\n\n  /* Find the end of DEST.  */\n  do\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *dest++;\n    }\n  while (c != L'\\0');\n\n  /* Make DEST point before next character, so we can increment\n     it while memory is read (wins on pipelined cpus).\t*/\n  ++destlen;\n  dest -= 2;\n\n  if (n >= 4)\n    {\n      size_t n4 = n >> 2;\n      do\n\t{\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t  if (__glibc_unlikely (destlen-- == 0))\n\t    __chk_fail ();\n\t  c = *src++;\n\t  *++dest = c;\n\t  if (c == L'\\0')\n\t    return s;\n\t} while (--n4 > 0);\n      n &= 3;\n    }\n\n  while (n > 0)\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      c = *src++;\n      *++dest = c;\n      if (c == L'\\0')\n\treturn s;\n      n--;\n    }\n\n  if (c != L'\\0')\n    {\n      if (__glibc_unlikely (destlen-- == 0))\n\t__chk_fail ();\n      *++dest = L'\\0';\n    }\n\n  return s;\n}",
    "__wcsncpy_chk": "*\n__wcsncpy_chk (wchar_t *dest, const wchar_t *src, size_t n, size_t destlen){\n  if (__glibc_unlikely (destlen < n))\n    __chk_fail ();\n\n  /* This function is not often enough used to justify not using a\n     tail call.  */\n  return __wcsncpy (dest, src, n);\n}",
    "__wcsnrtombs_chk": "__wcsnrtombs_chk (char *dst, const wchar_t **src, size_t nwc, size_t len,\n\t\t  mbstate_t *ps, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __wcsnrtombs (dst, src, nwc, len, ps);\n}",
    "__wcsrtombs_chk": "__wcsrtombs_chk (char *dst, const wchar_t **src, size_t len,\n\t\t mbstate_t *ps, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  return __wcsrtombs (dst, src, len, ps);\n}",
    "__wcstombs_chk": "__wcstombs_chk (char *dst, const wchar_t *src, size_t len, size_t dstlen){\n  if (__glibc_unlikely (dstlen < len))\n    __chk_fail ();\n\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n\n  /* Return how many we wrote (or maybe an error).  */\n  return __wcsrtombs (dst, &src, len, &state);\n}",
    "__wctomb_chk": "__wctomb_chk (char *s, wchar_t wchar, size_t buflen){\n  /* We do not have to implement the full wctomb semantics since we\n     know that S cannot be NULL when we come here.  */\n  if (buflen < MB_CUR_MAX)\n    __chk_fail ();\n\n  return __wcrtomb (s, wchar, &__wctomb_state);\n}",
    "__wmemcpy_chk": "*\n__wmemcpy_chk (wchar_t *s1, const wchar_t *s2, size_t n, size_t ns1){\n  if (__glibc_unlikely (ns1 < n))\n    __chk_fail ();\n  return (wchar_t *) memcpy ((char *) s1, (char *) s2, n * sizeof (wchar_t));\n}",
    "__wmemmove_chk": "*\n__wmemmove_chk (wchar_t *s1, const wchar_t *s2, size_t n, size_t ns1){\n  if (__glibc_unlikely (ns1 < n))\n    __chk_fail ();\n  return (wchar_t *) memmove ((char *) s1, (char *) s2, n * sizeof (wchar_t));\n}",
    "__wmempcpy_chk": "*\n__wmempcpy_chk (wchar_t *s1, const wchar_t *s2, size_t n, size_t ns1){\n  if (__glibc_unlikely (ns1 < n))\n    __chk_fail ();\n  return (wchar_t *) __mempcpy ((char *) s1, (char *) s2,\n\t\t\t\tn * sizeof (wchar_t));\n}",
    "__wmemset_chk": "*\n__wmemset_chk (wchar_t *s, wchar_t c, size_t n, size_t dstlen){\n  if (__glibc_unlikely (dstlen < n))\n    __chk_fail ();\n\n  return wmemset (s, c, n);\n}",
    "__wprintf_chk": "attribute_hidden\n__wprintf_chk (int flag, const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vfwprintf_chk (stdout, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "alphasort": "alphasort (const struct dirent **a, const struct dirent **b){\n  return strcoll ((*a)->d_name, (*b)->d_name);\n}",
    "alphasort64": "alphasort64 (const struct dirent64 **a, const struct dirent64 **b){\n  return strcoll ((*a)->d_name, (*b)->d_name);\n}",
    "getdirentries64": "getdirentries64 (int fd, char *buf, size_t nbytes, off64_t *basep){\n  off64_t base = __lseek64 (fd, (off_t) 0, SEEK_CUR);\n\n  ssize_t result = __getdents64 (fd, buf, nbytes);\n\n  if (result != -1)\n    *basep = base;\n\n  return result;\n}",
    "readdir64_r": "readdir64_r (DIR *dirp, struct dirent64 *entry, struct dirent64 **result){\n  __set_errno (ENOSYS);\n  *result = NULL;\n  return -1;\n}",
    "scandir": "scandir (const char *dir, struct dirent ***namelist,\n\t int (*select) (const struct dirent *),\n\t int (*cmp) (const struct dirent **, const struct dirent **)){\n  return __scandir_tail (__opendir (dir), namelist, select, cmp);\n}",
    "scandir64": "scandir64 (const char *dir, struct dirent64 ***namelist,\n\t   int (*select) (const struct dirent64 *),\n\t   int (*cmp) (const struct dirent64 **, const struct dirent64 **)){\n  return __scandir64_tail (__opendir (dir), namelist, select, cmp);\n}",
    "scandirat64": "scandirat64 (int dfd, const char *dir, struct dirent64 ***namelist,\n\t     int (*select) (const struct dirent64 *),\n\t     int (*cmp) (const struct dirent64 **, const struct dirent64 **)){\n  return __scandir64_tail (__opendirat (dfd, dir), namelist, select, cmp);\n}",
    "seekdir": "seekdir (DIR *dirp, long int pos){\n  __libc_lock_lock (dirp->lock);\n  (void) __lseek (dirp->fd, pos, SEEK_SET);\n  dirp->size = 0;\n  dirp->offset = 0;\n  dirp->filepos = pos;\n  __libc_lock_unlock (dirp->lock);\n}",
    "telldir": "telldir (DIR *dirp){\n  long int ret;\n\n  __libc_lock_lock (dirp->lock);\n  ret = dirp->filepos;\n  __libc_lock_unlock (dirp->lock);\n\n  return ret;\n}",
    "versionsort": "versionsort (const struct dirent **a, const struct dirent **b){\n  return __strverscmp ((*a)->d_name, (*b)->d_name);\n}",
    "versionsort64": "versionsort64 (const struct dirent64 **a, const struct dirent64 **b){\n  return __strverscmp ((*a)->d_name, (*b)->d_name);\n}",
    "malloc": "*\nmalloc (size_t size){\n  if (fail_malloc)\n    return NULL;\n\n  static void *(*original_malloc) (size_t);\n  if (original_malloc == NULL)\n    original_malloc = xdlsym (RTLD_NEXT, \"malloc\");\n  return original_malloc (size);\n}",
    "unsetenv": "unsetenv (const char *name){\n  size_t len;\n  char **ep;\n\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  len = strlen (name);\n\n  LOCK;\n\n  ep = __environ;\n  if (ep != NULL)\n    while (*ep != NULL)\n      {\n\tif (!strncmp (*ep, name, len) && (*ep)[len] == '=')\n\t  {\n\t    /* Found it.  Remove this pointer by moving later ones back.  */\n\t    char **dp = ep;\n\n\t    do\n\t\tdp[0] = dp[1];\n\t    while (*dp++);\n\t    /* Continue the loop in case NAME appears again.  */\n\t  }\n\telse\n\t  ++ep;\n      }\n\n  UNLOCK;\n\n  return 0;\n}",
    "_dl_find_object": "_dl_find_object (void *address, struct dl_find_object *result){\n  return GLRO (dl_find_object) (address, result);\n}",
    "__strerror_r": "*\n__strerror_r (int errnum, char *buf, size_t buflen){\n  int system;\n  int sub;\n  int code;\n  const struct error_system *es;\n  extern void __mach_error_map_compat (int *);\n\n  __mach_error_map_compat (&errnum);\n\n  system = err_get_system (errnum);\n  sub = err_get_sub (errnum);\n  code = err_get_code (errnum);\n\n  if (system > err_max_system || ! __mach_error_systems[system].bad_sub)\n    {\n      __snprintf (buf, buflen, \"%s%X\", _(\"Error in unknown error system: \"),\n\t\t  errnum);\n      return buf;\n    }\n\n  es = &__mach_error_systems[system];\n\n  if (sub >= es->max_sub)\n    return (char *) es->bad_sub;\n\n  if (code >= es->subsystem[sub].max_code)\n    {\n      __snprintf (buf, buflen, \"%s%s %d\", _(\"Unknown error \"),\n\t\t  es->subsystem[sub].subsys_name, errnum);\n      return buf;\n    }\n\n  return (char *) _(es->subsystem[sub].codes[code]);\n}",
    "__libc_fatal": "__libc_fatal (const char *message){\n  /* The loop is added only to keep gcc happy.  */\n  while (1)\n    __libc_message (\"%s\", message);\n}",
    "_dl_mcount_wrapper": "_dl_mcount_wrapper (void *selfpc){\n  GLRO(dl_mcount) ((ElfW(Addr)) RETURN_ADDRESS (0), (ElfW(Addr)) selfpc);\n}",
    "_dl_mcount_wrapper_check": "_dl_mcount_wrapper_check (void *selfpc){\n  if (GL(dl_profile_map) != NULL)\n    GLRO(dl_mcount) ((ElfW(Addr)) RETURN_ADDRESS (0), (ElfW(Addr)) selfpc);\n}",
    "__libc_early_init": "__libc_early_init (_Bool initial){\n  /* Initialize ctype data.  */\n  __ctype_init ();\n\n  /* Only the outer namespace is marked as single-threaded.  */\n  __libc_single_threaded = initial;\n\n#ifdef SHARED\n  __libc_single_threaded_internal = __libc_initial = initial;\n#endif\n\n  __pthread_early_init ();\n\n#if ENABLE_ELISION_SUPPORT\n  __lll_elision_init ();\n#endif\n}",
    "getpid": "getpid(void){\n  pid_t (*f)(void);\n  f = (pid_t (*)(void)) dlsym (RTLD_NEXT, \"getpid\");\n  if (f == NULL)\n    error (EXIT_FAILURE, 0, \"dlsym (RTLD_NEXT, \\\"getpid\\\"): %s\", dlerror ());\n  return (pid2 = f()) + 26;\n}",
    "calloc": "*\ncalloc (size_t a, size_t b){\n  if (b > 0 && a > SIZE_MAX / b)\n    {\n      errno = ENOMEM;\n      return NULL;\n    }\n  lock ();\n  /* malloc_internal uses mmap, so the memory is zeroed.  */\n  void *result = malloc_internal (a * b);\n  unlock ();\n  return result;\n}",
    "access": "access (int i){\n  char *buf = xasprintf (\"tls_global_%02d\", i);\n  dlerror ();\n  int *p = dlsym (mod[i], buf);\n  if (test_verbose)\n    printf (\"mod[%d]: &tls = %p\\n\", i, p);\n  if (p == NULL)\n    FAIL_EXIT1 (\"dlsym failed: %s\\n\", dlerror ());\n  TEST_COMPARE (*p, 0);\n  ++*p;\n  free (buf);\n}",
    "__monstartup": "void\n__monstartup (u_long lowpc, u_long highpc){\n  int o;\n  char *cp;\n  struct gmonparam *p = &_gmonparam;\n  long int minarcs, maxarcs;\n\n  /* Read minarcs/maxarcs tunables. */\n  minarcs = TUNABLE_GET (minarcs, int32_t, NULL);\n  maxarcs = TUNABLE_GET (maxarcs, int32_t, NULL);\n  if (maxarcs < minarcs)\n    {\n      ERR(\"monstartup: maxarcs < minarcs, setting maxarcs = minarcs\\n\");\n      maxarcs = minarcs;\n    }\n\n  /*\n   * If we are incorrectly called twice in a row (without an\n   * intervening call to _mcleanup), ignore the second call to\n   * prevent leaking memory.\n   */\n  if (p->tos != NULL)\n      return;\n\n  /*\n   * round lowpc and highpc to multiples of the density we're using\n   * so the rest of the scaling (here and in gprof) stays in ints.\n   */\n  p->lowpc = ROUNDDOWN(lowpc, HISTFRACTION * sizeof(HISTCOUNTER));\n  p->highpc = ROUNDUP(highpc, HISTFRACTION * sizeof(HISTCOUNTER));\n  p->textsize = p->highpc - p->lowpc;\n  /* This looks like a typo, but it's here to align the p->froms\n     section.  */\n  p->kcountsize = ROUNDUP(p->textsize / HISTFRACTION, sizeof(*p->froms));\n  p->hashfraction = HASHFRACTION;\n  p->log_hashfraction = -1;\n  /* The following test must be kept in sync with the corresponding\n     test in mcount.c.  */\n  if ((HASHFRACTION & (HASHFRACTION - 1)) == 0) {\n      /* if HASHFRACTION is a power of two, mcount can use shifting\n\t instead of integer division.  Precompute shift amount. */\n      p->log_hashfraction = ffs(p->hashfraction * sizeof(*p->froms)) - 1;\n  }\n  p->fromssize = ROUNDUP(p->textsize / HASHFRACTION, sizeof(*p->froms));\n  p->tolimit = p->textsize * ARCDENSITY / 100;\n  if (p->tolimit < minarcs)\n    p->tolimit = minarcs;\n  else if (p->tolimit > maxarcs)\n    p->tolimit = maxarcs;\n  p->tossize = p->tolimit * sizeof(struct tostruct);\n\n  cp = calloc (p->kcountsize + p->fromssize + p->tossize, 1);\n  if (! cp)\n    {\n      ERR(\"monstartup: out of memory\\n\");\n      p->tos = NULL;\n      p->state = GMON_PROF_ERROR;\n      return;\n    }\n  p->tos = (struct tostruct *)cp;\n  cp += p->tossize;\n  p->kcount = (HISTCOUNTER *)cp;\n  cp += p->kcountsize;\n  p->froms = (ARCINDEX *)cp;\n\n  p->tos[0].link = 0;\n\n  o = p->highpc - p->lowpc;\n  if (p->kcountsize < (u_long) o)\n    {\n#ifndef hp300\n      s_scale = ((float)p->kcountsize / o ) * SCALE_1_TO_1;\n#else\n      /* avoid floating point operations */\n      int quot = o / p->kcountsize;\n\n      if (quot >= 0x10000)\n\ts_scale = 1;\n      else if (quot >= 0x100)\n\ts_scale = 0x10000 / quot;\n      else if (o >= 0x800000)\n\ts_scale = 0x1000000 / (o / (p->kcountsize >> 8));\n      else\n\ts_scale = 0x1000000 / ((o << 8) / p->kcountsize);\n#endif\n    } else\n      s_scale = SCALE_1_TO_1;\n\n  __moncontrol(1);\n}",
    "_mcleanup": "_mcleanup (void){\n  __moncontrol (0);\n\n  if (_gmonparam.state != GMON_PROF_ERROR && _gmonparam.tos != NULL)\n    write_gmon ();\n\n  /* free the memory. */\n  free (_gmonparam.tos);\n\n  /* reset buffer to initial state for safety */\n  memset(&_gmonparam, 0, sizeof _gmonparam);\n  /* somewhat confusingly, ON=0, OFF=3 */\n  _gmonparam.state = GMON_PROF_OFF;\n}",
    "__profile_frequency": "__profile_frequency (void){\n  return GLRO(dl_clktck);\n}",
    "__libc_alloca_cutoff": "__libc_alloca_cutoff (size_t size){\n  return size <= (MIN (__MAX_ALLOCA_CUTOFF,\n\t\t       THREAD_GETMEM (THREAD_SELF, stackblock_size) / 4\n\t\t       /* The main thread, before the thread library is\n\t\t\t  initialized, has zero in the stackblock_size\n\t\t\t  element.  Since it is the main thread we can\n\t\t\t  assume the maximum available stack space.  */\n\t\t       ?: __MAX_ALLOCA_CUTOFF * 4));\n}",
    "__h_errno_location": "*\n__h_errno_location (void){\n  return &__h_errno;\n}",
    "pthread_cancel": "pthread_cancel (pthread_t t){\n  int err = 0;\n  struct __pthread *p;\n\n  p = __pthread_getid (t);\n  if (p == NULL)\n    return ESRCH;\n\n  __pthread_mutex_lock (&p->cancel_lock);\n  if (p->cancel_pending)\n    {\n      __pthread_mutex_unlock (&p->cancel_lock);\n      return 0;\n    }\n\n  p->cancel_pending = 1;\n\n  if (p->cancel_state != PTHREAD_CANCEL_ENABLE)\n    {\n      __pthread_mutex_unlock (&p->cancel_lock);\n      return 0;\n    }\n\n  if (p->cancel_type == PTHREAD_CANCEL_ASYNCHRONOUS)\n    /* CANCEL_LOCK is unlocked by this call.  */\n    err = __pthread_do_cancel (p);\n  else\n    {\n      if (p->cancel_hook != NULL)\n\t/* Thread blocking on a cancellation point.  Invoke hook to unblock.\n\t   See __pthread_cond_timedwait_internal.  */\n\tp->cancel_hook (p->cancel_hook_arg);\n\n      __pthread_mutex_unlock (&p->cancel_lock);\n    }\n\n  return err;\n}",
    "pthread_sigmask": "pthread_sigmask (int how, const sigset_t *set, sigset_t *oset){\n  struct __pthread *self = _pthread_self ();\n\n  /* Do not clear SELF's pending signals.  */\n  return __pthread_sigstate (self, how, set, oset, 0);\n}",
    "pthread_yield": "pthread_yield (void){\n  return __sched_yield ();\n}",
    "free": "free (void *ptr){\n  if (ptr == NULL)\n    return;\n  lock ();\n  struct allocation_header *header = get_header (\"free\", ptr);\n  free_internal (\"free\", header);\n  unlock ();\n}",
    "realloc": "*\nrealloc (void *ptr, size_t len){\n  static void *(*fun) (void *, size_t);\n\n  if (!fun)\n    fun = dlsym (RTLD_NEXT, \"realloc\");\n\n  if (ts.tv_nsec)\n    nanosleep (&ts, NULL);\n\n  return (*fun) (ptr, len);\n}",
    "__gconv_get_cache": "*\n__gconv_get_cache (void){\n  return gconv_cache;\n}",
    "__gconv_create_spec": "*\n__gconv_create_spec (struct gconv_spec *conv_spec, const char *fromcode,\n                   const char *tocode){\n  struct gconv_parsed_code pfc, ptc;\n  struct gconv_spec *ret = NULL;\n\n  pfc.code = __strdup (fromcode);\n  ptc.code = __strdup (tocode);\n\n  if ((pfc.code == NULL)\n      || (ptc.code == NULL))\n    goto out;\n\n  gconv_parse_code (&pfc);\n  gconv_parse_code (&ptc);\n\n  /* We ignore suffixes in the fromcode because that is how the current\n     implementation has always handled them.  Only suffixes in the tocode are\n     processed and handled.  The reality is that invalid input in the input\n     character set should only be ignored if the fromcode specifies IGNORE.\n     The current implementation ignores invalid input in the input character\n     set if the tocode contains IGNORE.  We preserve this behavior for\n     backwards compatibility.  In the future we may split the handling of\n     IGNORE to allow a finer grained specification of ignoring invalid input\n     and/or ignoring invalid output.  */\n  conv_spec->translit = ptc.translit;\n  conv_spec->ignore = ptc.ignore;\n\n  /* 3 extra bytes because 1 extra for '\\0', and 2 extra so strip might\n     be able to add one or two trailing '/' characters if necessary.  */\n  conv_spec->fromcode = malloc (strlen (fromcode) + 3);\n  if (conv_spec->fromcode == NULL)\n    goto out;\n\n  conv_spec->tocode = malloc (strlen (tocode) + 3);\n  if (conv_spec->tocode == NULL)\n    {\n      free (conv_spec->fromcode);\n      conv_spec->fromcode = NULL;\n      goto out;\n    }\n\n  /* Strip unrecognized characters and ensure that the code has two '/'\n     characters as per conversion code triplet specification.  */\n  strip (conv_spec->fromcode, pfc.code);\n  strip (conv_spec->tocode, ptc.code);\n  ret = conv_spec;\n\nout:\n  free (pfc.code);\n  free (ptc.code);\n\n  return ret;\n}",
    "__gconv_destroy_spec": "__gconv_destroy_spec (struct gconv_spec *conv_spec){\n  free (conv_spec->fromcode);\n  free (conv_spec->tocode);\n  return;\n}",
    "__gconv_get_modules_db": "*\n__gconv_get_modules_db (void){\n  return __gconv_modules_db;\n}",
    "__gconv_get_alias_db": "*\n__gconv_get_alias_db (void){\n  return __gconv_alias_db;\n}",
    "__gconv_open": "__gconv_open (struct gconv_spec *conv_spec, __gconv_t *handle,\n\t      int flags){\n  struct __gconv_step *steps;\n  size_t nsteps;\n  __gconv_t result = NULL;\n  size_t cnt = 0;\n  int res;\n  int conv_flags = 0;\n  bool translit = false;\n  char *tocode, *fromcode;\n\n  /* Find out whether any error handling method is specified.  */\n  translit = conv_spec->translit;\n\n  if (conv_spec->ignore)\n    conv_flags |= __GCONV_IGNORE_ERRORS;\n\n  tocode = conv_spec->tocode;\n  fromcode = conv_spec->fromcode;\n\n  /* If the string is empty define this to mean the charset of the\n     currently selected locale.  */\n  if (strcmp (tocode, \"//\") == 0)\n    {\n      const char *codeset = _NL_CURRENT (LC_CTYPE, CODESET);\n      size_t len = strlen (codeset);\n      char *dest;\n      tocode = dest = (char *) alloca (len + 3);\n      memcpy (__mempcpy (dest, codeset, len), \"//\", 3);\n    }\n  if (strcmp (fromcode, \"//\") == 0)\n    {\n      const char *codeset = _NL_CURRENT (LC_CTYPE, CODESET);\n      size_t len = strlen (codeset);\n      char *dest;\n      fromcode = dest = (char *) alloca (len + 3);\n      memcpy (__mempcpy (dest, codeset, len), \"//\", 3);\n    }\n\n  res = __gconv_find_transform (tocode, fromcode, &steps, &nsteps, flags);\n  if (res == __GCONV_OK)\n    {\n      /* Allocate room for handle.  */\n      result = (__gconv_t) malloc (sizeof (struct __gconv_info)\n\t\t\t\t   + (nsteps\n\t\t\t\t      * sizeof (struct __gconv_step_data)));\n      if (result == NULL)\n\tres = __GCONV_NOMEM;\n      else\n\t{\n\t  /* Remember the list of steps.  */\n\t  result->__steps = steps;\n\t  result->__nsteps = nsteps;\n\n\t  /* Clear the array for the step data.  */\n\t  memset (result->__data, '\\0',\n\t\t  nsteps * sizeof (struct __gconv_step_data));\n\n\t  /* Call all initialization functions for the transformation\n\t     step implementations.  */\n\t  for (cnt = 0; cnt < nsteps; ++cnt)\n\t    {\n\t      size_t size;\n\n\t      /* Would have to be done if we would not clear the whole\n                 array above.  */\n#if 0\n\t      /* Reset the counter.  */\n\t      result->__data[cnt].__invocation_counter = 0;\n\n\t      /* It's a regular use.  */\n\t      result->__data[cnt].__internal_use = 0;\n#endif\n\n\t      /* We use the `mbstate_t' member in DATA.  */\n\t      result->__data[cnt].__statep = &result->__data[cnt].__state;\n\n\t      /* The builtin transliteration handling only\n\t\t supports the internal encoding.  */\n\t      if (translit\n\t\t  && __strcasecmp_l (steps[cnt].__from_name,\n\t\t\t\t     \"INTERNAL\", _nl_C_locobj_ptr) == 0)\n\t\tconv_flags |= __GCONV_TRANSLIT;\n\n\t      /* If this is the last step we must not allocate an\n\t\t output buffer.  */\n\t      if (cnt < nsteps - 1)\n\t\t{\n\t\t  result->__data[cnt].__flags = conv_flags;\n\n\t\t  /* Allocate the buffer.  */\n\t\t  size = (GCONV_NCHAR_GOAL * steps[cnt].__max_needed_to);\n\n\t\t  result->__data[cnt].__outbuf = malloc (size);\n\t\t  if (result->__data[cnt].__outbuf == NULL)\n\t\t    {\n\t\t      res = __GCONV_NOMEM;\n\t\t      goto bail;\n\t\t    }\n\n\t\t  result->__data[cnt].__outbufend =\n\t\t    result->__data[cnt].__outbuf + size;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Handle the last entry.  */\n\t\t  result->__data[cnt].__flags = conv_flags | __GCONV_IS_LAST;\n\n\t\t  break;\n\t\t}\n\t    }\n\t}\n\n      if (res != __GCONV_OK)\n\t{\n\t  /* Something went wrong.  Free all the resources.  */\n\t  int serrno;\n\tbail:\n\t  serrno = errno;\n\n\t  if (result != NULL)\n\t    {\n\t      while (cnt-- > 0)\n\t\tfree (result->__data[cnt].__outbuf);\n\n\t      free (result);\n\t      result = NULL;\n\t    }\n\n\t  __gconv_close_transform (steps, nsteps);\n\n\t  __set_errno (serrno);\n\t}\n    }\n\n  *handle = result;\n  return res;\n}",
    "__gconv_transliterate": "__gconv_transliterate (struct __gconv_step *step,\n\t\t       struct __gconv_step_data *step_data,\n\t\t       const unsigned char *inbufstart,\n\t\t       const unsigned char **inbufp,\n\t\t       const unsigned char *inbufend,\n\t\t       unsigned char **outbufstart, size_t *irreversible){\n  /* Find out about the locale's transliteration.  */\n  uint32_t size;\n  const uint32_t *from_idx;\n  const uint32_t *from_tbl;\n  const uint32_t *to_idx;\n  const uint32_t *to_tbl;\n  const uint32_t *winbuf;\n  const uint32_t *winbufend;\n  uint32_t low;\n  uint32_t high;\n\n  /* The input buffer.  There are actually 4-byte values.  */\n  winbuf = (const uint32_t *) *inbufp;\n  winbufend = (const uint32_t *) inbufend;\n\n  __gconv_fct fct = step->__fct;\n  if (step->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n\n  /* If there is no transliteration information in the locale don't do\n     anything and return the error.  */\n  size = _NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_TAB_SIZE);\n  if (size == 0)\n    goto no_rules;\n\n  /* Get the rest of the values.  */\n  from_idx =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_FROM_IDX);\n  from_tbl =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_FROM_TBL);\n  to_idx =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_TO_IDX);\n  to_tbl =\n    (const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_TO_TBL);\n\n  /* Test whether there is enough input.  */\n  if (winbuf + 1 > winbufend)\n    return (winbuf == winbufend\n\t    ? __GCONV_EMPTY_INPUT : __GCONV_INCOMPLETE_INPUT);\n\n  /* The array starting at FROM_IDX contains indices to the string table\n     in FROM_TBL.  The indices are sorted wrt to the strings.  I.e., we\n     are doing binary search.  */\n  low = 0;\n  high = size;\n  while (low < high)\n    {\n      uint32_t med = (low + high) / 2;\n      uint32_t idx;\n      int cnt;\n\n      /* Compare the string at this index with the string at the current\n\t position in the input buffer.  */\n      idx = from_idx[med];\n      cnt = 0;\n      do\n\t{\n\t  if (from_tbl[idx + cnt] != winbuf[cnt])\n\t    /* Does not match.  */\n\t    break;\n\t  ++cnt;\n\t}\n      while (from_tbl[idx + cnt] != L'\\0' && winbuf + cnt < winbufend);\n\n      if (cnt > 0 && from_tbl[idx + cnt] == L'\\0')\n\t{\n\t  /* Found a matching input sequence.  Now try to convert the\n\t     possible replacements.  */\n\t  uint32_t idx2 = to_idx[med];\n\n\t  do\n\t    {\n\t      /* Determine length of replacement.  */\n\t      unsigned int len = 0;\n\t      int res;\n\t      const unsigned char *toinptr;\n\t      unsigned char *outptr;\n\n\t      while (to_tbl[idx2 + len] != L'\\0')\n\t\t++len;\n\n\t      /* Try this input text.  */\n\t      toinptr = (const unsigned char *) &to_tbl[idx2];\n\t      outptr = *outbufstart;\n\t      res = DL_CALL_FCT (fct,\n\t\t\t\t (step, step_data, &toinptr,\n\t\t\t\t  (const unsigned char *) &to_tbl[idx2 + len],\n\t\t\t\t  &outptr, NULL, 0, 0));\n\t      if (res != __GCONV_ILLEGAL_INPUT)\n\t\t{\n\t\t  /* If the conversion succeeds we have to increment the\n\t\t     input buffer.  */\n\t\t  if (res == __GCONV_EMPTY_INPUT)\n\t\t    {\n\t\t      *inbufp += cnt * sizeof (uint32_t);\n\t\t      ++*irreversible;\n\t\t      res = __GCONV_OK;\n\t\t    }\n\t\t  /* Do not increment the output pointer if we could not\n\t\t     store the entire output. */\n\t\t  if (res != __GCONV_FULL_OUTPUT)\n\t\t    *outbufstart = outptr;\n\n\t\t  return res;\n\t\t}\n\n\t      /* Next replacement.  */\n\t      idx2 += len + 1;\n\t    }\n\t  while (to_tbl[idx2] != L'\\0');\n\n\t  /* Nothing found, continue searching.  */\n\t}\n      else if (cnt > 0)\n\t/* This means that the input buffer contents matches a prefix of\n\t   an entry.  Since we cannot match it unless we get more input,\n\t   we will tell the caller about it.  */\n\treturn __GCONV_INCOMPLETE_INPUT;\n\n      if (winbuf + cnt >= winbufend || from_tbl[idx + cnt] < winbuf[cnt])\n\tlow = med + 1;\n      else\n\thigh = med;\n    }\n\n no_rules:\n  /* Maybe the character is supposed to be ignored.  */\n  if (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_IGNORE_LEN) != 0)\n    {\n      int n = _NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_IGNORE_LEN);\n      const uint32_t *ranges =\n\t(const uint32_t *) _NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_IGNORE);\n      const uint32_t wc = *(const uint32_t *) (*inbufp);\n      int i;\n\n      /* Test whether there is enough input.  */\n      if (winbuf + 1 > winbufend)\n\treturn (winbuf == winbufend\n\t\t? __GCONV_EMPTY_INPUT : __GCONV_INCOMPLETE_INPUT);\n\n      for (i = 0; i < n; ranges += 3, ++i)\n\tif (ranges[0] <= wc && wc <= ranges[1]\n\t    && (wc - ranges[0]) % ranges[2] == 0)\n\t  {\n\t    /* Matches the range.  Ignore it.  */\n\t    *inbufp += 4;\n\t    ++*irreversible;\n\t    return __GCONV_OK;\n\t  }\n\telse if (wc < ranges[0])\n\t  /* There cannot be any other matching range since they are\n             sorted.  */\n\t  break;\n    }\n\n  /* One last chance: use the default replacement.  */\n  if (_NL_CURRENT_WORD (LC_CTYPE, _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN) != 0)\n    {\n      const uint32_t *default_missing = (const uint32_t *)\n\t_NL_CURRENT (LC_CTYPE, _NL_CTYPE_TRANSLIT_DEFAULT_MISSING);\n      const unsigned char *toinptr = (const unsigned char *) default_missing;\n      uint32_t len = _NL_CURRENT_WORD (LC_CTYPE,\n\t\t\t\t       _NL_CTYPE_TRANSLIT_DEFAULT_MISSING_LEN);\n      unsigned char *outptr;\n      int res;\n\n      /* Test whether there is enough input.  */\n      if (winbuf + 1 > winbufend)\n\treturn (winbuf == winbufend\n\t\t? __GCONV_EMPTY_INPUT : __GCONV_INCOMPLETE_INPUT);\n\n      outptr = *outbufstart;\n      res = DL_CALL_FCT (fct,\n\t\t\t (step, step_data, &toinptr,\n\t\t\t  (const unsigned char *) (default_missing + len),\n\t\t\t  &outptr, NULL, 0, 0));\n\n      if (res != __GCONV_ILLEGAL_INPUT)\n\t{\n\t  /* If the conversion succeeds we have to increment the\n\t     input buffer.  */\n\t  if (res == __GCONV_EMPTY_INPUT)\n\t    {\n\t      /* This worked but is not reversible.  */\n\t      ++*irreversible;\n\t      *inbufp += 4;\n\t      res = __GCONV_OK;\n\t    }\n\t  *outbufstart = outptr;\n\n\t  return res;\n\t}\n    }\n\n  /* Haven't found a match.  */\n  return __GCONV_ILLEGAL_INPUT;\n}",
    "iconv": "iconv (iconv_t cd, char **inbuf, size_t *inbytesleft, char **outbuf,\n       size_t *outbytesleft){\n  __gconv_t gcd = (__gconv_t) cd;\n  char *outstart = outbuf ? *outbuf : NULL;\n  size_t irreversible;\n  int result;\n\n  if (__glibc_unlikely (inbuf == NULL || *inbuf == NULL))\n    {\n      if (outbuf == NULL || *outbuf == NULL)\n\tresult = __gconv (gcd, NULL, NULL, NULL, NULL, &irreversible);\n      else\n\tresult = __gconv (gcd, NULL, NULL, (unsigned char **) outbuf,\n\t\t\t  (unsigned char *) (outstart + *outbytesleft),\n\t\t\t  &irreversible);\n    }\n  else\n    {\n      const char *instart = *inbuf;\n\n      result = __gconv (gcd, (const unsigned char **) inbuf,\n\t\t\t(const unsigned char *)  (*inbuf + *inbytesleft),\n\t\t\t(unsigned char **) outbuf,\n\t\t\t(unsigned char *) (*outbuf + *outbytesleft),\n\t\t\t&irreversible);\n\n      *inbytesleft -= *inbuf - instart;\n    }\n  if (outstart != NULL)\n    *outbytesleft -= *outbuf - outstart;\n\n  switch (__builtin_expect (result, __GCONV_OK))\n    {\n    case __GCONV_ILLEGAL_DESCRIPTOR:\n      __set_errno (EBADF);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_ILLEGAL_INPUT:\n      __set_errno (EILSEQ);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_FULL_OUTPUT:\n      __set_errno (E2BIG);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_INCOMPLETE_INPUT:\n      __set_errno (EINVAL);\n      irreversible = (size_t) -1L;\n      break;\n\n    case __GCONV_EMPTY_INPUT:\n    case __GCONV_OK:\n      /* Nothing.  */\n      break;\n\n    default:\n      assert (!\"Nothing like this should happen\");\n    }\n\n  return irreversible;\n}",
    "iconv_close": "iconv_close (iconv_t cd){\n  if (__glibc_unlikely (cd == (iconv_t *) -1L))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  return __gconv_close ((__gconv_t) cd) ? -1 : 0;\n}",
    "iconv_open": "iconv_open (const char *tocode, const char *fromcode){\n  __gconv_t cd;\n  struct gconv_spec conv_spec;\n\n  if (__gconv_create_spec (&conv_spec, fromcode, tocode) == NULL)\n    return (iconv_t) -1;\n\n  int res = __gconv_open (&conv_spec, &cd, 0);\n\n  __gconv_destroy_spec (&conv_spec);\n\n  if (__builtin_expect (res, __GCONV_OK) != __GCONV_OK)\n    {\n      /* We must set the error number according to the specs.  */\n      if (res == __GCONV_NOCONV || res == __GCONV_NODB)\n\t__set_errno (EINVAL);\n\n      cd = (iconv_t) -1;\n    }\n\n  return (iconv_t) cd;\n}",
    "bindresvport": "bindresvport (int sd, struct sockaddr_in *sin){\n  static short port;\n  struct sockaddr_in myaddr;\n  int i;\n\n#define STARTPORT 600\n#define LOWPORT 512\n#define ENDPORT (IPPORT_RESERVED - 1)\n#define NPORTS\t(ENDPORT - STARTPORT + 1)\n  static short startport = STARTPORT;\n\n  if (sin == (struct sockaddr_in *) 0)\n    {\n      sin = &myaddr;\n      memset (sin, 0, sizeof (*sin));\n      sin->sin_family = AF_INET;\n    }\n  else if (sin->sin_family != AF_INET)\n    {\n      __set_errno (EAFNOSUPPORT);\n      return -1;\n    }\n\n  if (port == 0)\n    {\n      port = (__getpid () % NPORTS) + STARTPORT;\n    }\n\n  /* Initialize to make gcc happy.  */\n  int res = -1;\n\n  int nports = ENDPORT - startport + 1;\n  int endport = ENDPORT;\n\n  __libc_lock_lock (lock);\n\n again:\n  for (i = 0; i < nports; ++i)\n    {\n      sin->sin_port = htons (port++);\n      if (port > endport)\n\tport = startport;\n      res = __bind (sd, sin, sizeof (struct sockaddr_in));\n      if (res >= 0 || errno != EADDRINUSE)\n\tbreak;\n    }\n\n  if (i == nports && startport != LOWPORT)\n    {\n      startport = LOWPORT;\n      endport = STARTPORT - 1;\n      nports = STARTPORT - LOWPORT;\n      port = LOWPORT + port % (STARTPORT - LOWPORT);\n      goto again;\n    }\n\n  __libc_lock_unlock (lock);\n\n  return res;\n}",
    "ether_aton": "*\nether_aton (const char *asc){\n  static struct ether_addr result;\n\n  return ether_aton_r (asc, &result);\n}",
    "ether_aton_r": "*\nether_aton_r (const char *asc, struct ether_addr *addr){\n  size_t cnt;\n\n  for (cnt = 0; cnt < 6; ++cnt)\n    {\n      unsigned int number;\n      char ch;\n\n      ch = _tolower (*asc++);\n      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\treturn NULL;\n      number = isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n      ch = _tolower (*asc);\n      if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\\0' && !isspace (ch)))\n\t{\n\t  ++asc;\n\t  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\t    return NULL;\n\t  number <<= 4;\n\t  number += isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n\t  ch = *asc;\n\t  if (cnt < 5 && ch != ':')\n\t    return NULL;\n\t}\n\n      /* Store result.  */\n      addr->ether_addr_octet[cnt] = (unsigned char) number;\n\n      /* Skip ':'.  */\n      ++asc;\n    }\n\n  return addr;\n}",
    "ether_line": "ether_line (const char *line, struct ether_addr *addr, char *hostname){\n  for (size_t cnt = 0; cnt < 6; ++cnt)\n    {\n      unsigned int number;\n      char ch;\n\n      ch = _tolower (*line++);\n      if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\treturn -1;\n      number = isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n      ch = _tolower (*line);\n      if ((cnt < 5 && ch != ':') || (cnt == 5 && ch != '\\0' && !isspace (ch)))\n\t{\n\t  ++line;\n\t  if ((ch < '0' || ch > '9') && (ch < 'a' || ch > 'f'))\n\t    return -1;\n\t  number <<= 4;\n\t  number += isdigit (ch) ? (ch - '0') : (ch - 'a' + 10);\n\n\t  ch = *line;\n\t  if (cnt < 5 && ch != ':')\n\t    return -1;\n\t}\n\n      /* Store result.  */\n      addr->ether_addr_octet[cnt] = (unsigned char) number;\n\n      /* Skip ':'.  */\n      if (ch != '\\0')\n\t++line;\n    }\n\n  /* Skip initial whitespace.  */\n  while (isspace (*line))\n    ++line;\n\n  if (*line == '#' || *line == '\\0')\n    /* No hostname.  */\n    return -1;\n\n  /* The hostname is up to the next non-space character.  */\n  /* XXX This can cause trouble because the hostname might be too long\n     but we have no possibility to check it here.  */\n  while (*line != '\\0' && *line != '#' && !isspace (*line))\n    *hostname++ = *line++;\n  *hostname = '\\0';\n\n  return 0;\n}",
    "ether_ntoa": "*\nether_ntoa (const struct ether_addr *addr){\n  static char asc[18];\n\n  return ether_ntoa_r (addr, asc);\n}",
    "ether_ntoa_r": "*\nether_ntoa_r (const struct ether_addr *addr, char *buf){\n  sprintf (buf, \"%x:%x:%x:%x:%x:%x\",\n\t   addr->ether_addr_octet[0], addr->ether_addr_octet[1],\n\t   addr->ether_addr_octet[2], addr->ether_addr_octet[3],\n\t   addr->ether_addr_octet[4], addr->ether_addr_octet[5]);\n  return buf;\n}",
    "getipv4sourcefilter": "getipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,\n\t\t     uint32_t *fmode, uint32_t *numsrc, struct in_addr *slist){\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  socklen_t needed = IP_MSFILTER_SIZE (*numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct ip_msfilter *imsf = buf.data;\n\n  imsf->imsf_multiaddr = group;\n  imsf->imsf_interface = interface;\n  imsf->imsf_numsrc = *numsrc;\n\n  int result = __getsockopt (s, SOL_IP, IP_MSFILTER, imsf, &needed);\n\n  /* If successful, copy the results to the places the caller wants\n     them in.  */\n  if (result == 0)\n    {\n      *fmode = imsf->imsf_fmode;\n      memcpy (slist, imsf->imsf_slist,\n\t      MIN (*numsrc, imsf->imsf_numsrc) * sizeof (struct in_addr));\n      *numsrc = imsf->imsf_numsrc;\n    }\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "getsourcefilter": "getsourcefilter (int s, uint32_t interface, const struct sockaddr *group,\n\t\t socklen_t grouplen, uint32_t *fmode, uint32_t *numsrc,\n\t\t struct sockaddr_storage *slist){\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  socklen_t needed = GROUP_FILTER_SIZE (*numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct group_filter *gf = buf.data;\n\n  gf->gf_interface = interface;\n  memcpy (&gf->gf_group, group, grouplen);\n  gf->gf_numsrc = *numsrc;\n\n  /* We need to provide the appropriate socket level value.  */\n  int result;\n  int sol = __get_sol (group->sa_family, grouplen);\n  if (sol == -1)\n    {\n      __set_errno (EINVAL);\n      result = -1;\n    }\n  else\n    {\n      result = __getsockopt (s, sol, MCAST_MSFILTER, gf, &needed);\n\n      /* If successful, copy the results to the places the caller wants\n\t them in.  */\n      if (result == 0)\n\t{\n\t  *fmode = gf->gf_fmode;\n\t  memcpy (slist, gf->gf_slist,\n\t\t  MIN (*numsrc, gf->gf_numsrc)\n\t\t  * sizeof (struct sockaddr_storage));\n\t  *numsrc = gf->gf_numsrc;\n\t}\n    }\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "htonl": "htonl (uint32_t x){\n#if BYTE_ORDER == BIG_ENDIAN\n  return x;\n#elif BYTE_ORDER == LITTLE_ENDIAN\n  return __bswap_32 (x);\n#else\n# error \"What kind of system is this?\"\n#endif\n}",
    "htons": "htons (uint16_t x){\n#if BYTE_ORDER == BIG_ENDIAN\n  return x;\n#elif BYTE_ORDER == LITTLE_ENDIAN\n  return __bswap_16 (x);\n#else\n# error \"What kind of system is this?\"\n#endif\n}",
    "__idna_to_dns_encoding": "__idna_to_dns_encoding (const char *name, char **result){\n  switch (__idna_name_classify (name))\n    {\n    case idna_name_ascii:\n      /* Nothing to convert.  */\n      return gai_strdup (name, result);\n    case idna_name_nonascii:\n      /* Encoding needed.  Handled below.  */\n      break;\n    case idna_name_nonascii_backslash:\n    case idna_name_encoding_error:\n      return EAI_IDN_ENCODE;\n    case idna_name_memory_error:\n      return EAI_MEMORY;\n    case idna_name_error:\n      return EAI_SYSTEM;\n    }\n\n  struct functions *functions = get_functions ();\n  if (functions == NULL)\n    /* We report this as an encoding error (assuming that libidn2 is\n       not installed), although the root cause may be a temporary\n       error condition due to resource shortage.  */\n    return EAI_IDN_ENCODE;\n  char *ptr = NULL;\n  __typeof__ (functions->lookup_ul) fptr = functions->lookup_ul;\n  PTR_DEMANGLE (fptr);\n  int ret = fptr (name, &ptr, 0);\n  if (ret == 0)\n    {\n      /* Assume that idn2_free is equivalent to free.  */\n      *result = ptr;\n      return 0;\n    }\n  else if (ret == IDN2_MALLOC)\n    return EAI_MEMORY;\n  else\n    return EAI_IDN_ENCODE;\n}",
    "__idna_from_dns_encoding": "__idna_from_dns_encoding (const char *name, char **result){\n  struct functions *functions = get_functions ();\n  if (functions == NULL)\n    /* Simply use the encoded name, assuming that it is not punycode\n       (but even a punycode name would be syntactically valid).  */\n    return gai_strdup (name, result);\n  char *ptr = NULL;\n  __typeof__ (functions->to_unicode_lzlz) fptr = functions->to_unicode_lzlz;\n  PTR_DEMANGLE (fptr);\n  int ret = fptr (name, &ptr, 0);\n  if (ret == 0)\n    {\n      /* Assume that idn2_free is equivalent to free.  */\n      *result = ptr;\n      return 0;\n    }\n  else if (ret == IDN2_MALLOC)\n    return EAI_MEMORY;\n  else\n    return EAI_IDN_ENCODE;\n}",
    "inet6_opt_init": "inet6_opt_init (void *extbuf, socklen_t extlen){\n  if (extbuf != NULL)\n    {\n      if (extlen <= 0 || (extlen % 8) != 0 || extlen > 256 * 8)\n\treturn -1;\n\n      /* Fill in the length in units of 8 octets.  */\n      struct ip6_hbh *extp = (struct ip6_hbh *) extbuf;\n\n      /* RFC 2460 requires that the header extension length is the\n\t length of the option header in 8-byte units, not including\n\t the first 8 bytes.  Hence we have to subtract one.  */\n      extp->ip6h_len = extlen / 8 - 1;\n    }\n\n  return sizeof (struct ip6_hbh);\n}",
    "inet6_opt_append": "inet6_opt_append (void *extbuf, socklen_t extlen, int offset, uint8_t type,\n\t\t  socklen_t len, uint8_t align, void **databufp){\n  /* Check minimum offset.  */\n  if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  /* One cannot add padding options.  */\n  if (type == IP6OPT_PAD1 || type == IP6OPT_PADN)\n    return -1;\n\n  /* The option length must fit in one octet.  */\n  if (len > 255)\n    return -1;\n\n  /* The alignment can only by 1, 2, 4, or 8 and must not exceed the\n     option length.  */\n  if (align == 0 || align > 8 || (align & (align - 1)) != 0 || align > len)\n    return -1;\n\n  /* Determine the needed padding for alignment.  Following the\n     current content of the buffer we have the is the IPv6 option type\n     and length, followed immediately by the data.  The data has the\n     alignment constraints.  Therefore padding must be inserted in the\n     form of padding options before the new option. */\n  int data_offset = offset + sizeof (struct ip6_opt);\n  int npad = (align - data_offset % align) & (align - 1);\n\n  if (extbuf != NULL)\n    {\n      /* Now we can check whether the buffer is large enough.  */\n      if (data_offset + npad + len > extlen)\n\treturn -1;\n\n      add_padding (extbuf, offset, npad);\n\n      offset += npad;\n\n      /* Now prepare the option itself.  */\n      struct ip6_opt *opt = (struct ip6_opt *) ((uint8_t *) extbuf + offset);\n\n      opt->ip6o_type = type;\n      opt->ip6o_len = len;\n\n      *databufp = opt + 1;\n    }\n  else\n    offset += npad;\n\n  return offset + sizeof (struct ip6_opt) + len;\n}",
    "inet6_opt_finish": "inet6_opt_finish (void *extbuf, socklen_t extlen, int offset){\n  /* Check minimum offset.  */\n  if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  /* Required padding at the end.  */\n  int npad = (8 - (offset & 7)) & 7;\n\n  if (extbuf != NULL)\n    {\n      /* Make sure the buffer is large enough.  */\n      if (offset + npad > extlen)\n\treturn -1;\n\n      add_padding (extbuf, offset, npad);\n    }\n\n  return offset + npad;\n}",
    "inet6_opt_set_val": "inet6_opt_set_val (void *databuf, int offset, void *val, socklen_t vallen){\n  memcpy ((uint8_t *) databuf + offset, val, vallen);\n\n  return offset + vallen;\n}",
    "inet6_opt_next": "inet6_opt_next (void *extbuf, socklen_t extlen, int offset, uint8_t *typep,\n\t\tsocklen_t *lenp, void **databufp){\n  if (offset == 0)\n    offset = sizeof (struct ip6_hbh);\n  else if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  while (offset < extlen)\n    {\n      struct ip6_opt *opt = (struct ip6_opt *) ((uint8_t *) extbuf + offset);\n\n      if (opt->ip6o_type == IP6OPT_PAD1)\n\t/* Single byte padding.  */\n\t++offset;\n      else if (opt->ip6o_type == IP6OPT_PADN)\n\toffset += sizeof (struct ip6_opt) + opt->ip6o_len;\n      else\n\t{\n\t  /* Check whether the option is valid.  */\n\t  offset += sizeof (struct ip6_opt) + opt->ip6o_len;\n\t  if (offset > extlen)\n\t    return -1;\n\n\t  *typep = opt->ip6o_type;\n\t  *lenp = opt->ip6o_len;\n\t  *databufp = opt + 1;\n\t  return offset;\n\t}\n    }\n\n  return -1;\n}",
    "inet6_opt_find": "inet6_opt_find (void *extbuf, socklen_t extlen, int offset, uint8_t type,\n\t\tsocklen_t *lenp, void **databufp){\n  if (offset == 0)\n    offset = sizeof (struct ip6_hbh);\n  else if (offset < sizeof (struct ip6_hbh))\n    return -1;\n\n  while (offset < extlen)\n    {\n      struct ip6_opt *opt = (struct ip6_opt *) ((uint8_t *) extbuf + offset);\n\n      if (opt->ip6o_type == IP6OPT_PAD1)\n\t{\n\t  /* Single byte padding.  */\n\t  ++offset;\n\t  if (type == IP6OPT_PAD1)\n\t    {\n\t      *lenp = 0;\n\t      *databufp = (uint8_t *) extbuf + offset;\n\t      return offset;\n\t    }\n\t}\n      else if (opt->ip6o_type != type)\n\toffset += sizeof (struct ip6_opt) + opt->ip6o_len;\n      else\n\t{\n\t  /* Check whether the option is valid.  */\n\t  offset += sizeof (struct ip6_opt) + opt->ip6o_len;\n\t  if (offset > extlen)\n\t    return -1;\n\n\t  *lenp = opt->ip6o_len;\n\t  *databufp = opt + 1;\n\t  return offset;\n\t}\n    }\n\n  return -1;\n}",
    "inet6_opt_get_val": "inet6_opt_get_val (void *databuf, int offset, void *val, socklen_t vallen){\n  memcpy (val, (uint8_t *) databuf + offset, vallen);\n\n  return offset + vallen;\n}",
    "inet6_option_space": "inet6_option_space (int nbytes){\n  /* Add room for the extension header.  */\n  nbytes += sizeof (struct ip6_ext);\n\n  return CMSG_SPACE (roundup (nbytes, 8));\n}",
    "inet6_option_init": "inet6_option_init (void *bp, struct cmsghdr **cmsgp, int type){\n  /* Only Hop-by-Hop or Destination options allowed.  */\n  if (type != IPV6_HOPOPTS && type != IPV6_DSTOPTS)\n    return -1;\n\n  /* BP is a pointer to the previously allocated space.  */\n  struct cmsghdr *newp = (struct cmsghdr *) bp;\n\n  /* Initialize the message header.\n\n     Length: No data yet, only the cmsghdr struct.  */\n  newp->cmsg_len = CMSG_LEN (0);\n  /* Originating protocol: obviously IPv6.  */\n  newp->cmsg_level = IPPROTO_IPV6;\n  /* Message type.  */\n  newp->cmsg_type = type;\n\n  /* Pass up the result.  */\n  *cmsgp = newp;\n\n  return 0;\n}",
    "inet6_option_append": "inet6_option_append (struct cmsghdr *cmsg, const uint8_t *typep, int multx,\n\t\t     int plusy){\n  /* typep is a pointer to the 8-bit option type.  It is assumed that this\n     field is immediately followed by the 8-bit option data length field,\n     which is then followed immediately by the option data.\n\n     The option types IP6OPT_PAD1 and IP6OPT_PADN also must be handled.  */\n  int len = typep[0] == IP6OPT_PAD1 ? 1 : typep[1] + 2;\n\n  /* Get the pointer to the space in the message.  */\n  uint8_t *ptr = option_alloc (cmsg, len, multx, plusy);\n  if (ptr == NULL)\n    /* Some problem with the parameters.  */\n    return -1;\n\n  /* Copy the content.  */\n  memcpy (ptr, typep, len);\n\n  return 0;\n}",
    "inet6_option_alloc": "*\ninet6_option_alloc (struct cmsghdr *cmsg, int datalen, int multx, int plusy){\n  return option_alloc (cmsg, datalen, multx, plusy);\n}",
    "inet6_option_next": "inet6_option_next (const struct cmsghdr *cmsg, uint8_t **tptrp){\n  /* Make sure it is an option of the right type.  */\n  if (cmsg->cmsg_level != IPPROTO_IPV6\n      || (cmsg->cmsg_type != IPV6_HOPOPTS && cmsg->cmsg_type != IPV6_DSTOPTS))\n    return -1;\n\n  /* Pointer to the extension header.  We only compute the address, we\n     don't access anything yet.  */\n  const struct ip6_ext *ip6e = (const struct ip6_ext *) CMSG_DATA (cmsg);\n\n  /* Make sure the message is long enough.  */\n  if (cmsg->cmsg_len < CMSG_LEN (sizeof (struct ip6_ext))\n      /* Now we can access the extension header.  */\n      || cmsg->cmsg_len < CMSG_LEN ((ip6e->ip6e_len + 1) * 8))\n    /* Too small.  */\n    return -1;\n\n  /* Determine the address of the byte past the message.  */\n  const uint8_t *endp = CMSG_DATA (cmsg) + (ip6e->ip6e_len + 1) * 8;\n\n  const uint8_t *result;\n  if (*tptrp == NULL)\n    /* This is the first call, return the first option if there is one.  */\n    result = (const uint8_t *) (ip6e + 1);\n  else\n    {\n      /* Make sure *TPTRP points to a beginning of a new option in\n\t the message.  The upper limit is checked in get_opt_end.  */\n      if (*tptrp < (const uint8_t *) (ip6e + 1))\n\treturn -1;\n\n      /* Get the beginning of the next option.  */\n      if (get_opt_end (&result, *tptrp, endp) != 0)\n\treturn -1;\n    }\n\n  /* We know where the next option starts.  */\n  *tptrp = (uint8_t *) result;\n\n  /* Check the option is fully represented in the message.  */\n  return get_opt_end (&result, result, endp);\n}",
    "inet6_option_find": "inet6_option_find (const struct cmsghdr *cmsg, uint8_t **tptrp, int type){\n  /* Make sure it is an option of the right type.  */\n  if (cmsg->cmsg_level != IPPROTO_IPV6\n      || (cmsg->cmsg_type != IPV6_HOPOPTS && cmsg->cmsg_type != IPV6_DSTOPTS))\n    return -1;\n\n  /* Pointer to the extension header.  We only compute the address, we\n     don't access anything yet.  */\n  const struct ip6_ext *ip6e = (const struct ip6_ext *) CMSG_DATA (cmsg);\n\n  /* Make sure the message is long enough.  */\n  if (cmsg->cmsg_len < CMSG_LEN (sizeof (struct ip6_ext))\n      /* Now we can access the extension header.  */\n      || cmsg->cmsg_len < CMSG_LEN ((ip6e->ip6e_len + 1) * 8))\n    /* Too small.  */\n    return -1;\n\n  /* Determine the address of the byte past the message.  */\n  const uint8_t *endp = CMSG_DATA (cmsg) + (ip6e->ip6e_len + 1) * 8;\n\n  const uint8_t *next;\n  if (*tptrp == NULL)\n    /* This is the first call, return the first option if there is one.  */\n    next = (const uint8_t *) (ip6e + 1);\n  else\n    {\n      /* Make sure *TPTRP points to a beginning of a new option in\n\t the message.  The upper limit is checked in get_opt_end.  */\n      if (*tptrp < (const uint8_t *) (ip6e + 1))\n\treturn -1;\n\n      /* Get the beginning of the next option.  */\n      if (get_opt_end (&next, *tptrp, endp) != 0)\n\treturn -1;\n    }\n\n  /* Now search for the appropriate typed entry.  */\n  const uint8_t *result;\n  do\n    {\n      result = next;\n\n      /* Get the end of this entry.  */\n      if (get_opt_end (&next, result, endp) != 0)\n\treturn -1;\n    }\n  while (*result != type);\n\n  /* We know where the next option starts.  */\n  *tptrp = (uint8_t *) result;\n\n  /* Success.  */\n  return 0;\n}",
    "inet6_rth_space": "inet6_rth_space (int type, int segments){\n  switch (type)\n    {\n    case IPV6_RTHDR_TYPE_0:\n      if (segments < 0 || segments > 127)\n\treturn 0;\n\n      return sizeof (struct ip6_rthdr0) + segments * sizeof (struct in6_addr);\n    }\n\n  return 0;\n}",
    "inet6_rth_init": "*\ninet6_rth_init (void *bp, socklen_t bp_len, int type, int segments){\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (type)\n    {\n    case IPV6_RTHDR_TYPE_0:\n      /* Make sure the parameters are valid and the buffer is large enough.  */\n      if (segments < 0 || segments > 127)\n\tbreak;\n\n      socklen_t len = (sizeof (struct ip6_rthdr0)\n\t\t       + segments * sizeof (struct in6_addr));\n      if (len > bp_len)\n\tbreak;\n\n      /* Some implementations seem to initialize the whole memory area.  */\n      memset (bp, '\\0', len);\n\n      /* Length in units of 8 octets.  */\n      rthdr->ip6r_len = segments * sizeof (struct in6_addr) / 8;\n      rthdr->ip6r_type = IPV6_RTHDR_TYPE_0;\n      return bp;\n    }\n\n  return NULL;\n}",
    "inet6_rth_add": "inet6_rth_add (void *bp, const struct in6_addr *addr){\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (rthdr->ip6r_type)\n    {\n      struct ip6_rthdr0 *rthdr0;\n    case IPV6_RTHDR_TYPE_0:\n      rthdr0 = (struct ip6_rthdr0 *) rthdr;\n      if (rthdr0->ip6r0_len * 8 / sizeof (struct in6_addr)\n\t  - rthdr0->ip6r0_segleft < 1)\n        return -1;\n\n      memcpy (&rthdr0->ip6r0_addr[rthdr0->ip6r0_segleft++],\n\t      addr, sizeof (struct in6_addr));\n\n      return 0;\n    }\n\n  return -1;\n}",
    "inet6_rth_reverse": "inet6_rth_reverse (const void *in, void *out){\n  struct ip6_rthdr *in_rthdr = (struct ip6_rthdr *) in;\n\n  switch (in_rthdr->ip6r_type)\n    {\n      struct ip6_rthdr0 *in_rthdr0;\n      struct ip6_rthdr0 *out_rthdr0;\n    case IPV6_RTHDR_TYPE_0:\n      in_rthdr0 = (struct ip6_rthdr0 *) in;\n      out_rthdr0 = (struct ip6_rthdr0 *) out;\n\n      /* Copy header, not the addresses.  The memory regions can overlap.  */\n      memmove (out_rthdr0, in_rthdr0, sizeof (struct ip6_rthdr0));\n\n      int total = in_rthdr0->ip6r0_len * 8 / sizeof (struct in6_addr);\n      for (int i = 0; i < total / 2; ++i)\n\t{\n\t  /* Remember, IN_RTHDR0 and OUT_RTHDR0 might overlap.  */\n\t  struct in6_addr temp = in_rthdr0->ip6r0_addr[i];\n\t  out_rthdr0->ip6r0_addr[i] = in_rthdr0->ip6r0_addr[total - 1 - i];\n\t  out_rthdr0->ip6r0_addr[total - 1 - i] = temp;\n\t}\n      if (total % 2 != 0 && in != out)\n\tout_rthdr0->ip6r0_addr[total / 2] = in_rthdr0->ip6r0_addr[total / 2];\n\n      out_rthdr0->ip6r0_segleft = total;\n\n      return 0;\n    }\n\n  return -1;\n}",
    "inet6_rth_segments": "inet6_rth_segments (const void *bp){\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (rthdr->ip6r_type)\n    {\n    case IPV6_RTHDR_TYPE_0:\n\n      return rthdr->ip6r_len * 8 / sizeof (struct in6_addr);\n    }\n\n  return -1;\n}",
    "inet6_rth_getaddr": "*\ninet6_rth_getaddr (const void *bp, int index){\n  struct ip6_rthdr *rthdr = (struct ip6_rthdr *) bp;\n\n  switch (rthdr->ip6r_type)\n    {\n       struct ip6_rthdr0 *rthdr0;\n    case IPV6_RTHDR_TYPE_0:\n      rthdr0 = (struct ip6_rthdr0 *) rthdr;\n\n      if (index >= rthdr0->ip6r0_len * 8 / sizeof (struct in6_addr))\n\tbreak;\n\n      return &rthdr0->ip6r0_addr[index];\n    }\n\n  return NULL;\n}",
    "__inet6_scopeid_pton": "__inet6_scopeid_pton (const struct in6_addr *address, const char *scope,\n                      uint32_t *result){\n  if (IN6_IS_ADDR_LINKLOCAL (address)\n      || IN6_IS_ADDR_MC_NODELOCAL (address)\n      || IN6_IS_ADDR_MC_LINKLOCAL (address))\n    {\n      uint32_t number = __if_nametoindex (scope);\n      if (number != 0)\n        {\n          *result = number;\n          return 0;\n        }\n    }\n\n  if (isdigit_l (scope[0], _nl_C_locobj_ptr))\n    {\n      char *end;\n      unsigned long long number\n        = ____strtoull_l_internal (scope, &end, /*base */ 10, /* group */ 0,\n                                   /* bin_cst */ false, _nl_C_locobj_ptr);\n      if (*end == '\\0' && number <= UINT32_MAX)\n        {\n          *result = number;\n          return 0;\n        }\n    }\n\n  __set_errno (EINVAL);\n  return -1;\n}",
    "inet_lnaof": "inet_lnaof (struct in_addr in){\n\tuint32_t i = ntohl(in.s_addr);\n\n\tif (IN_CLASSA(i))\n\t\treturn ((i)&IN_CLASSA_HOST);\n\telse if (IN_CLASSB(i))\n\t\treturn ((i)&IN_CLASSB_HOST);\n\telse\n\t\treturn ((i)&IN_CLASSC_HOST);\n}",
    "inet_netof": "inet_netof (struct in_addr in){\n\tuint32_t i = ntohl(in.s_addr);\n\n\tif (IN_CLASSA(i))\n\t\treturn (((i)&IN_CLASSA_NET) >> IN_CLASSA_NSHIFT);\n\telse if (IN_CLASSB(i))\n\t\treturn (((i)&IN_CLASSB_NET) >> IN_CLASSB_NSHIFT);\n\telse\n\t\treturn (((i)&IN_CLASSC_NET) >> IN_CLASSC_NSHIFT);\n}",
    "inet_ntoa": "*\ninet_ntoa (struct in_addr in){\n  unsigned char *bytes = (unsigned char *) &in;\n  __snprintf (buffer, sizeof (buffer), \"%d.%d.%d.%d\",\n\t      bytes[0], bytes[1], bytes[2], bytes[3]);\n\n  return buffer;\n}",
    "rcmd_af": "rcmd_af (char **ahost, u_short rport, const char *locuser, const char *remuser,\n\t const char *cmd, int *fd2p, sa_family_t af){\n\tchar paddr[INET6_ADDRSTRLEN];\n\tstruct addrinfo hints, *res, *ai;\n\tunion\n\t{\n\t\tstruct sockaddr sa;\n\t\tstruct sockaddr_storage ss;\n\t\tstruct sockaddr_in sin;\n\t\tstruct sockaddr_in6 sin6;\n\t} from;\n\tstruct pollfd pfd[2];\n\tsigset_t mask, omask;\n\n\tpid_t pid;\n\tint s, lport, timo, error;\n\tchar c;\n\tint refused;\n\tchar num[8];\n\tssize_t n;\n\n\tif (af != AF_INET && af != AF_INET6 && af != AF_UNSPEC)\n\t  {\n\t    __set_errno (EAFNOSUPPORT);\n\t    return -1;\n\t  }\n\n\tpid = __getpid();\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_flags = AI_CANONNAME;\n\thints.ai_family = af;\n\thints.ai_socktype = SOCK_STREAM;\n\t(void)__snprintf(num, sizeof(num), \"%d\", ntohs(rport));\n\terror = getaddrinfo(*ahost, num, &hints, &res);\n\tif (error) {\n\t\tif (error == EAI_NONAME && *ahost != NULL)\n\t\t\t__fxprintf(NULL, \"%s: Unknown host\\n\", *ahost);\n\t\telse\n\t\t\t__fxprintf(NULL, \"rcmd: getaddrinfo: %s\\n\",\n\t\t\t\t   gai_strerror(error));\n\n\t\treturn -1;\n\t}\n\n\tpfd[0].events = POLLIN;\n\tpfd[1].events = POLLIN;\n\n\tif (res->ai_canonname){\n\t\tfree (ahostbuf);\n\t\tahostbuf = __strdup (res->ai_canonname);\n\t\tif (ahostbuf == NULL) {\n\t\t\tfreeaddrinfo (res);\n\t\t\t__fxprintf(NULL, \"%s\",\n\t\t\t\t   _(\"rcmd: Cannot allocate memory\\n\"));\n\t\t\treturn -1;\n\t\t}\n\t\t*ahost = ahostbuf;\n\t} else\n\t\t*ahost = NULL;\n\tai = res;\n\trefused = 0;\n\t__sigemptyset(&mask);\n\t__sigaddset(&mask, SIGURG);\n\t__sigprocmask (SIG_BLOCK, &mask, &omask);\n\tfor (timo = 1, lport = IPPORT_RESERVED - 1;;) {\n\t\tchar errbuf[200];\n\n\t\ts = rresvport_af(&lport, ai->ai_family);\n\t\tif (s < 0) {\n\t\t\tif (errno == EAGAIN)\n\t\t\t\t__fxprintf(NULL, \"%s\", _(\"\\\nrcmd: socket: All ports in use\\n\"));\n\t\t\telse\n\t\t\t\t__fxprintf(NULL, \"rcmd: socket: %m\\n\");\n\n\t\t\t__sigprocmask (SIG_SETMASK, &omask, 0);\n\t\t\tfreeaddrinfo(res);\n\t\t\treturn -1;\n\t\t}\n\t\t__fcntl(s, F_SETOWN, pid);\n\t\tif (__connect(s, ai->ai_addr, ai->ai_addrlen) >= 0)\n\t\t\tbreak;\n\t\t(void)__close(s);\n\t\tif (errno == EADDRINUSE) {\n\t\t\tlport--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (errno == ECONNREFUSED)\n\t\t\trefused = 1;\n\t\tif (ai->ai_next != NULL) {\n\t\t\tint oerrno = errno;\n\t\t\tchar *buf = NULL;\n\n\t\t\tgetnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t\t    paddr, sizeof(paddr),\n\t\t\t\t    NULL, 0,\n\t\t\t\t    NI_NUMERICHOST);\n\n\t\t\tif (__asprintf (&buf, _(\"connect to address %s: \"),\n\t\t\t\t\tpaddr) >= 0)\n\t\t\t  {\n\t\t\t    __fxprintf(NULL, \"%s\", buf);\n\t\t\t    free (buf);\n\t\t\t  }\n\t\t\t__set_errno (oerrno);\n\t\t\tperror(0);\n\t\t\tai = ai->ai_next;\n\t\t\tgetnameinfo(ai->ai_addr, ai->ai_addrlen,\n\t\t\t\t    paddr, sizeof(paddr),\n\t\t\t\t    NULL, 0,\n\t\t\t\t    NI_NUMERICHOST);\n\t\t\tif (__asprintf (&buf, _(\"Trying %s...\\n\"), paddr) >= 0)\n\t\t\t  {\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\t\t\t    free (buf);\n\t\t\t  }\n\t\t\tcontinue;\n\t\t}\n\t\tif (refused && timo <= 16) {\n\t\t\t(void)__sleep(timo);\n\t\t\ttimo *= 2;\n\t\t\tai = res;\n\t\t\trefused = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tfreeaddrinfo(res);\n\t\t(void)__fxprintf(NULL, \"%s: %s\\n\", *ahost,\n\t\t\t\t __strerror_r(errno, errbuf, sizeof (errbuf)));\n\t\t__sigprocmask (SIG_SETMASK, &omask, 0);\n\t\treturn -1;\n\t}\n\tlport--;\n\tif (fd2p == 0) {\n\t\t__write(s, \"\", 1);\n\t\tlport = 0;\n\t} else {\n\t\tchar num[8];\n\t\tint s2 = rresvport_af(&lport, ai->ai_family), s3;\n\t\tsocklen_t len = ai->ai_addrlen;\n\n\t\tif (s2 < 0)\n\t\t\tgoto bad;\n\t\t__listen(s2, 1);\n\t\t(void)__snprintf(num, sizeof(num), \"%d\", lport);\n\t\tif (__write(s, num, strlen(num)+1) != (ssize_t)strlen(num)+1) {\n\t\t\tchar *buf = NULL;\n\n\t\t\tif (__asprintf (&buf, _(\"\\\nrcmd: write (setting up stderr): %m\\n\")) >= 0)\n\t\t\t  {\n\t\t\t    __fxprintf(NULL, \"%s\", buf);\n\t\t\t    free (buf);\n\t\t\t  }\n\t\t\t(void)__close(s2);\n\t\t\tgoto bad;\n\t\t}\n\t\tpfd[0].fd = s;\n\t\tpfd[1].fd = s2;\n\t\t__set_errno (0);\n\t\tif (__poll (pfd, 2, -1) < 1 || (pfd[1].revents & POLLIN) == 0){\n\t\t\tchar *buf = NULL;\n\n\t\t\tif ((errno != 0\n\t\t\t     && __asprintf(&buf, _(\"\\\nrcmd: poll (setting up stderr): %m\\n\")) >= 0)\n\t\t\t    || (errno == 0\n\t\t\t\t&& __asprintf(&buf, _(\"\\\npoll: protocol failure in circuit setup\\n\")) >= 0))\n\t\t\t  {\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\t\t\t    free  (buf);\n\t\t\t  }\n\t\t\t(void)__close(s2);\n\t\t\tgoto bad;\n\t\t}\n\t\ts3 = TEMP_FAILURE_RETRY (accept(s2, &from.sa, &len));\n\t\tswitch (from.sa.sa_family) {\n\t\tcase AF_INET:\n\t\t\trport = ntohs(from.sin.sin_port);\n\t\t\tbreak;\n\t\tcase AF_INET6:\n\t\t\trport = ntohs(from.sin6.sin6_port);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\trport = 0;\n\t\t\tbreak;\n\t\t}\n\t\t(void)__close(s2);\n\t\tif (s3 < 0) {\n\t\t\t(void)__fxprintf(NULL, \"rcmd: accept: %m\\n\");\n\t\t\tlport = 0;\n\t\t\tgoto bad;\n\t\t}\n\t\t*fd2p = s3;\n\n\t\tif (rport >= IPPORT_RESERVED || rport < IPPORT_RESERVED / 2){\n\t\t\tchar *buf = NULL;\n\n\t\t\tif (__asprintf(&buf, _(\"\\\nsocket: protocol failure in circuit setup\\n\")) >= 0)\n\t\t\t  {\n\t\t\t    __fxprintf (NULL, \"%s\", buf);\n\t\t\t    free (buf);\n\t\t\t  }\n\t\t\tgoto bad2;\n\t\t}\n\t}\n\tstruct iovec iov[3] =\n\t  {\n\t    [0] = { .iov_base = (void *) locuser,\n\t\t    .iov_len = strlen (locuser) + 1 },\n\t    [1] = { .iov_base = (void *) remuser,\n\t\t    .iov_len = strlen (remuser) + 1 },\n\t    [2] = { .iov_base = (void *) cmd,\n\t\t    .iov_len = strlen (cmd) + 1 }\n\t  };\n\t(void) TEMP_FAILURE_RETRY (__writev (s, iov, 3));\n\tn = TEMP_FAILURE_RETRY (__read(s, &c, 1));\n\tif (n != 1) {\n\t\tchar *buf = NULL;\n\n\t\tif ((n == 0\n\t\t     && __asprintf(&buf, _(\"rcmd: %s: short read\"),\n\t\t\t\t   *ahost) >= 0)\n\t\t    || (n != 0\n\t\t\t&& __asprintf(&buf, \"rcmd: %s: %m\\n\", *ahost) >= 0))\n\t\t  {\n\t\t    __fxprintf (NULL, \"%s\", buf);\n\t\t    free (buf);\n\t\t  }\n\t\tgoto bad2;\n\t}\n\tif (c != 0) {\n\t\twhile (__read(s, &c, 1) == 1) {\n\t\t\t(void)__write(STDERR_FILENO, &c, 1);\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto bad2;\n\t}\n\t__sigprocmask (SIG_SETMASK, &omask, 0);\n\tfreeaddrinfo(res);\n\treturn s;\nbad2:\n\tif (lport)\n\t\t(void)__close(*fd2p);\nbad:\n\t(void)__close(s);\n\t__sigprocmask (SIG_SETMASK, &omask, 0);\n\tfreeaddrinfo(res);\n\treturn -1;\n}",
    "rcmd": "rcmd (char **ahost, u_short rport, const char *locuser, const char *remuser,\n      const char *cmd, int *fd2p){\n  return rcmd_af (ahost, rport, locuser, remuser, cmd, fd2p, AF_INET);\n}",
    "rresvport_af": "rresvport_af (int *alport, sa_family_t family){\n\tunion {\n\t\tstruct sockaddr generic;\n\t\tstruct sockaddr_in in;\n\t\tstruct sockaddr_in6 in6;\n\t} ss;\n\tint s;\n\tsize_t len;\n\tuint16_t *sport;\n\n\tswitch(family){\n\tcase AF_INET:\n\t\tlen = sizeof(struct sockaddr_in);\n\t\tsport = &ss.in.sin_port;\n\t\tbreak;\n\tcase AF_INET6:\n\t\tlen = sizeof(struct sockaddr_in6);\n\t\tsport = &ss.in6.sin6_port;\n\t\tbreak;\n\tdefault:\n\t\t__set_errno (EAFNOSUPPORT);\n\t\treturn -1;\n\t}\n\t/* NB: No SOCK_CLOEXEC for backwards compatibility.  */\n\ts = __socket(family, SOCK_STREAM, 0);\n\tif (s < 0)\n\t\treturn -1;\n\n\tmemset (&ss, '\\0', sizeof(ss));\n#ifdef SALEN\n\tss.generic.__ss_len = len;\n#endif\n\tss.generic.sa_family = family;\n\n\t/* Ignore invalid values.  */\n\tif (*alport < IPPORT_RESERVED / 2)\n\t\t*alport = IPPORT_RESERVED / 2;\n\telse if (*alport >= IPPORT_RESERVED)\n\t\t*alport = IPPORT_RESERVED - 1;\n\n\tint start = *alport;\n\tdo {\n\t\t*sport = htons((uint16_t) *alport);\n\t\tif (__bind(s, &ss.generic, len) >= 0)\n\t\t\treturn s;\n\t\tif (errno != EADDRINUSE) {\n\t\t\t(void)__close(s);\n\t\t\treturn -1;\n\t\t}\n\t\tif ((*alport)-- == IPPORT_RESERVED/2)\n\t\t\t*alport = IPPORT_RESERVED - 1;\n\t} while (*alport != start);\n\t(void)__close(s);\n\t__set_errno (EAGAIN);\n\treturn -1;\n}",
    "rresvport": "rresvport (int *alport){\n\treturn rresvport_af(alport, AF_INET);\n}",
    "ruserok_af": "ruserok_af (const char *rhost, int superuser, const char *ruser,\n\t    const char *luser, sa_family_t af){\n\tstruct addrinfo hints, *res, *res0;\n\tint gai;\n\tint ret;\n\n\tmemset (&hints, '\\0', sizeof(hints));\n\thints.ai_family = af;\n\tgai = getaddrinfo(rhost, NULL, &hints, &res0);\n\tif (gai)\n\t\treturn -1;\n\tret = -1;\n\tfor (res=res0; res; res=res->ai_next)\n\t\tif (ruserok2_sa(res->ai_addr, res->ai_addrlen,\n\t\t\t\tsuperuser, ruser, luser, rhost) == 0){\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\tfreeaddrinfo(res0);\n\treturn (ret);\n}",
    "ruserok": "ruserok (const char *rhost, int superuser, const char *ruser,\n\t const char *luser){\n\treturn ruserok_af(rhost, superuser, ruser, luser, AF_INET);\n}",
    "iruserok_af": "iruserok_af (const void *raddr, int superuser, const char *ruser,\n\t     const char *luser, sa_family_t af){\n  union {\n    struct sockaddr generic;\n    struct sockaddr_in in;\n    struct sockaddr_in6 in6;\n  } ra;\n  size_t ralen;\n\n  memset (&ra, '\\0', sizeof(ra));\n  switch (af){\n  case AF_INET:\n    ra.in.sin_family = AF_INET;\n    memcpy (&ra.in.sin_addr, raddr, sizeof(struct in_addr));\n    ralen = sizeof(struct sockaddr_in);\n    break;\n  case AF_INET6:\n    ra.in6.sin6_family = AF_INET6;\n    memcpy (&ra.in6.sin6_addr, raddr, sizeof(struct in6_addr));\n    ralen = sizeof(struct sockaddr_in6);\n    break;\n  default:\n    return 0;\n  }\n  return ruserok_sa (&ra.generic, ralen, superuser, ruser, luser);\n}",
    "iruserok": "iruserok (uint32_t raddr, int superuser, const char *ruser, const char *luser){\n  return iruserok_af (&raddr, superuser, ruser, luser, AF_INET);\n}",
    "__ivaliduser": "attribute_compat_text_section\n__ivaliduser (FILE *hostf, uint32_t raddr, const char *luser,\n\t      const char *ruser){\n\tstruct sockaddr_in ra;\n\tmemset(&ra, '\\0', sizeof(ra));\n\tra.sin_family = AF_INET;\n\tra.sin_addr.s_addr = raddr;\n\treturn __validuser2_sa(hostf, (struct sockaddr *)&ra, sizeof(ra),\n\t\t\t       luser, ruser, \"-\");\n}",
    "rexec_af": "rexec_af (char **ahost, int rport, const char *name, const char *pass,\n\t  const char *cmd, int *fd2p, sa_family_t af){\n\tstruct sockaddr_storage from;\n\tstruct addrinfo hints, *res0;\n\tconst char *orig_name = name;\n\tconst char *orig_pass = pass;\n\tu_short port = 0;\n\tint s, timo = 1, s3;\n\tchar c;\n\tint gai;\n\tchar servbuff[NI_MAXSERV];\n\n\t__snprintf(servbuff, sizeof(servbuff), \"%d\", ntohs(rport));\n\tservbuff[sizeof(servbuff) - 1] = '\\0';\n\n\tmemset(&hints, '\\0', sizeof(hints));\n\thints.ai_family = af;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_CANONNAME;\n\tgai = getaddrinfo(*ahost, servbuff, &hints, &res0);\n\tif (gai){\n\t\t/* XXX: set errno? */\n\t\treturn -1;\n\t}\n\n\tif (res0->ai_canonname){\n\t\tfree (ahostbuf);\n\t\tahostbuf = __strdup (res0->ai_canonname);\n\t\tif (ahostbuf == NULL) {\n\t\t\tperror (\"rexec: strdup\");\n\t\t\tgoto bad2;\n\t\t}\n\t\t*ahost = ahostbuf;\n\t} else {\n\t\t*ahost = NULL;\n\t\t__set_errno (ENOENT);\n\t\tgoto bad2;\n\t}\n\truserpass(res0->ai_canonname, &name, &pass);\nretry:\n\t/* NB: No SOCK_CLOEXEC for backwards compatibility.  */\n\ts = __socket(res0->ai_family, res0->ai_socktype, 0);\n\tif (s < 0) {\n\t\tperror(\"rexec: socket\");\n\t\tgoto bad2;\n\t}\n\tif (__connect(s, res0->ai_addr, res0->ai_addrlen) < 0) {\n\t\tif (errno == ECONNREFUSED && timo <= 16) {\n\t\t\t(void) __close(s);\n\t\t\t__sleep(timo);\n\t\t\ttimo *= 2;\n\t\t\tgoto retry;\n\t\t}\n\t\tperror(res0->ai_canonname);\n\t\tgoto bad;\n\t}\n\tif (fd2p == 0) {\n\t\t(void) __write(s, \"\", 1);\n\t\tport = 0;\n\t} else {\n\t\tchar num[32];\n\t\tint s2;\n\t\tunion\n\t\t{\n\t\t  struct sockaddr_storage ss;\n\t\t  struct sockaddr sa;\n\t\t} sa2;\n\t\tsocklen_t sa2len;\n\n\t\ts2 = __socket(res0->ai_family, res0->ai_socktype, 0);\n\t\tif (s2 < 0)\n\t\t\tgoto bad;\n\n\t\t__listen(s2, 1);\n\t\tsa2len = sizeof (sa2);\n\t\tif (__getsockname(s2, &sa2.sa, &sa2len) < 0) {\n\t\t\tperror(\"getsockname\");\n\t\t\t(void) __close(s2);\n\t\t\tgoto bad;\n\t\t} else if (sa2len != SA_LEN(&sa2.sa)) {\n\t\t\t__set_errno(EINVAL);\n\t\t\t(void) __close(s2);\n\t\t\tgoto bad;\n\t\t}\n\t\tport = 0;\n\t\tif (!getnameinfo(&sa2.sa, sa2len,\n\t\t\t\t NULL, 0, servbuff, sizeof(servbuff),\n\t\t\t\t NI_NUMERICSERV))\n\t\t\tport = strtol(servbuff, NULL, 10);\n\t\t(void) sprintf(num, \"%u\", port);\n\t\t(void) __write(s, num, strlen(num)+1);\n\t\t{ socklen_t len = sizeof (from);\n\t\t  s3 = TEMP_FAILURE_RETRY (accept(s2, (struct sockaddr *)&from,\n\t\t\t\t\t\t  &len));\n\t\t  __close(s2);\n\t\t  if (s3 < 0) {\n\t\t\tperror(\"accept\");\n\t\t\tport = 0;\n\t\t\tgoto bad;\n\t\t  }\n\t\t}\n\t\t*fd2p = s3;\n\t}\n\n\tstruct iovec iov[3] =\n\t  {\n\t    [0] = { .iov_base = (void *) name, .iov_len = strlen (name) + 1 },\n\t    /* should public key encrypt the password here */\n\t    [1] = { .iov_base = (void *) pass, .iov_len = strlen (pass) + 1 },\n\t    [2] = { .iov_base = (void *) cmd, .iov_len = strlen (cmd) + 1 }\n\t  };\n\t(void) TEMP_FAILURE_RETRY (__writev (s, iov, 3));\n\n\t/* We don't need the memory allocated for the name and the password\n\t   in ruserpass anymore.  */\n\tif (name != orig_name)\n\t  free ((char *) name);\n\tif (pass != orig_pass)\n\t  free ((char *) pass);\n\n\tif (__read(s, &c, 1) != 1) {\n\t\tperror(*ahost);\n\t\tgoto bad;\n\t}\n\tif (c != 0) {\n\t\twhile (__read(s, &c, 1) == 1) {\n\t\t\t(void) __write(2, &c, 1);\n\t\t\tif (c == '\\n')\n\t\t\t\tbreak;\n\t\t}\n\t\tgoto bad;\n\t}\n\tfreeaddrinfo(res0);\n\treturn (s);\nbad:\n\tif (port)\n\t\t(void) __close(*fd2p);\n\t(void) __close(s);\nbad2:\n\tfreeaddrinfo(res0);\n\treturn (-1);\n}",
    "rexec": "rexec (char **ahost, int rport, const char *name, const char *pass,\n       const char *cmd, int *fd2p){\n\treturn rexec_af(ahost, rport, name, pass, cmd, fd2p, AF_INET);\n}",
    "ruserpass": "ruserpass (const char *host, const char **aname, const char **apass){\n\tchar *hdir, *buf, *tmp;\n\tchar myname[1024], *mydomain;\n\tint t, usedefault = 0;\n\tstruct __stat64_t64 stb;\n\n\thdir = __libc_secure_getenv(\"HOME\");\n\tif (hdir == NULL) {\n\t\t/* If we can't get HOME, fail instead of trying \".\",\n\t\t   which is no improvement. This really should call\n\t\t   getpwuid(getuid()).  */\n\t\t/*hdir = \".\";*/\n\t\treturn -1;\n\t}\n\n\tbuf = alloca (strlen (hdir) + 8);\n\n\t__stpcpy (__stpcpy (buf, hdir), \"/.netrc\");\n\tcfile = fopen(buf, \"rce\");\n\tif (cfile == NULL) {\n\t\tif (errno != ENOENT)\n\t\t\twarn(\"%s\", buf);\n\t\treturn (0);\n\t}\n\t/* No threads use this stream.  */\n\t__fsetlocking (cfile, FSETLOCKING_BYCALLER);\n\tif (__gethostname(myname, sizeof(myname)) < 0)\n\t\tmyname[0] = '\\0';\n\tmydomain = __strchrnul(myname, '.');\nnext:\n\twhile ((t = token())) switch(t) {\n\n\tcase DEFAULT:\n\t\tusedefault = 1;\n\t\t/* FALL THROUGH */\n\n\tcase MACHINE:\n\t\tif (!usedefault) {\n\t\t\tif (token() != ID)\n\t\t\t\tcontinue;\n\t\t\t/*\n\t\t\t * Allow match either for user's input host name\n\t\t\t * or official hostname.  Also allow match of\n\t\t\t * incompletely-specified host in local domain.\n\t\t\t */\n\t\t\tif (__strcasecmp(host, tokval) == 0)\n\t\t\t\tgoto match;\n/*\t\t\tif (__strcasecmp(hostname, tokval) == 0)\n\t\t\t\tgoto match;\n\t\t\tif ((tmp = strchr(hostname, '.')) != NULL &&\n\t\t\t    __strcasecmp(tmp, mydomain) == 0 &&\n\t\t\t    __strncasecmp(hostname, tokval, tmp-hostname) == 0 &&\n\t\t\t    tokval[tmp - hostname] == '\\0')\n\t\t\t\tgoto match; */\n\t\t\tif ((tmp = strchr(host, '.')) != NULL &&\n\t\t\t    __strcasecmp(tmp, mydomain) == 0 &&\n\t\t\t    __strncasecmp(host, tokval, tmp - host) == 0 &&\n\t\t\t    tokval[tmp - host] == '\\0')\n\t\t\t\tgoto match;\n\t\t\tcontinue;\n\t\t}\n\tmatch:\n\t\twhile ((t = token()) && t != MACHINE && t != DEFAULT) switch(t) {\n\n\t\tcase LOGIN:\n\t\t\tif (token()) {\n\t\t\t\tif (*aname == 0) {\n\t\t\t\t  char *newp;\n\t\t\t\t  newp = malloc((unsigned) strlen(tokval) + 1);\n\t\t\t\t  if (newp == NULL)\n\t\t\t\t    {\n\t\t\t\t      warnx(_(\"out of memory\"));\n\t\t\t\t      goto bad;\n\t\t\t\t    }\n\t\t\t\t  *aname = strcpy(newp, tokval);\n\t\t\t\t} else {\n\t\t\t\t\tif (strcmp(*aname, tokval))\n\t\t\t\t\t\tgoto next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase PASSWD:\n\t\t\tif (strcmp(*aname, \"anonymous\") &&\n\t\t\t    __fstat64_time64(fileno(cfile), &stb) >= 0 &&\n\t\t\t    (stb.st_mode & 077) != 0) {\n\twarnx(_(\"Error: .netrc file is readable by others.\"));\n\twarnx(_(\"Remove 'password' line or make file unreadable by others.\"));\n\t\t\t\tgoto bad;\n\t\t\t}\n\t\t\tif (token() && *apass == 0) {\n\t\t\t\tchar *newp;\n\t\t\t\tnewp = malloc((unsigned) strlen(tokval) + 1);\n\t\t\t\tif (newp == NULL)\n\t\t\t\t  {\n\t\t\t\t    warnx(_(\"out of memory\"));\n\t\t\t\t    goto bad;\n\t\t\t\t  }\n\t\t\t\t*apass = strcpy(newp, tokval);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase ACCOUNT:\n\t\t\tbreak;\n\t\tcase MACDEF:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\twarnx(_(\"Unknown .netrc keyword %s\"), tokval);\n\t\t\tbreak;\n\t\t}\n\t\tgoto done;\n\t}\ndone:\n\t(void) fclose(cfile);\n\treturn (0);\nbad:\n\t(void) fclose(cfile);\n\treturn (-1);\n}",
    "setipv4sourcefilter": "setipv4sourcefilter (int s, struct in_addr interface, struct in_addr group,\n\t\t     uint32_t fmode, uint32_t numsrc,\n\t\t     const struct in_addr *slist){\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  size_t needed = IP_MSFILTER_SIZE (numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct ip_msfilter *imsf = buf.data;\n\n  imsf->imsf_multiaddr = group;\n  imsf->imsf_interface = interface;\n  imsf->imsf_fmode = fmode;\n  imsf->imsf_numsrc = numsrc;\n  memcpy (imsf->imsf_slist, slist, numsrc * sizeof (struct in_addr));\n\n  int result = __setsockopt (s, SOL_IP, IP_MSFILTER, imsf, needed);\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "setsourcefilter": "setsourcefilter (int s, uint32_t interface, const struct sockaddr *group,\n\t\t socklen_t grouplen, uint32_t fmode, uint32_t numsrc,\n\t\t const struct sockaddr_storage *slist){\n  /* We have to create an struct ip_msfilter object which we can pass\n     to the kernel.  */\n  size_t needed = GROUP_FILTER_SIZE (numsrc);\n\n  struct scratch_buffer buf;\n  scratch_buffer_init (&buf);\n  if (!scratch_buffer_set_array_size (&buf, 1, needed))\n    return -1;\n  struct group_filter *gf = buf.data;\n\n  gf->gf_interface = interface;\n  memcpy (&gf->gf_group, group, grouplen);\n  gf->gf_fmode = fmode;\n  gf->gf_numsrc = numsrc;\n  memcpy (gf->gf_slist, slist, numsrc * sizeof (struct sockaddr_storage));\n\n  /* We need to provide the appropriate socket level value.  */\n  int result;\n  int sol = __get_sol (group->sa_family, grouplen);\n  if (sol == -1)\n    {\n      __set_errno (EINVAL);\n      result = -1;\n    }\n  else\n    result = __setsockopt (s, sol, MCAST_MSFILTER, gf, needed);\n\n  scratch_buffer_free (&buf);\n\n  return result;\n}",
    "stpcpy": "*\nstpcpy (char *dest, const char *src){\n  while ((*dest++ = *src++) != '\\0')\n    /* Do nothing. */ ;\n  return dest - 1;\n}",
    "mempcpy": "*\nmempcpy (void *dest, const void *src, size_t n){\n  return (void *) ((char *) memcpy (dest, src, n) + n);\n}",
    "__close": "__close (int fd){\n  return SYSCALL_CANCEL (close, fd);\n}",
    "copy_file_range": "copy_file_range (int infd, __off64_t *pinoff,\n                 int outfd, __off64_t *poutoff,\n                 size_t length, unsigned int flags){\n  return SYSCALL_CANCEL (copy_file_range, infd, pinoff, outfd, poutoff,\n                         length, flags);\n}",
    "creat": "creat (const char *file, mode_t mode){\n  return __open (file, O_WRONLY|O_CREAT|O_TRUNC, mode);\n}",
    "creat64": "creat64 (const char *file, mode_t mode){\n  return __open64 (file, O_WRONLY|O_CREAT|O_TRUNC, mode);\n}",
    "__dup2": "__dup2 (int fd, int fd2){\n#ifdef __NR_dup2\n  return INLINE_SYSCALL_CALL (dup2, fd, fd2);\n#else\n  /* For the degenerate case, check if the fd is valid (by trying to\n     get the file status flags) and return it, or else return EBADF.  */\n  if (fd == fd2)\n    return __libc_fcntl (fd, F_GETFL, 0) < 0 ? -1 : fd;\n\n  return INLINE_SYSCALL_CALL (dup3, fd, fd2, 0);\n#endif\n}",
    "faccessat": "faccessat (int fd, const char *file, int type, int flag){\n  if (file == NULL || (flag & ~(AT_SYMLINK_NOFOLLOW | AT_EACCESS)) != 0\n      || (type & ~(R_OK|W_OK|X_OK|F_OK)) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd < 0 && fd != AT_FDCWD)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "fchmodat": "fchmodat (int fd, const char *file, mode_t mode, int flag){\n#if __ASSUME_FCHMODAT2\n  return INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);\n#else\n  if (flag == 0)\n    return INLINE_SYSCALL_CALL (fchmodat, fd, file, mode);\n\n  int r = INLINE_SYSCALL_CALL (fchmodat2, fd, file, mode, flag);\n  if (r != 0 && errno == ENOSYS)\n    return fchmodat_fallback (fd, file, mode, flag);\n  return r;\n#endif\n}",
    "fchownat": "fchownat (int fd, const char *file, uid_t owner, gid_t group, int flag){\n  if (file == NULL || (flag & ~AT_SYMLINK_NOFOLLOW) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd < 0 && fd != AT_FDCWD)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__fcntl": "__fcntl (int fd, int cmd, ...){\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__file_is_unchanged": "__file_is_unchanged (const struct file_change_detection *left,\n                     const struct file_change_detection *right){\n  if (left->size < 0 || right->size < 0)\n    /* Negative sizes are used as markers and never match.  */\n    return false;\n  else if (left->size == 0 && right->size == 0)\n    /* Both files are empty or do not exist, so they have the same\n       content, no matter what the other fields indicate.  */\n    return true;\n  else\n    return left->size == right->size\n      && left->ino == right->ino\n      && left->mtime.tv_sec == right->mtime.tv_sec\n      && left->mtime.tv_nsec == right->mtime.tv_nsec\n      && left->ctime.tv_sec == right->ctime.tv_sec\n      && left->ctime.tv_nsec == right->ctime.tv_nsec;\n}",
    "__file_change_detection_for_stat": "__file_change_detection_for_stat (struct file_change_detection *file,\n                                  const struct __stat64_t64 *st){\n  if (S_ISDIR (st->st_mode))\n    /* Treat as empty file.  */\n    file->size = 0;\n  else if (!S_ISREG (st->st_mode))\n    /* Non-regular files cannot be cached.  */\n    file->size = -1;\n  else\n    {\n      file->size = st->st_size;\n      file->ino = st->st_ino;\n      file->mtime = (struct __timespec64) { st->st_mtim.tv_sec,\n\t\t\t\t\t    st->st_mtim.tv_nsec };\n      file->ctime = (struct __timespec64) { st->st_ctim.tv_sec,\n\t\t\t\t\t    st->st_ctim.tv_nsec };\n    }\n}",
    "__file_change_detection_for_path": "__file_change_detection_for_path (struct file_change_detection *file,\n                                  const char *path){\n  struct __stat64_t64 st;\n  if (__stat64_time64 (path, &st) != 0)\n    switch (errno)\n      {\n      case EACCES:\n      case EISDIR:\n      case ELOOP:\n      case ENOENT:\n      case ENOTDIR:\n      case EPERM:\n        /* Ignore errors due to file system contents.  Instead, treat\n           the file as empty.  */\n        file->size = 0;\n        return true;\n      default:\n        /* Other errors are fatal.  */\n        return false;\n      }\n  else /* stat64 was successful.  */\n    {\n      __file_change_detection_for_stat (file, &st);\n      return true;\n    }\n}",
    "__file_change_detection_for_fp": "__file_change_detection_for_fp (struct file_change_detection *file,\n                                FILE *fp){\n  if (fp == NULL)\n    {\n      /* The file does not exist.  */\n      file->size = 0;\n      return true;\n    }\n  else\n    {\n      struct __stat64_t64 st;\n      if (__fstat64_time64 (__fileno (fp), &st) != 0)\n        /* If we already have a file descriptor, all errors are fatal.  */\n        return false;\n      else\n        {\n          __file_change_detection_for_stat (file, &st);\n          return true;\n        }\n    }\n}",
    "__fstat64": "__fstat64 (int fd, struct stat64 *buf){\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  struct __stat64_t64 st_t64;\n  return __fstat64_time64 (fd, &st_t64)\n\t ?: __cp_stat64_t64_stat64 (&st_t64, buf);\n}",
    "futimens": "futimens (int fd, const struct timespec tsp[2]){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "get_current_dir_name": "*\nget_current_dir_name (void){\n  char *pwd;\n  struct __stat64_t64 dotstat, pwdstat;\n\n  pwd = getenv (\"PWD\");\n  if (pwd != NULL\n      && __stat64_time64 (\".\", &dotstat) == 0\n      && __stat64_time64 (pwd, &pwdstat) == 0\n      && pwdstat.st_dev == dotstat.st_dev\n      && pwdstat.st_ino == dotstat.st_ino)\n    /* The PWD value is correct.  Use it.  */\n    return __strdup (pwd);\n\n  return __getcwd ((char *) NULL, 0);\n}",
    "getwd": "*\ngetwd (char *buf){\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n  char tmpbuf[PATH_MAX];\n\n  if (buf == NULL)\n    {\n      __set_errno (EINVAL);\n      return NULL;\n    }\n\n  if (__getcwd (tmpbuf, PATH_MAX) == NULL)\n    {\n      /* We use 1024 here since it should really be enough and because\n\t this is a safe value.  */\n      __strerror_r (errno, buf, 1024);\n      return NULL;\n    }\n\n  /* This is completely unsafe.  Nobody can say how big the user\n     provided buffer is.  Perhaps the application and the libc\n     disagree about the value of PATH_MAX.  */\n  return strcpy (buf, tmpbuf);\n}",
    "lchmod": "lchmod (const char *file, mode_t mode){\n  error_t err;\n  file_t port = __file_name_lookup (file, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = __file_chmod (port, mode);\n  __mach_port_deallocate (__mach_task_self (), port);\n  if (err)\n    return __hurd_fail (err);\n  return 0;\n}",
    "linkat": "linkat (int fromfd, const char *from, int tofd, const char *to, int flags){\n  if (from == NULL || to == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if ((tofd != AT_FDCWD && tofd < 0 && *to != '/')\n      || (fromfd != AT_FDCWD && fromfd < 0 && *from != '/'))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "lockf": "lockf (int fd, int cmd, off_t len){\n  /* lockf is always relative to the current file position.  */\n  struct flock fl = {\n    .l_type = F_WRLCK,\n    .l_whence = SEEK_CUR,\n    .l_len = len\n  };\n\n  /* lockf() is a cancellation point but so is fcntl() if F_SETLKW is\n     used.  Therefore we don't have to care about cancellation here,\n     the fcntl() function will take care of it.  */\n  switch (cmd)\n    {\n    case F_TEST:\n      /* Test the lock: return 0 if FD is unlocked or locked by this process;\n\t return -1, set errno to EACCES, if another process holds the lock.  */\n      fl.l_type = F_RDLCK;\n      if (__fcntl (fd, F_GETLK, &fl) < 0)\n\treturn -1;\n      if (fl.l_type == F_UNLCK || fl.l_pid == __getpid ())\n\treturn 0;\n      __set_errno (EACCES);\n      return -1;\n    case F_ULOCK:\n      fl.l_type = F_UNLCK;\n      return __fcntl (fd, F_SETLK, &fl);\n    case F_LOCK:\n      return __fcntl (fd, F_SETLKW, &fl);\n    case F_TLOCK:\n      return __fcntl (fd, F_SETLK, &fl);\n    }\n  __set_errno (EINVAL);\n  return -1;\n}",
    "mkdirat": "mkdirat (int fd, const char *path, mode_t mode){\n  if (path == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd != AT_FDCWD && path[0] != '/')\n    {\n      /* Check FD is associated with a directory.  */\n      struct stat64 st;\n      if (__fstat64 (fd, &st) != 0)\n\treturn -1;\n\n      if (!S_ISDIR (st.st_mode))\n\t{\n\t  __set_errno (ENOTDIR);\n\t  return -1;\n\t}\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mkfifo": "mkfifo (const char *path, mode_t mode){\n  return __mknod (path, mode | S_IFIFO, 0);\n}",
    "mkfifoat": "mkfifoat (int fd, const char *file, mode_t mode){\n  return __mknodat (fd, file, mode | S_IFIFO, 0);\n}",
    "__open64_2": "__open64_2 (const char *file, int oflag){\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid open64 call: O_CREAT or O_TMPFILE without mode\");\n\n  return __open64 (file, oflag);\n}",
    "__open_2": "__open_2 (const char *file, int oflag){\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid open call: O_CREAT or O_TMPFILE without mode\");\n\n  return __open (file, oflag);\n}",
    "__openat64_2": "__openat64_2 (int fd, const char *file, int oflag){\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid openat64 call: O_CREAT or O_TMPFILE without mode\");\n\n  return __openat64 (fd, file, oflag);\n}",
    "__openat_2": "__openat_2 (int fd, const char *file, int oflag){\n  if (__OPEN_NEEDS_MODE (oflag))\n    __fortify_fail (\"invalid openat call: O_CREAT or O_TMPFILE without mode\");\n\n  return __openat (fd, file, oflag);\n}",
    "__pipe": "__pipe (int __pipedes[2]){\n  return INLINE_SYSCALL_CALL (pipe2, (int *) __pipedes, 0);\n}",
    "__poll": "__poll (struct pollfd *fds, nfds_t nfds, int timeout){\n#ifdef __NR_poll\n  return SYSCALL_CANCEL (poll, fds, nfds, timeout);\n#else\n  struct timespec timeout_ts;\n  struct timespec *timeout_ts_p = NULL;\n\n  if (timeout >= 0)\n    {\n      timeout_ts.tv_sec = timeout / 1000;\n      timeout_ts.tv_nsec = (timeout % 1000) * 1000000;\n      timeout_ts_p = &timeout_ts;\n    }\n\n  return SYSCALL_CANCEL (ppoll, fds, nfds, timeout_ts_p, NULL, 0);\n#endif\n}",
    "posix_fadvise": "posix_fadvise (int fd, off_t offset, off_t len, int advise){\n# if defined (__NR_fadvise64) && !defined (__ASSUME_FADVISE64_AS_64_64)\n  int ret = INTERNAL_SYSCALL_CALL (fadvise64, fd,\n\t\t\t\t   __ALIGNMENT_ARG SYSCALL_LL (offset),\n\t\t\t\t   len, advise);\n# else\n#  ifdef __ASSUME_FADVISE64_64_6ARG\n  int ret = INTERNAL_SYSCALL_CALL (fadvise64_64, fd, advise,\n\t\t\t\t   SYSCALL_LL (offset), SYSCALL_LL (len));\n#  else\n\n#   ifndef __NR_fadvise64_64\n#    define __NR_fadvise64_64 __NR_fadvise64\n#   endif\n\n  int ret = INTERNAL_SYSCALL_CALL (fadvise64_64, fd,\n\t\t\t\t   __ALIGNMENT_ARG SYSCALL_LL (offset),\n\t\t\t\t   SYSCALL_LL (len), advise);\n#  endif\n# endif\n  if (INTERNAL_SYSCALL_ERROR_P (ret))\n    return INTERNAL_SYSCALL_ERRNO (ret);\n  return 0;\n}",
    "posix_fadvise64": "posix_fadvise64 (int fd, __off64_t offset, __off64_t len, int advise){\n  return ENOSYS;\n}",
    "posix_fallocate": "posix_fallocate (int fd, __off_t offset, __off_t len){\n  int res = INTERNAL_SYSCALL_CALL (fallocate, fd, 0,\n\t\t\t\t   SYSCALL_LL (offset), SYSCALL_LL (len));\n  if (! INTERNAL_SYSCALL_ERROR_P (res))\n    return 0;\n  if (INTERNAL_SYSCALL_ERRNO (res) != EOPNOTSUPP)\n    return INTERNAL_SYSCALL_ERRNO (res);\n  return internal_fallocate (fd, offset, len);\n}",
    "posix_fallocate64": "posix_fallocate64 (int fd, __off64_t offset, __off64_t len){\n  return ENOSYS;\n}",
    "ppoll": "ppoll (struct pollfd *fds, nfds_t nfds, const struct timespec *timeout,\n         const sigset_t *sigmask){\n  struct __timespec64 ts64;\n  if (timeout)\n    ts64 = valid_timespec_to_timespec64 (*timeout);\n\n  return __ppoll64 (fds, nfds, timeout ? &ts64 : NULL, sigmask);\n}",
    "readlinkat": "readlinkat (int fd, const char *path, char *buf, size_t len){\n  if (path == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd != AT_FDCWD && fd < 0 && *path != '/')\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sendfile": "sendfile (int out_fd, int in_fd, off_t *offset, size_t count){\n# ifdef __NR_sendfile\n  return INLINE_SYSCALL_CALL (sendfile, out_fd, in_fd, offset, count);\n# else\n  __off64_t off64;\n  int rc;\n\n  if (offset != NULL)\n    {\n      if (*offset < 0 || (off_t) (*offset + count) < 0)\n        {\n          __set_errno (EINVAL);\n          return -1;\n        }\n      off64 = *offset;\n    }\n\n  rc = INLINE_SYSCALL_CALL (sendfile64, out_fd, in_fd, offset ? &off64 : NULL,\n\t\t\t    count);\n  if (offset)\n    *offset = off64;\n  return rc;\n# endif\n}",
    "sendfile64": "sendfile64 (int out_fd, int in_fd, off64_t *offset, size_t count){\n#ifndef __NR_sendfile64\n# define __NR_sendfile64 __NR_sendfile\n#endif\n  return INLINE_SYSCALL_CALL (sendfile64, out_fd, in_fd, offset, count);\n}",
    "__statfs": "__statfs (const char *file, struct statfs *buf){\n  return INLINE_SYSCALL_CALL (statfs, file, buf);\n}",
    "statx": "statx (int fd, const char *path, int flags,\n       unsigned int mask, struct statx *buf){\n  int ret = INLINE_SYSCALL_CALL (statx, fd, path, flags, mask, buf);\n#ifdef __ASSUME_STATX\n  return ret;\n#else\n  if (ret == 0 || errno != ENOSYS)\n    /* Preserve non-error/non-ENOSYS return values.  */\n    return ret;\n  else\n    return statx_generic (fd, path, flags, mask, buf);\n#endif\n}",
    "symlinkat": "symlinkat (const char *from, int fd, const char *to){\n  if (from == NULL || to == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd != AT_FDCWD && fd < 0 && *to != '/')\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "ttyname": "*\nttyname (int fd){\n  /* isatty check, tcgetattr is used because it sets the correct\n     errno (EBADF resp. ENOTTY) on error.  Fast error path to avoid the\n     allocation  */\n  struct termios term;\n  if (__glibc_unlikely (__tcgetattr (fd, &term) < 0))\n    return NULL;\n\n  if (ttyname_buf == NULL)\n    {\n      ttyname_buf = malloc (PATH_MAX);\n      if (ttyname_buf == NULL)\n\treturn NULL;\n    }\n\n  int result = __ttyname_r (fd, ttyname_buf, PATH_MAX);\n  if (result != 0)\n    {\n      __set_errno (result);\n      return NULL;\n    }\n  return ttyname_buf;\n}",
    "unlinkat": "unlinkat (int fd, const char *name, int flag){\n  if (name == NULL || (flag & AT_REMOVEDIR) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (fd < 0 && fd != AT_FDCWD)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "utime": "utime (const char *file, const struct utimbuf *times){\n  struct timeval timevals[2];\n  struct timeval *tvp;\n\n  if (times != NULL)\n    {\n      timevals[0].tv_sec = (time_t) times->actime;\n      timevals[0].tv_usec = 0L;\n      timevals[1].tv_sec = (time_t) times->modtime;\n      timevals[1].tv_usec = 0L;\n      tvp = timevals;\n    }\n  else\n    tvp = NULL;\n\n  return __utimes (file, tvp);\n}",
    "utimensat": "utimensat (int fd, const char *file, const struct timespec tsp[2],\n\t   int flags){\n  error_t err;\n  file_t port;\n\n  port = __file_name_lookup_at (fd, flags, file, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n\n  err = hurd_futimens (port, tsp);\n\n  __mach_port_deallocate (__mach_task_self (), port);\n  if (err)\n    return __hurd_fail (err);\n  return 0;\n}",
    "__fbufsize": "__fbufsize (FILE *fp){\n  if (fp->_mode > 0)\n    return fp->_wide_data->_IO_buf_end - fp->_wide_data->_IO_buf_base;\n  else\n    return fp->_IO_buf_end - fp->_IO_buf_base;\n}",
    "__flbf": "__flbf (FILE *fp){\n  return fp->_flags & _IO_LINE_BUF;\n}",
    "__fpending": "__fpending (FILE *fp){\n  if (fp->_mode > 0)\n    return fp->_wide_data->_IO_write_ptr - fp->_wide_data->_IO_write_base;\n  else\n    return fp->_IO_write_ptr - fp->_IO_write_base;\n}",
    "__fpurge": "__fpurge (FILE *fp){\n  if (fp->_mode > 0)\n    {\n      /* Wide-char stream.  */\n      if (_IO_in_backup (fp))\n\t_IO_free_wbackup_area (fp);\n\n      fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n      fp->_wide_data->_IO_write_ptr = fp->_wide_data->_IO_write_base;\n    }\n  else\n    {\n      /* Byte stream.  */\n      if (_IO_in_backup (fp))\n\t_IO_free_backup_area (fp);\n\n      fp->_IO_read_end = fp->_IO_read_ptr;\n      fp->_IO_write_ptr = fp->_IO_write_base;\n    }\n}",
    "__freadable": "__freadable (FILE *fp){\n  return (fp->_flags & _IO_NO_READS) == 0;\n}",
    "__freading": "__freading (FILE *fp){\n  return ((fp->_flags & _IO_NO_WRITES)\n\t  || ((fp->_flags & (_IO_CURRENTLY_PUTTING | _IO_NO_READS)) == 0\n\t      && fp->_IO_read_base != NULL));\n}",
    "__fsetlocking": "__fsetlocking (FILE *fp, int type){\n  int result = ((fp->_flags & _IO_USER_LOCK)\n\t\t? FSETLOCKING_BYCALLER : FSETLOCKING_INTERNAL);\n\n  if (type != FSETLOCKING_QUERY)\n    {\n      fp->_flags &= ~_IO_USER_LOCK;\n      if (type == FSETLOCKING_BYCALLER)\n\t fp->_flags |= _IO_USER_LOCK;\n    }\n\n  return result;\n}",
    "__fwritable": "__fwritable (FILE *fp){\n  return (fp->_flags & _IO_NO_WRITES) == 0;\n}",
    "__fwriting": "__fwriting (FILE *fp){\n  return fp->_flags & (_IO_NO_READS | _IO_CURRENTLY_PUTTING);\n}",
    "clearerr": "clearerr (FILE *fp){\n  CHECK_FILE (fp, /*nothing*/);\n  _IO_flockfile (fp);\n  _IO_clearerr (fp);\n  _IO_funlockfile (fp);\n}",
    "clearerr_unlocked": "clearerr_unlocked (FILE *fp){\n  CHECK_FILE (fp, /*nothing*/);\n  _IO_clearerr (fp);\n}",
    "_IO_feof": "_IO_feof (FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_feof_unlocked (fp);\n  _IO_flockfile (fp);\n  result = _IO_feof_unlocked (fp);\n  _IO_funlockfile (fp);\n  return result;\n}",
    "_IO_ferror": "_IO_ferror (FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_ferror_unlocked (fp);\n  _IO_flockfile (fp);\n  result = _IO_ferror_unlocked (fp);\n  _IO_funlockfile (fp);\n  return result;\n}",
    "_IO_file_doallocate": "_IO_file_doallocate (FILE *fp){\n  size_t size;\n  char *p;\n  struct __stat64_t64 st;\n\n  size = BUFSIZ;\n  if (fp->_fileno >= 0 && __builtin_expect (_IO_SYSSTAT (fp, &st), 0) >= 0)\n    {\n      if (S_ISCHR (st.st_mode))\n\t{\n\t  /* Possibly a tty.  */\n\t  if (\n#ifdef DEV_TTY_P\n\t      DEV_TTY_P (&st) ||\n#endif\n\t      local_isatty (fp->_fileno))\n\t    fp->_flags |= _IO_LINE_BUF;\n\t}\n#if defined _STATBUF_ST_BLKSIZE\n      if (st.st_blksize > 0 && st.st_blksize < BUFSIZ)\n\tsize = st.st_blksize;\n#endif\n    }\n  p = malloc (size);\n  if (__glibc_unlikely (p == NULL))\n    return EOF;\n  _IO_setb (fp, p, p + size, 1);\n  return 1;\n}",
    "_IO_file_open": "*\n_IO_file_open (FILE *fp, const char *filename, int posix_mode, int prot,\n\t       int read_write, int is32not64){\n  int fdesc;\n  if (__glibc_unlikely (fp->_flags2 & _IO_FLAGS2_NOTCANCEL))\n    fdesc = __open_nocancel (filename,\n\t\t\t     posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);\n  else\n    fdesc = __open (filename, posix_mode | (is32not64 ? 0 : O_LARGEFILE), prot);\n  if (fdesc < 0)\n    return NULL;\n  fp->_fileno = fdesc;\n  _IO_mask_flags (fp, read_write,_IO_NO_READS+_IO_NO_WRITES+_IO_IS_APPENDING);\n  /* For append mode, send the file offset to the end of the file.  Don't\n     update the offset cache though, since the file handle is not active.  */\n  if ((read_write & (_IO_IS_APPENDING | _IO_NO_READS))\n      == (_IO_IS_APPENDING | _IO_NO_READS))\n    {\n      off64_t new_pos = _IO_SYSSEEK (fp, 0, _IO_seek_end);\n      if (new_pos == _IO_pos_BAD && errno != ESPIPE)\n\t{\n\t  __close_nocancel (fdesc);\n\t  return NULL;\n\t}\n    }\n  _IO_link_in ((struct _IO_FILE_plus *) fp);\n  return fp;\n}",
    "_IO_file_read": "_IO_file_read (FILE *fp, void *buf, ssize_t size){\n  return (__builtin_expect (fp->_flags2 & _IO_FLAGS2_NOTCANCEL, 0)\n\t  ? __read_nocancel (fp->_fileno, buf, size)\n\t  : __read (fp->_fileno, buf, size));\n}",
    "_IO_file_seek": "_IO_file_seek (FILE *fp, off64_t offset, int dir){\n  return __lseek64 (fp->_fileno, offset, dir);\n}",
    "_IO_file_stat": "_IO_file_stat (FILE *fp, void *st){\n  return __fstat64_time64 (fp->_fileno, (struct __stat64_t64 *) st);\n}",
    "_IO_file_close": "_IO_file_close (FILE *fp){\n  /* Cancelling close should be avoided if possible since it leaves an\n     unrecoverable state behind.  */\n  return __close_nocancel (fp->_fileno);\n}",
    "fputc": "fputc (int c, FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_putc_unlocked (c, fp);\n  _IO_acquire_lock (fp);\n  result = _IO_putc_unlocked (c, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputc_unlocked": "fputc_unlocked (int c, FILE *fp){\n  CHECK_FILE (fp, EOF);\n  return _IO_putc_unlocked (c, fp);\n}",
    "fputwc": "fputwc (wchar_t wc, FILE *fp){\n  wint_t result;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  if (_IO_fwide (fp, 1) < 0)\n    result = WEOF;\n  else\n    result = _IO_putwc_unlocked (wc, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputwc_unlocked": "fputwc_unlocked (wchar_t wc, FILE *fp){\n  CHECK_FILE (fp, WEOF);\n  if (_IO_fwide (fp, 1) < 0)\n    return WEOF;\n  return _IO_putwc_unlocked (wc, fp);\n}",
    "freopen": "*\nfreopen (const char *filename, const char *mode, FILE *fp){\n  FILE *result = NULL;\n  struct fd_to_filename fdfilename;\n\n  CHECK_FILE (fp, NULL);\n\n  _IO_acquire_lock (fp);\n  /* First flush the stream (failure should be ignored).  */\n  _IO_SYNC (fp);\n\n  if (!(fp->_flags & _IO_IS_FILEBUF))\n    goto end;\n\n  int fd = _IO_fileno (fp);\n  const char *gfilename\n    = filename != NULL ? filename : __fd_to_filename (fd, &fdfilename);\n\n  fp->_flags2 |= _IO_FLAGS2_NOCLOSE;\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_1)\n  if (&_IO_stdin_used == NULL)\n    {\n      /* If the shared C library is used by the application binary which\n\t was linked against the older version of libio, we just use the\n\t older one even for internal use to avoid trouble since a pointer\n\t to the old libio may be passed into shared C library and wind\n\t up here. */\n      _IO_old_file_close_it (fp);\n      _IO_JUMPS_FUNC_UPDATE (fp, &_IO_old_file_jumps);\n      result = _IO_old_file_fopen (fp, gfilename, mode);\n    }\n  else\n#endif\n    {\n      _IO_file_close_it (fp);\n      _IO_JUMPS_FILE_plus (fp) = &_IO_file_jumps;\n      if (_IO_vtable_offset (fp) == 0 && fp->_wide_data != NULL)\n\tfp->_wide_data->_wide_vtable = &_IO_wfile_jumps;\n      result = _IO_file_fopen (fp, gfilename, mode, 1);\n      if (result != NULL)\n\tresult = __fopen_maybe_mmap (result);\n    }\n  fp->_flags2 &= ~_IO_FLAGS2_NOCLOSE;\n  if (result != NULL)\n    {\n      /* unbound stream orientation */\n      result->_mode = 0;\n\n      if (fd != -1 && _IO_fileno (result) != fd)\n\t{\n\t  /* At this point we have both file descriptors already allocated,\n\t     so __dup3 will not fail with EBADF, EINVAL, or EMFILE.  But\n\t     we still need to check for EINVAL and, due Linux internal\n\t     implementation, EBUSY.  It is because on how it internally opens\n\t     the file by splitting the buffer allocation operation and VFS\n\t     opening (a dup operation may run when a file is still pending\n\t     'install' on VFS).  */\n\t  if (__dup3 (_IO_fileno (result), fd,\n\t\t      (result->_flags2 & _IO_FLAGS2_CLOEXEC) != 0\n\t\t      ? O_CLOEXEC : 0) == -1)\n\t    {\n\t      _IO_file_close_it (result);\n\t      result = NULL;\n\t      goto end;\n\t    }\n\t  __close (_IO_fileno (result));\n\t  _IO_fileno (result) = fd;\n\t}\n    }\n  else if (fd != -1)\n    __close (fd);\n\nend:\n  _IO_release_lock (fp);\n  return result;\n}",
    "freopen64": "*\nfreopen64 (const char *filename, const char *mode, FILE *fp){\n  FILE *result = NULL;\n  struct fd_to_filename fdfilename;\n\n  CHECK_FILE (fp, NULL);\n\n  _IO_acquire_lock (fp);\n  /* First flush the stream (failure should be ignored).  */\n  _IO_SYNC (fp);\n\n  if (!(fp->_flags & _IO_IS_FILEBUF))\n    goto end;\n\n  int fd = _IO_fileno (fp);\n  const char *gfilename\n    = filename != NULL ? filename : __fd_to_filename (fd, &fdfilename);\n\n  fp->_flags2 |= _IO_FLAGS2_NOCLOSE;\n  _IO_file_close_it (fp);\n  _IO_JUMPS_FILE_plus (fp) = &_IO_file_jumps;\n  if (_IO_vtable_offset (fp) == 0 && fp->_wide_data != NULL)\n    fp->_wide_data->_wide_vtable = &_IO_wfile_jumps;\n  result = _IO_file_fopen (fp, gfilename, mode, 0);\n  fp->_flags2 &= ~_IO_FLAGS2_NOCLOSE;\n  if (result != NULL)\n    result = __fopen_maybe_mmap (result);\n  if (result != NULL)\n    {\n      /* unbound stream orientation */\n      result->_mode = 0;\n\n      if (fd != -1 && _IO_fileno (result) != fd)\n\t{\n\t  /* At this point we have both file descriptors already allocated,\n\t     so __dup3 will not fail with EBADF, EINVAL, or EMFILE.  But\n\t     we still need to check for EINVAL and, due Linux internal\n\t     implementation, EBUSY.  It is because on how it internally opens\n\t     the file by splitting the buffer allocation operation and VFS\n\t     opening (a dup operation may run when a file is still pending\n\t     'install' on VFS).  */\n\t  if (__dup3 (_IO_fileno (result), fd,\n\t\t      (result->_flags2 & _IO_FLAGS2_CLOEXEC) != 0\n\t\t      ? O_CLOEXEC : 0) == -1)\n\t    {\n\t      _IO_file_close_it (result);\n\t      result = NULL;\n\t      goto end;\n\t    }\n\t  __close (_IO_fileno (result));\n\t  _IO_fileno (result) = fd;\n\t}\n    }\n  else if (fd != -1)\n    __close (fd);\n\nend:\n  _IO_release_lock (fp);\n  return result;\n}",
    "fseek": "fseek (FILE *fp, long int offset, int whence){\n  int result;\n  CHECK_FILE (fp, -1);\n  _IO_acquire_lock (fp);\n  result = _IO_fseek (fp, offset, whence);\n  _IO_release_lock (fp);\n  return result;\n}",
    "__fseeko64": "__fseeko64 (FILE *fp, off64_t offset, int whence){\n  int result;\n  CHECK_FILE (fp, -1);\n  _IO_acquire_lock (fp);\n  result = _IO_fseek (fp, offset, whence);\n  _IO_release_lock (fp);\n  return result;\n}",
    "__ftello64": "__ftello64 (FILE *fp){\n  off64_t pos;\n  CHECK_FILE (fp, -1L);\n  _IO_acquire_lock (fp);\n  pos = _IO_seekoff_unlocked (fp, 0, _IO_seek_cur, 0);\n  if (_IO_in_backup (fp) && pos != _IO_pos_BAD)\n    {\n      if (fp->_mode <= 0)\n\tpos -= fp->_IO_save_end - fp->_IO_save_base;\n    }\n  _IO_release_lock (fp);\n  if (pos == _IO_pos_BAD)\n    {\n      if (errno == 0)\n\t__set_errno (EIO);\n      return -1L;\n    }\n  return pos;\n}",
    "fwide": "fwide (FILE *fp, int mode){\n  int result;\n\n  /* Normalize the value.  */\n  mode = mode < 0 ? -1 : (mode == 0 ? 0 : 1);\n\n  if (mode == 0 || fp->_mode != 0)\n    /* The caller simply wants to know about the current orientation\n       or the orientation already has been determined.  */\n    return fp->_mode;\n\n  _IO_acquire_lock (fp);\n  result = _IO_fwide (fp, mode);\n  _IO_release_lock (fp);\n\n  return result;\n}",
    "_IO_un_link": "_IO_un_link (struct _IO_FILE_plus *fp){\n  if (fp->file._flags & _IO_LINKED)\n    {\n      FILE **f;\n#ifdef _IO_MTSAFE_IO\n      _IO_cleanup_region_start_noarg (flush_cleanup);\n      _IO_lock_lock (list_all_lock);\n      run_fp = (FILE *) fp;\n      _IO_flockfile ((FILE *) fp);\n#endif\n      if (_IO_list_all == NULL)\n\t;\n      else if (fp == _IO_list_all)\n\t_IO_list_all = (struct _IO_FILE_plus *) _IO_list_all->file._chain;\n      else\n\tfor (f = &_IO_list_all->file._chain; *f; f = &(*f)->_chain)\n\t  if (*f == (FILE *) fp)\n\t    {\n\t      *f = fp->file._chain;\n\t      break;\n\t    }\n      fp->file._flags &= ~_IO_LINKED;\n#ifdef _IO_MTSAFE_IO\n      _IO_funlockfile ((FILE *) fp);\n      run_fp = NULL;\n      _IO_lock_unlock (list_all_lock);\n      _IO_cleanup_region_end (0);\n#endif\n    }\n}",
    "_IO_link_in": "_IO_link_in (struct _IO_FILE_plus *fp){\n  if ((fp->file._flags & _IO_LINKED) == 0)\n    {\n      fp->file._flags |= _IO_LINKED;\n#ifdef _IO_MTSAFE_IO\n      _IO_cleanup_region_start_noarg (flush_cleanup);\n      _IO_lock_lock (list_all_lock);\n      run_fp = (FILE *) fp;\n      _IO_flockfile ((FILE *) fp);\n#endif\n      fp->file._chain = (FILE *) _IO_list_all;\n      _IO_list_all = fp;\n#ifdef _IO_MTSAFE_IO\n      _IO_funlockfile ((FILE *) fp);\n      run_fp = NULL;\n      _IO_lock_unlock (list_all_lock);\n      _IO_cleanup_region_end (0);\n#endif\n    }\n}",
    "_IO_switch_to_get_mode": "_IO_switch_to_get_mode (FILE *fp){\n  if (fp->_IO_write_ptr > fp->_IO_write_base)\n    if (_IO_OVERFLOW (fp, EOF) == EOF)\n      return EOF;\n  if (_IO_in_backup (fp))\n    fp->_IO_read_base = fp->_IO_backup_base;\n  else\n    {\n      fp->_IO_read_base = fp->_IO_buf_base;\n      if (fp->_IO_write_ptr > fp->_IO_read_end)\n\tfp->_IO_read_end = fp->_IO_write_ptr;\n    }\n  fp->_IO_read_ptr = fp->_IO_write_ptr;\n\n  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end = fp->_IO_read_ptr;\n\n  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n  return 0;\n}",
    "_IO_free_backup_area": "_IO_free_backup_area (FILE *fp){\n  if (_IO_in_backup (fp))\n    _IO_switch_to_main_get_area (fp);  /* Just in case. */\n  free (fp->_IO_save_base);\n  fp->_IO_save_base = NULL;\n  fp->_IO_save_end = NULL;\n  fp->_IO_backup_base = NULL;\n}",
    "__overflow": "__overflow (FILE *f, int ch){\n  /* This is a single-byte stream.  */\n  if (f->_mode == 0)\n    _IO_fwide (f, -1);\n  return _IO_OVERFLOW (f, ch);\n}",
    "__underflow": "__underflow (FILE *fp){\n  if (_IO_vtable_offset (fp) == 0 && _IO_fwide (fp, -1) != -1)\n    return EOF;\n\n  if (fp->_mode == 0)\n    _IO_fwide (fp, -1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_get_mode (fp) == EOF)\n      return EOF;\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *(unsigned char *) fp->_IO_read_ptr;\n  if (_IO_in_backup (fp))\n    {\n      _IO_switch_to_main_get_area (fp);\n      if (fp->_IO_read_ptr < fp->_IO_read_end)\n\treturn *(unsigned char *) fp->_IO_read_ptr;\n    }\n  if (_IO_have_markers (fp))\n    {\n      if (save_for_backup (fp, fp->_IO_read_end))\n\treturn EOF;\n    }\n  else if (_IO_have_backup (fp))\n    _IO_free_backup_area (fp);\n  return _IO_UNDERFLOW (fp);\n}",
    "__uflow": "__uflow (FILE *fp){\n  if (_IO_vtable_offset (fp) == 0 && _IO_fwide (fp, -1) != -1)\n    return EOF;\n\n  if (fp->_mode == 0)\n    _IO_fwide (fp, -1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_get_mode (fp) == EOF)\n      return EOF;\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *(unsigned char *) fp->_IO_read_ptr++;\n  if (_IO_in_backup (fp))\n    {\n      _IO_switch_to_main_get_area (fp);\n      if (fp->_IO_read_ptr < fp->_IO_read_end)\n\treturn *(unsigned char *) fp->_IO_read_ptr++;\n    }\n  if (_IO_have_markers (fp))\n    {\n      if (save_for_backup (fp, fp->_IO_read_end))\n\treturn EOF;\n    }\n  else if (_IO_have_backup (fp))\n    _IO_free_backup_area (fp);\n  return _IO_UFLOW (fp);\n}",
    "_IO_setb": "_IO_setb (FILE *f, char *b, char *eb, int a){\n  if (f->_IO_buf_base && !(f->_flags & _IO_USER_BUF))\n    free (f->_IO_buf_base);\n  f->_IO_buf_base = b;\n  f->_IO_buf_end = eb;\n  if (a)\n    f->_flags &= ~_IO_USER_BUF;\n  else\n    f->_flags |= _IO_USER_BUF;\n}",
    "_IO_doallocbuf": "_IO_doallocbuf (FILE *fp){\n  if (fp->_IO_buf_base)\n    return;\n  if (!(fp->_flags & _IO_UNBUFFERED) || fp->_mode > 0)\n    if (_IO_DOALLOCATE (fp) != EOF)\n      return;\n  _IO_setb (fp, fp->_shortbuf, fp->_shortbuf+1, 0);\n}",
    "_IO_default_uflow": "_IO_default_uflow (FILE *fp){\n  int ch = _IO_UNDERFLOW (fp);\n  if (ch == EOF)\n    return EOF;\n  return *(unsigned char *) fp->_IO_read_ptr++;\n}",
    "_IO_default_xsputn": "_IO_default_xsputn (FILE *f, const void *data, size_t n){\n  const char *s = (char *) data;\n  size_t more = n;\n  if (more <= 0)\n    return 0;\n  for (;;)\n    {\n      /* Space available. */\n      if (f->_IO_write_ptr < f->_IO_write_end)\n\t{\n\t  size_t count = f->_IO_write_end - f->_IO_write_ptr;\n\t  if (count > more)\n\t    count = more;\n\t  if (count > 20)\n\t    {\n\t      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count);\n\t      s += count;\n\t    }\n\t  else if (count)\n\t    {\n\t      char *p = f->_IO_write_ptr;\n\t      ssize_t i;\n\t      for (i = count; --i >= 0; )\n\t\t*p++ = *s++;\n\t      f->_IO_write_ptr = p;\n\t    }\n\t  more -= count;\n\t}\n      if (more == 0 || _IO_OVERFLOW (f, (unsigned char) *s++) == EOF)\n\tbreak;\n      more--;\n    }\n  return n - more;\n}",
    "_IO_sgetn": "_IO_sgetn (FILE *fp, void *data, size_t n){\n  /* FIXME handle putback buffer here! */\n  return _IO_XSGETN (fp, data, n);\n}",
    "_IO_default_xsgetn": "_IO_default_xsgetn (FILE *fp, void *data, size_t n){\n  size_t more = n;\n  char *s = (char*) data;\n  for (;;)\n    {\n      /* Data available. */\n      if (fp->_IO_read_ptr < fp->_IO_read_end)\n\t{\n\t  size_t count = fp->_IO_read_end - fp->_IO_read_ptr;\n\t  if (count > more)\n\t    count = more;\n\t  if (count > 20)\n\t    {\n\t      s = __mempcpy (s, fp->_IO_read_ptr, count);\n\t      fp->_IO_read_ptr += count;\n\t    }\n\t  else if (count)\n\t    {\n\t      char *p = fp->_IO_read_ptr;\n\t      int i = (int) count;\n\t      while (--i >= 0)\n\t\t*s++ = *p++;\n\t      fp->_IO_read_ptr = p;\n\t    }\n\t    more -= count;\n\t}\n      if (more == 0 || __underflow (fp) == EOF)\n\tbreak;\n    }\n  return n - more;\n}",
    "_IO_default_doallocate": "_IO_default_doallocate (FILE *fp){\n  char *buf;\n\n  buf = malloc(BUFSIZ);\n  if (__glibc_unlikely (buf == NULL))\n    return EOF;\n\n  _IO_setb (fp, buf, buf+BUFSIZ, 1);\n  return 1;\n}",
    "_IO_init": "_IO_init (FILE *fp, int flags){\n  IO_set_accept_foreign_vtables (&_IO_vtable_check);\n  _IO_init_internal (fp, flags);\n}",
    "_IO_enable_locks": "_IO_enable_locks (void){\n  _IO_ITER i;\n\n  if (stdio_needs_locking)\n    return;\n  stdio_needs_locking = 1;\n  for (i = _IO_iter_begin (); i != _IO_iter_end (); i = _IO_iter_next (i))\n    _IO_iter_file (i)->_flags2 |= _IO_FLAGS2_NEED_LOCK;\n}",
    "_IO_default_finish": "_IO_default_finish (FILE *fp, int dummy){\n  struct _IO_marker *mark;\n  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n    {\n      free (fp->_IO_buf_base);\n      fp->_IO_buf_base = fp->_IO_buf_end = NULL;\n    }\n\n  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n    mark->_sbuf = NULL;\n\n  if (fp->_IO_save_base)\n    {\n      free (fp->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n\n  _IO_un_link ((struct _IO_FILE_plus *) fp);\n\n#ifdef _IO_MTSAFE_IO\n  if (fp->_lock != NULL)\n    _IO_lock_fini (*fp->_lock);\n#endif\n}",
    "_IO_sputbackc": "_IO_sputbackc (FILE *fp, int c){\n  int result;\n\n  if (fp->_IO_read_ptr > fp->_IO_read_base\n      && (unsigned char)fp->_IO_read_ptr[-1] == (unsigned char)c)\n    {\n      fp->_IO_read_ptr--;\n      result = (unsigned char) c;\n    }\n  else\n    result = _IO_PBACKFAIL (fp, c);\n\n  if (result != EOF)\n    fp->_flags &= ~_IO_EOF_SEEN;\n\n  return result;\n}",
    "_IO_sungetc": "_IO_sungetc (FILE *fp){\n  int result;\n\n  if (fp->_IO_read_ptr > fp->_IO_read_base)\n    {\n      fp->_IO_read_ptr--;\n      result = (unsigned char) *fp->_IO_read_ptr;\n    }\n  else\n    result = _IO_PBACKFAIL (fp, EOF);\n\n  if (result != EOF)\n    fp->_flags &= ~_IO_EOF_SEEN;\n\n  return result;\n}",
    "_IO_adjust_column": "_IO_adjust_column (unsigned start, const char *line, int count){\n  const char *ptr = line + count;\n  while (ptr > line)\n    if (*--ptr == '\\n')\n      return line + count - ptr - 1;\n  return start + count;\n}",
    "_IO_flush_all": "_IO_flush_all (void){\n  int result = 0;\n  FILE *fp;\n\n#ifdef _IO_MTSAFE_IO\n  _IO_cleanup_region_start_noarg (flush_cleanup);\n  _IO_lock_lock (list_all_lock);\n#endif\n\n  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp->_chain)\n    {\n      run_fp = fp;\n      _IO_flockfile (fp);\n\n      if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base)\n\t   || (_IO_vtable_offset (fp) == 0\n\t       && fp->_mode > 0 && (fp->_wide_data->_IO_write_ptr\n\t\t\t\t    > fp->_wide_data->_IO_write_base))\n\t   )\n\t  && _IO_OVERFLOW (fp, EOF) == EOF)\n\tresult = EOF;\n\n      _IO_funlockfile (fp);\n      run_fp = NULL;\n    }\n\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_unlock (list_all_lock);\n  _IO_cleanup_region_end (0);\n#endif\n\n  return result;\n}",
    "_IO_flush_all_linebuffered": "_IO_flush_all_linebuffered (void){\n  FILE *fp;\n\n#ifdef _IO_MTSAFE_IO\n  _IO_cleanup_region_start_noarg (flush_cleanup);\n  _IO_lock_lock (list_all_lock);\n#endif\n\n  for (fp = (FILE *) _IO_list_all; fp != NULL; fp = fp->_chain)\n    {\n      run_fp = fp;\n      _IO_flockfile (fp);\n\n      if ((fp->_flags & _IO_NO_WRITES) == 0 && fp->_flags & _IO_LINE_BUF)\n\t_IO_OVERFLOW (fp, EOF);\n\n      _IO_funlockfile (fp);\n      run_fp = NULL;\n    }\n\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_unlock (list_all_lock);\n  _IO_cleanup_region_end (0);\n#endif\n}",
    "_IO_init_marker": "_IO_init_marker (struct _IO_marker *marker, FILE *fp){\n  marker->_sbuf = fp;\n  if (_IO_in_put_mode (fp))\n    _IO_switch_to_get_mode (fp);\n  if (_IO_in_backup (fp))\n    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_end;\n  else\n    marker->_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n\n  /* Should perhaps sort the chain? */\n  marker->_next = fp->_markers;\n  fp->_markers = marker;\n}",
    "_IO_remove_marker": "_IO_remove_marker (struct _IO_marker *marker){\n  /* Unlink from sb's chain. */\n  struct _IO_marker **ptr = &marker->_sbuf->_markers;\n  for (; ; ptr = &(*ptr)->_next)\n    {\n      if (*ptr == NULL)\n\tbreak;\n      else if (*ptr == marker)\n\t{\n\t  *ptr = marker->_next;\n\t  return;\n\t}\n    }\n  /* FIXME: if _sbuf has a backup area that is no longer needed,\n     should we delete it now, or wait until the next underflow? */\n}",
    "_IO_marker_difference": "_IO_marker_difference (struct _IO_marker *mark1, struct _IO_marker *mark2){\n  return mark1->_pos - mark2->_pos;\n}",
    "_IO_marker_delta": "_IO_marker_delta (struct _IO_marker *mark){\n  int cur_pos;\n  if (mark->_sbuf == NULL)\n    return BAD_DELTA;\n  if (_IO_in_backup (mark->_sbuf))\n    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_end;\n  else\n    cur_pos = mark->_sbuf->_IO_read_ptr - mark->_sbuf->_IO_read_base;\n  return mark->_pos - cur_pos;\n}",
    "_IO_seekmark": "_IO_seekmark (FILE *fp, struct _IO_marker *mark, int delta){\n  if (mark->_sbuf != fp)\n    return EOF;\n if (mark->_pos >= 0)\n    {\n      if (_IO_in_backup (fp))\n\t_IO_switch_to_main_get_area (fp);\n      fp->_IO_read_ptr = fp->_IO_read_base + mark->_pos;\n    }\n  else\n    {\n      if (!_IO_in_backup (fp))\n\t_IO_switch_to_backup_area (fp);\n      fp->_IO_read_ptr = fp->_IO_read_end + mark->_pos;\n    }\n  return 0;\n}",
    "_IO_unsave_markers": "_IO_unsave_markers (FILE *fp){\n  struct _IO_marker *mark = fp->_markers;\n  if (mark)\n    {\n      fp->_markers = 0;\n    }\n\n  if (_IO_have_backup (fp))\n    _IO_free_backup_area (fp);\n}",
    "_IO_default_pbackfail": "_IO_default_pbackfail (FILE *fp, int c){\n  if (fp->_IO_read_ptr > fp->_IO_read_base && !_IO_in_backup (fp)\n      && (unsigned char) fp->_IO_read_ptr[-1] == c)\n    --fp->_IO_read_ptr;\n  else\n    {\n      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n      if (!_IO_in_backup (fp))\n\t{\n\t  /* We need to keep the invariant that the main get area\n\t     logically follows the backup area.  */\n\t  if (fp->_IO_read_ptr > fp->_IO_read_base && _IO_have_backup (fp))\n\t    {\n\t      if (save_for_backup (fp, fp->_IO_read_ptr))\n\t\treturn EOF;\n\t    }\n\t  else if (!_IO_have_backup (fp))\n\t    {\n\t      /* No backup buffer: allocate one. */\n\t      /* Use nshort buffer, if unused? (probably not)  FIXME */\n\t      int backup_size = 128;\n\t      char *bbuf = (char *) malloc (backup_size);\n\t      if (bbuf == NULL)\n\t\treturn EOF;\n\t      fp->_IO_save_base = bbuf;\n\t      fp->_IO_save_end = fp->_IO_save_base + backup_size;\n\t      fp->_IO_backup_base = fp->_IO_save_end;\n\t    }\n\t  fp->_IO_read_base = fp->_IO_read_ptr;\n\t  _IO_switch_to_backup_area (fp);\n\t}\n      else if (fp->_IO_read_ptr <= fp->_IO_read_base)\n\t{\n\t  /* Increase size of existing backup buffer. */\n\t  size_t new_size;\n\t  size_t old_size = fp->_IO_read_end - fp->_IO_read_base;\n\t  char *new_buf;\n\t  new_size = 2 * old_size;\n\t  new_buf = (char *) malloc (new_size);\n\t  if (new_buf == NULL)\n\t    return EOF;\n\t  memcpy (new_buf + (new_size - old_size), fp->_IO_read_base,\n\t\t  old_size);\n\t  free (fp->_IO_read_base);\n\t  _IO_setg (fp, new_buf, new_buf + (new_size - old_size),\n\t\t    new_buf + new_size);\n\t  fp->_IO_backup_base = fp->_IO_read_ptr;\n\t}\n\n      *--fp->_IO_read_ptr = c;\n    }\n  return (unsigned char) c;\n}",
    "_IO_iter_begin": "_IO_iter_begin (void){\n  return (_IO_ITER) _IO_list_all;\n}",
    "_IO_iter_end": "_IO_iter_end (void){\n  return NULL;\n}",
    "_IO_iter_next": "_IO_iter_next (_IO_ITER iter){\n  return iter->_chain;\n}",
    "_IO_iter_file": "*\n_IO_iter_file (_IO_ITER iter){\n  return iter;\n}",
    "_IO_list_lock": "_IO_list_lock (void){\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_lock (list_all_lock);\n#endif\n}",
    "_IO_list_unlock": "_IO_list_unlock (void){\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_unlock (list_all_lock);\n#endif\n}",
    "_IO_list_resetlock": "_IO_list_resetlock (void){\n#ifdef _IO_MTSAFE_IO\n  _IO_lock_init (list_all_lock);\n#endif\n}",
    "_IO_getc": "_IO_getc (FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_getc_unlocked (fp);\n  _IO_acquire_lock (fp);\n  result = _IO_getc_unlocked (fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "getchar": "getchar (void){\n  int result;\n  if (!_IO_need_lock (stdin))\n    return _IO_getc_unlocked (stdin);\n  _IO_acquire_lock (stdin);\n  result = _IO_getc_unlocked (stdin);\n  _IO_release_lock (stdin);\n  return result;\n}",
    "getchar_unlocked": "getchar_unlocked (void){\n  return _IO_getc_unlocked (stdin);\n}",
    "getwchar": "getwchar (void){\n  wint_t result;\n  _IO_acquire_lock (stdin);\n  result = _IO_getwc_unlocked (stdin);\n  _IO_release_lock (stdin);\n  return result;\n}",
    "getwchar_unlocked": "getwchar_unlocked (void){\n  return _IO_getwc_unlocked (stdin);\n}",
    "_IO_fflush": "_IO_fflush (FILE *fp){\n  if (fp == NULL)\n    return _IO_flush_all ();\n  else\n    {\n      int result;\n      CHECK_FILE (fp, EOF);\n      _IO_acquire_lock (fp);\n      result = _IO_SYNC (fp) ? EOF : 0;\n      _IO_release_lock (fp);\n      return result;\n    }\n}",
    "_IO_fgets": "*\n_IO_fgets (char *buf, int n, FILE *fp){\n  size_t count;\n  char *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  if (__glibc_unlikely (n == 1))\n    {\n      /* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */\n      buf[0] = '\\0';\n      return buf;\n    }\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getline (fp, buf, n - 1, '\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fgetws": "*\nfgetws (wchar_t *buf, int n, FILE *fp){\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  if (__glibc_unlikely (n == 1))\n    {\n      /* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */\n      buf[0] = L'\\0';\n      return buf;\n    }\n  _IO_acquire_lock (fp);\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, n - 1, L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || (_IO_ferror_unlocked (fp) && errno != EAGAIN))\n    result = NULL;\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fgetws_unlocked": "*\nfgetws_unlocked (wchar_t *buf, int n, FILE *fp){\n  size_t count;\n  wchar_t *result;\n  int old_error;\n  CHECK_FILE (fp, NULL);\n  if (n <= 0)\n    return NULL;\n  if (__glibc_unlikely (n == 1))\n    {\n      /* Another irregular case: since we have to store a NUL byte and\n\t there is only room for exactly one byte, we don't have to\n\t read anything.  */\n      buf[0] = L'\\0';\n      return buf;\n    }\n  /* This is very tricky since a file descriptor may be in the\n     non-blocking mode. The error flag doesn't mean much in this\n     case. We return an error only when there is a new error. */\n  old_error = fp->_flags & _IO_ERR_SEEN;\n  fp->_flags &= ~_IO_ERR_SEEN;\n  count = _IO_getwline (fp, buf, n - 1, L'\\n', 1);\n  /* If we read in some bytes and errno is EAGAIN, that error will\n     be reported for next read. */\n  if (count == 0 || ((fp->_flags & _IO_ERR_SEEN) && errno != EAGAIN))\n    result = NULL;\n  else\n    {\n      buf[count] = '\\0';\n      result = buf;\n    }\n  fp->_flags |= old_error;\n  return result;\n}",
    "_IO_fputs": "_IO_fputs (const char *str, FILE *fp){\n  size_t len = strlen (str);\n  int result = EOF;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  if ((_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)\n      && _IO_sputn (fp, str, len) == len)\n    result = 1;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputws": "fputws (const wchar_t *str, FILE *fp){\n  size_t len = __wcslen (str);\n  int result = EOF;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  if (_IO_fwide (fp, 1) == 1\n      && _IO_sputn (fp, (char *) str, len) == len)\n    result = 1;\n  _IO_release_lock (fp);\n  return result;\n}",
    "fputws_unlocked": "fputws_unlocked (const wchar_t *str, FILE *fp){\n  size_t len = __wcslen (str);\n  int result = EOF;\n  CHECK_FILE (fp, EOF);\n  if (_IO_fwide (fp, 1) == 1\n      && _IO_sputn (fp, (char *) str, len) == len)\n    result = 1;\n  return result;\n}",
    "_IO_fread": "_IO_fread (void *buf, size_t size, size_t count, FILE *fp){\n  size_t bytes_requested = size * count;\n  size_t bytes_read;\n  CHECK_FILE (fp, 0);\n  if (bytes_requested == 0)\n    return 0;\n  _IO_acquire_lock (fp);\n  bytes_read = _IO_sgetn (fp, (char *) buf, bytes_requested);\n  _IO_release_lock (fp);\n  return bytes_requested == bytes_read ? count : bytes_read / size;\n}",
    "_IO_ftell": "_IO_ftell (FILE *fp){\n  off64_t pos;\n  CHECK_FILE (fp, -1L);\n  _IO_acquire_lock (fp);\n  pos = _IO_seekoff_unlocked (fp, 0, _IO_seek_cur, 0);\n  if (_IO_in_backup (fp) && pos != _IO_pos_BAD)\n    {\n      if (_IO_vtable_offset (fp) != 0 || fp->_mode <= 0)\n\tpos -= fp->_IO_save_end - fp->_IO_save_base;\n    }\n  _IO_release_lock (fp);\n  if (pos == _IO_pos_BAD)\n    {\n      if (errno == 0)\n\t__set_errno (EIO);\n      return -1L;\n    }\n  if ((off64_t) (long int) pos != pos)\n    {\n      __set_errno (EOVERFLOW);\n      return -1L;\n    }\n  return pos;\n}",
    "_IO_fwrite": "_IO_fwrite (const void *buf, size_t size, size_t count, FILE *fp){\n  size_t request = size * count;\n  size_t written = 0;\n  CHECK_FILE (fp, 0);\n  if (request == 0)\n    return 0;\n  _IO_acquire_lock (fp);\n  if (_IO_vtable_offset (fp) != 0 || _IO_fwide (fp, -1) == -1)\n    written = _IO_sputn (fp, (const char *) buf, request);\n  _IO_release_lock (fp);\n  /* We have written all of the input in case the return value indicates\n     this or EOF is returned.  The latter is a special case where we\n     simply did not manage to flush the buffer.  But the data is in the\n     buffer and therefore written as far as fwrite is concerned.  */\n  if (written == request || written == EOF)\n    return count;\n  else\n    return written / size;\n}",
    "fwrite_unlocked": "fwrite_unlocked (const void *buf, size_t size, size_t count, FILE *fp){\n  size_t request = size * count;\n  size_t written = 0;\n  CHECK_FILE (fp, 0);\n  if (request == 0)\n    return 0;\n  if (_IO_fwide (fp, -1) == -1)\n    {\n      written = _IO_sputn (fp, (const char *) buf, request);\n      /* We have written all of the input in case the return value indicates\n\t this or EOF is returned.  The latter is a special case where we\n\t simply did not manage to flush the buffer.  But the data is in the\n\t buffer and therefore written as far as fwrite is concerned.  */\n      if (written == request || written == EOF)\n\treturn count;\n    }\n\n  return written / size;\n}",
    "__getdelim": "__getdelim (char **lineptr, size_t *n, int delimiter, FILE *fp){\n  ssize_t result;\n  ssize_t cur_len = 0;\n  ssize_t len;\n\n  CHECK_FILE (fp, -1);\n  _IO_acquire_lock (fp);\n  if (_IO_ferror_unlocked (fp))\n    {\n      result = -1;\n      goto unlock_return;\n    }\n\n  if (lineptr == NULL || n == NULL)\n    {\n      __set_errno (EINVAL);\n      fseterr_unlocked (fp);\n      result = -1;\n      goto unlock_return;\n    }\n\n  if (*lineptr == NULL || *n == 0)\n    {\n      *n = 120;\n      *lineptr = (char *) malloc (*n);\n      if (*lineptr == NULL)\n\t{\n\t  fseterr_unlocked (fp);\n\t  result = -1;\n\t  goto unlock_return;\n\t}\n    }\n\n  len = fp->_IO_read_end - fp->_IO_read_ptr;\n  if (len <= 0)\n    {\n      if (__underflow (fp) == EOF)\n\t{\n\t  result = -1;\n\t  goto unlock_return;\n\t}\n      len = fp->_IO_read_end - fp->_IO_read_ptr;\n    }\n\n  for (;;)\n    {\n      size_t needed;\n      char *t;\n      t = (char *) memchr ((void *) fp->_IO_read_ptr, delimiter, len);\n      if (t != NULL)\n\tlen = (t - fp->_IO_read_ptr) + 1;\n      if (__glibc_unlikely (len >= SSIZE_MAX - cur_len))\n\t{\n\t  __set_errno (EOVERFLOW);\n\t  fseterr_unlocked (fp);\n\t  result = -1;\n\t  goto unlock_return;\n\t}\n      /* Make enough space for len+1 (for final NUL) bytes.  */\n      needed = cur_len + len + 1;\n      if (needed > *n)\n\t{\n\t  char *new_lineptr;\n\n\t  if (needed < 2 * *n)\n\t    needed = 2 * *n;  /* Be generous. */\n\t  new_lineptr = (char *) realloc (*lineptr, needed);\n\t  if (new_lineptr == NULL)\n\t    {\n\t      fseterr_unlocked (fp);\n\t      result = -1;\n\t      goto unlock_return;\n\t    }\n\t  *lineptr = new_lineptr;\n\t  *n = needed;\n\t}\n      memcpy (*lineptr + cur_len, (void *) fp->_IO_read_ptr, len);\n      fp->_IO_read_ptr += len;\n      cur_len += len;\n      if (t != NULL || __underflow (fp) == EOF)\n\tbreak;\n      len = fp->_IO_read_end - fp->_IO_read_ptr;\n    }\n  (*lineptr)[cur_len] = '\\0';\n  result = cur_len;\n\nunlock_return:\n  _IO_release_lock (fp);\n  return result;\n}",
    "_IO_getline": "_IO_getline (FILE *fp, char *buf, size_t n, int delim,\n\t     int extract_delim){\n  return _IO_getline_info (fp, buf, n, delim, extract_delim, (int *) 0);\n}",
    "_IO_getline_info": "_IO_getline_info (FILE *fp, char *buf, size_t n, int delim,\n\t\t  int extract_delim, int *eof){\n  char *ptr = buf;\n  if (eof != NULL)\n    *eof = 0;\n  if (__builtin_expect (fp->_mode, -1) == 0)\n    _IO_fwide (fp, -1);\n  while (n != 0)\n    {\n      ssize_t len = fp->_IO_read_end - fp->_IO_read_ptr;\n      if (len <= 0)\n\t{\n\t  int c = __uflow (fp);\n\t  if (c == EOF)\n\t    {\n\t      if (eof)\n\t\t*eof = c;\n\t      break;\n\t    }\n\t  if (c == delim)\n\t    {\n \t      if (extract_delim > 0)\n\t\t*ptr++ = c;\n\t      else if (extract_delim < 0)\n\t\t_IO_sputbackc (fp, c);\n\t      if (extract_delim > 0)\n\t\t++len;\n\t      return ptr - buf;\n\t    }\n\t  *ptr++ = c;\n\t  n--;\n\t}\n      else\n\t{\n\t  char *t;\n\t  if ((size_t) len >= n)\n\t    len = n;\n\t  t = (char *) memchr ((void *) fp->_IO_read_ptr, delim, len);\n\t  if (t != NULL)\n\t    {\n\t      size_t old_len = ptr-buf;\n\t      len = t - fp->_IO_read_ptr;\n\t      if (extract_delim >= 0)\n\t\t{\n\t\t  ++t;\n\t\t  if (extract_delim > 0)\n\t\t    ++len;\n\t\t}\n\t      memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);\n\t      fp->_IO_read_ptr = t;\n\t      return old_len + len;\n\t    }\n\t  memcpy ((void *) ptr, (void *) fp->_IO_read_ptr, len);\n\t  fp->_IO_read_ptr += len;\n\t  ptr += len;\n\t  n -= len;\n\t}\n    }\n  return ptr - buf;\n}",
    "_IO_gets": "*\n_IO_gets (char *buf){\n  size_t count;\n  int ch;\n  char *retval;\n\n  _IO_acquire_lock (stdin);\n  ch = _IO_getc_unlocked (stdin);\n  if (ch == EOF)\n    {\n      retval = NULL;\n      goto unlock_return;\n    }\n  if (ch == '\\n')\n    count = 0;\n  else\n    {\n      /* This is very tricky since a file descriptor may be in the\n\t non-blocking mode. The error flag doesn't mean much in this\n\t case. We return an error only when there is a new error. */\n      int old_error = stdin->_flags & _IO_ERR_SEEN;\n      stdin->_flags &= ~_IO_ERR_SEEN;\n      buf[0] = (char) ch;\n      count = _IO_getline (stdin, buf + 1, INT_MAX, '\\n', 0) + 1;\n      if (stdin->_flags & _IO_ERR_SEEN)\n\t{\n\t  retval = NULL;\n\t  goto unlock_return;\n\t}\n      else\n\tstdin->_flags |= old_error;\n    }\n  buf[count] = 0;\n  retval = buf;\nunlock_return:\n  _IO_release_lock (stdin);\n  return retval;\n}",
    "_IO_padn": "_IO_padn (FILE *fp, int pad, ssize_t count){\n  char padbuf[PADSIZE];\n  const char *padptr;\n  int i;\n  size_t written = 0;\n  size_t w;\n\n  if (pad == ' ')\n    padptr = blanks;\n  else if (pad == '0')\n    padptr = zeroes;\n  else\n    {\n      for (i = PADSIZE; --i >= 0; )\n\tpadbuf[i] = pad;\n      padptr = padbuf;\n    }\n  for (i = count; i >= PADSIZE; i -= PADSIZE)\n    {\n      w = _IO_sputn (fp, padptr, PADSIZE);\n      written += w;\n      if (w != PADSIZE)\n\treturn written;\n    }\n\n  if (i > 0)\n    {\n      w = _IO_sputn (fp, padptr, i);\n      written += w;\n    }\n  return written;\n}",
    "_IO_puts": "_IO_puts (const char *str){\n  int result = EOF;\n  size_t len = strlen (str);\n  _IO_acquire_lock (stdout);\n\n  if ((_IO_vtable_offset (stdout) != 0\n       || _IO_fwide (stdout, -1) == -1)\n      && _IO_sputn (stdout, str, len) == len\n      && _IO_putc_unlocked ('\\n', stdout) != EOF)\n    result = MIN (INT_MAX, len + 1);\n\n  _IO_release_lock (stdout);\n  return result;\n}",
    "_IO_seekoff": "_IO_seekoff (FILE *fp, off64_t offset, int dir, int mode){\n  off64_t retval;\n\n  _IO_acquire_lock (fp);\n  retval = _IO_seekoff_unlocked (fp, offset, dir, mode);\n  _IO_release_lock (fp);\n  return retval;\n}",
    "_IO_seekpos": "_IO_seekpos (FILE *fp, off64_t pos, int mode){\n  off64_t retval;\n\n  _IO_acquire_lock (fp);\n  retval = _IO_seekpos_unlocked (fp, pos, mode);\n  _IO_release_lock (fp);\n  return retval;\n}",
    "_IO_setbuffer": "_IO_setbuffer (FILE *fp, char *buf, size_t size){\n  CHECK_FILE (fp, );\n  _IO_acquire_lock (fp);\n  fp->_flags &= ~_IO_LINE_BUF;\n  if (!buf)\n    size = 0;\n  (void) _IO_SETBUF (fp, buf, size);\n  if (_IO_vtable_offset (fp) == 0 && fp->_mode == 0 && _IO_CHECK_WIDE (fp))\n    /* We also have to set the buffer using the wide char function.  */\n    (void) _IO_WSETBUF (fp, buf, size);\n  _IO_release_lock (fp);\n}",
    "_IO_setvbuf": "_IO_setvbuf (FILE *fp, char *buf, int mode, size_t size){\n  int result;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  switch (mode)\n    {\n    case _IOFBF:\n      fp->_flags &= ~(_IO_LINE_BUF|_IO_UNBUFFERED);\n      if (buf == NULL)\n\t{\n\t  if (fp->_IO_buf_base == NULL)\n\t    {\n\t      /* There is no flag to distinguish between \"fully buffered\n\t\t mode has been explicitly set\" as opposed to \"line\n\t\t buffering has not been explicitly set\".  In both\n\t\t cases, _IO_LINE_BUF is off.  If this is a tty, and\n\t\t _IO_filedoalloc later gets called, it cannot know if\n\t\t it should set the _IO_LINE_BUF flag (because that is\n\t\t the default), or not (because we have explicitly asked\n\t\t for fully buffered mode).  So we make sure a buffer\n\t\t gets allocated now, and explicitly turn off line\n\t\t buffering.\n\n\t\t A possibly cleaner alternative would be to add an\n\t\t extra flag, but then flags are a finite resource.  */\n\t      if (_IO_DOALLOCATE (fp) < 0)\n\t\t{\n\t\t  result = EOF;\n\t\t  goto unlock_return;\n\t\t}\n\t      fp->_flags &= ~_IO_LINE_BUF;\n\t    }\n\t  result = 0;\n\t  goto unlock_return;\n\t}\n      break;\n    case _IOLBF:\n      fp->_flags &= ~_IO_UNBUFFERED;\n      fp->_flags |= _IO_LINE_BUF;\n      if (buf == NULL)\n\t{\n\t  result = 0;\n\t  goto unlock_return;\n\t}\n      break;\n    case _IONBF:\n      fp->_flags &= ~_IO_LINE_BUF;\n      fp->_flags |= _IO_UNBUFFERED;\n      buf = NULL;\n      size = 0;\n      break;\n    default:\n      result = EOF;\n      goto unlock_return;\n    }\n  result = _IO_SETBUF (fp, buf, size) == NULL ? EOF : 0;\n\nunlock_return:\n  _IO_release_lock (fp);\n  return result;\n}",
    "ungetc": "ungetc (int c, FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (c == EOF)\n    return EOF;\n  if (!_IO_need_lock (fp))\n    return _IO_sputbackc (fp, (unsigned char) c);\n  _IO_acquire_lock (fp);\n  result = _IO_sputbackc (fp, (unsigned char) c);\n  _IO_release_lock (fp);\n  return result;\n}",
    "ungetwc": "ungetwc (wint_t c, FILE *fp){\n  wint_t result;\n  CHECK_FILE (fp, WEOF);\n  _IO_acquire_lock (fp);\n  _IO_fwide (fp, 1);\n  if (c == WEOF)\n    result = WEOF;\n  else\n    result = _IO_sputbackwc (fp, c);\n  _IO_release_lock (fp);\n  return result;\n}",
    "_IO_peekc_locked": "_IO_peekc_locked (FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  _IO_acquire_lock (fp);\n  result = _IO_peekc_unlocked (fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "_IO_putc": "_IO_putc (int c, FILE *fp){\n  int result;\n  CHECK_FILE (fp, EOF);\n  if (!_IO_need_lock (fp))\n    return _IO_putc_unlocked (c, fp);\n  _IO_acquire_lock (fp);\n  result = _IO_putc_unlocked (c, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "putchar": "putchar (int c){\n  int result;\n  _IO_acquire_lock (stdout);\n  result = _IO_putc_unlocked (c, stdout);\n  _IO_release_lock (stdout);\n  return result;\n}",
    "putchar_unlocked": "putchar_unlocked (int c){\n  CHECK_FILE (stdout, EOF);\n  return _IO_putc_unlocked (c, stdout);\n}",
    "putwc": "putwc (wchar_t wc, FILE *fp){\n  wint_t result;\n  CHECK_FILE (fp, WEOF);\n  _IO_acquire_lock (fp);\n  result = _IO_putwc_unlocked (wc, fp);\n  _IO_release_lock (fp);\n  return result;\n}",
    "putwc_unlocked": "putwc_unlocked (wchar_t wc, FILE *fp){\n  CHECK_FILE (fp, WEOF);\n  return _IO_putwc_unlocked (wc, fp);\n}",
    "putwchar": "putwchar (wchar_t wc){\n  wint_t result;\n  _IO_acquire_lock (stdout);\n  result = _IO_putwc_unlocked (wc, stdout);\n  _IO_release_lock (stdout);\n  return result;\n}",
    "putwchar_unlocked": "putwchar_unlocked (wchar_t wc){\n  CHECK_FILE (stdout, WEOF);\n  return _IO_putwc_unlocked (wc, stdout);\n}",
    "rewind": "rewind (FILE *fp){\n  CHECK_FILE (fp, );\n  _IO_acquire_lock (fp);\n  _IO_rewind (fp);\n  _IO_clearerr (fp);\n  _IO_release_lock (fp);\n}",
    "setbuf": "setbuf (FILE *fp, char *buf){\n  _IO_setbuffer (fp, buf, BUFSIZ);\n}",
    "setlinebuf": "setlinebuf (FILE *stream){\n  _IO_setvbuf (stream, NULL, 1, 0);\n}",
    "_IO_str_init_static": "_IO_str_init_static (_IO_strfile *sf, char *ptr, int size, char *pstart){\n  return _IO_str_init_static_internal (sf, ptr, size < 0 ? -1 : size, pstart);\n}",
    "_IO_str_init_readonly": "_IO_str_init_readonly (_IO_strfile *sf, const char *ptr, int size){\n  _IO_str_init_static_internal (sf, (char *) ptr, size < 0 ? -1 : size, NULL);\n  sf->_sbf._f._flags |= _IO_NO_WRITES;\n}",
    "_IO_str_overflow": "_IO_str_overflow (FILE *fp, int c){\n  int flush_only = c == EOF;\n  size_t pos;\n  if (fp->_flags & _IO_NO_WRITES)\n      return flush_only ? 0 : EOF;\n  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))\n    {\n      fp->_flags |= _IO_CURRENTLY_PUTTING;\n      fp->_IO_write_ptr = fp->_IO_read_ptr;\n      fp->_IO_read_ptr = fp->_IO_read_end;\n    }\n  pos = fp->_IO_write_ptr - fp->_IO_write_base;\n  if (pos >= (size_t) (_IO_blen (fp) + flush_only))\n    {\n      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */\n\treturn EOF;\n      else\n\t{\n\t  char *new_buf;\n\t  char *old_buf = fp->_IO_buf_base;\n\t  size_t old_blen = _IO_blen (fp);\n\t  size_t new_size = 2 * old_blen + 100;\n\t  if (new_size < old_blen)\n\t    return EOF;\n\t  new_buf = malloc (new_size);\n\t  if (new_buf == NULL)\n\t    {\n\t      /*\t  __ferror(fp) = 1; */\n\t      return EOF;\n\t    }\n\t  if (old_buf)\n\t    {\n\t      memcpy (new_buf, old_buf, old_blen);\n\t      free (old_buf);\n\t      /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n\t      fp->_IO_buf_base = NULL;\n\t    }\n\t  memset (new_buf + old_blen, '\\0', new_size - old_blen);\n\n\t  _IO_setb (fp, new_buf, new_buf + new_size, 1);\n\t  fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);\n\t  fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);\n\t  fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);\n\t  fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);\n\n\t  fp->_IO_write_base = new_buf;\n\t  fp->_IO_write_end = fp->_IO_buf_end;\n\t}\n    }\n\n  if (!flush_only)\n    *fp->_IO_write_ptr++ = (unsigned char) c;\n  if (fp->_IO_write_ptr > fp->_IO_read_end)\n    fp->_IO_read_end = fp->_IO_write_ptr;\n  if (flush_only)\n    return 0;\n  else\n    return c;\n}",
    "_IO_str_underflow": "_IO_str_underflow (FILE *fp){\n  if (fp->_IO_write_ptr > fp->_IO_read_end)\n    fp->_IO_read_end = fp->_IO_write_ptr;\n  if ((fp->_flags & _IO_TIED_PUT_GET) && (fp->_flags & _IO_CURRENTLY_PUTTING))\n    {\n      fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n      fp->_IO_read_ptr = fp->_IO_write_ptr;\n      fp->_IO_write_ptr = fp->_IO_write_end;\n    }\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *((unsigned char *) fp->_IO_read_ptr);\n  else\n    return EOF;\n}",
    "_IO_str_seekoff": "_IO_str_seekoff (FILE *fp, off64_t offset, int dir, int mode){\n  off64_t new_pos;\n\n  if (mode == 0 && (fp->_flags & _IO_TIED_PUT_GET))\n    mode = (fp->_flags & _IO_CURRENTLY_PUTTING ? _IOS_OUTPUT : _IOS_INPUT);\n\n  bool was_writing = (fp->_IO_write_ptr > fp->_IO_write_base\n\t\t     || _IO_in_put_mode (fp));\n  if (was_writing)\n    _IO_str_switch_to_get_mode (fp);\n\n  if (mode == 0)\n    {\n      new_pos = fp->_IO_read_ptr - fp->_IO_read_base;\n    }\n  else\n    {\n      ssize_t cur_size = _IO_str_count(fp);\n      new_pos = EOF;\n\n      /* Move the get pointer, if requested. */\n      if (mode & _IOS_INPUT)\n\t{\n\t  ssize_t base;\n\t  switch (dir)\n\t    {\n\t    case _IO_seek_set:\n\t      base = 0;\n\t      break;\n\t    case _IO_seek_cur:\n\t      base = fp->_IO_read_ptr - fp->_IO_read_base;\n\t      break;\n\t    default: /* case _IO_seek_end: */\n\t      base = cur_size;\n\t      break;\n\t    }\n\t  ssize_t maxval = SSIZE_MAX - base;\n\t  if (offset < -base || offset > maxval)\n\t    {\n\t      __set_errno (EINVAL);\n\t      return EOF;\n\t    }\n\t  base += offset;\n\t  if (base > cur_size\n\t      && enlarge_userbuf (fp, base, 1) != 0)\n\t    return EOF;\n\t  fp->_IO_read_ptr = fp->_IO_read_base + base;\n\t  fp->_IO_read_end = fp->_IO_read_base + cur_size;\n\t  new_pos = base;\n\t}\n\n      /* Move the put pointer, if requested. */\n      if (mode & _IOS_OUTPUT)\n\t{\n\t  ssize_t base;\n\t  switch (dir)\n\t    {\n\t    case _IO_seek_set:\n\t      base = 0;\n\t      break;\n\t    case _IO_seek_cur:\n\t      base = fp->_IO_write_ptr - fp->_IO_write_base;\n\t      break;\n\t    default: /* case _IO_seek_end: */\n\t      base = cur_size;\n\t      break;\n\t    }\n\t  ssize_t maxval = SSIZE_MAX - base;\n\t  if (offset < -base || offset > maxval)\n\t    {\n\t      __set_errno (EINVAL);\n\t      return EOF;\n\t    }\n\t  base += offset;\n\t  if (base > cur_size\n\t      && enlarge_userbuf (fp, base, 0) != 0)\n\t    return EOF;\n\t  fp->_IO_write_ptr = fp->_IO_write_base + base;\n\t  new_pos = base;\n\t}\n    }\n  return new_pos;\n}",
    "_IO_str_pbackfail": "_IO_str_pbackfail (FILE *fp, int c){\n  if ((fp->_flags & _IO_NO_WRITES) && c != EOF)\n    return EOF;\n  return _IO_default_pbackfail (fp, c);\n}",
    "_IO_wdo_write": "_IO_wdo_write (FILE *fp, const wchar_t *data, size_t to_do){\n  struct _IO_codecvt *cc = fp->_codecvt;\n\n  if (to_do > 0)\n    {\n      if (fp->_IO_write_end == fp->_IO_write_ptr\n\t  && fp->_IO_write_end != fp->_IO_write_base)\n\t{\n\t  if (_IO_new_do_write (fp, fp->_IO_write_base,\n\t\t\t\tfp->_IO_write_ptr - fp->_IO_write_base) == EOF)\n\t    return WEOF;\n\t}\n\n      do\n\t{\n\t  enum __codecvt_result result;\n\t  const wchar_t *new_data;\n\t  char mb_buf[MB_LEN_MAX];\n\t  char *write_base, *write_ptr, *buf_end;\n\n\t  if (fp->_IO_buf_end - fp->_IO_write_ptr < sizeof (mb_buf))\n\t    {\n\t      /* Make sure we have room for at least one multibyte\n\t\t character.  */\n\t      write_ptr = write_base = mb_buf;\n\t      buf_end = mb_buf + sizeof (mb_buf);\n\t    }\n\t  else\n\t    {\n\t      write_ptr = fp->_IO_write_ptr;\n\t      write_base = fp->_IO_write_base;\n\t      buf_end = fp->_IO_buf_end;\n\t    }\n\n\t  /* Now convert from the internal format into the external buffer.  */\n\t  result = __libio_codecvt_out (cc, &fp->_wide_data->_IO_state,\n\t\t\t\t\tdata, data + to_do, &new_data,\n\t\t\t\t\twrite_ptr,\n\t\t\t\t\tbuf_end,\n\t\t\t\t\t&write_ptr);\n\n\t  /* Write out what we produced so far.  */\n\t  if (_IO_new_do_write (fp, write_base, write_ptr - write_base) == EOF)\n\t    /* Something went wrong.  */\n\t    return WEOF;\n\n\t  to_do -= new_data - data;\n\n\t  /* Next see whether we had problems during the conversion.  If yes,\n\t     we cannot go on.  */\n\t  if (result != __codecvt_ok\n\t      && (result != __codecvt_partial || new_data - data == 0))\n\t    break;\n\n\t  data = new_data;\n\t}\n      while (to_do > 0);\n    }\n\n  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base,\n\t     fp->_wide_data->_IO_buf_base);\n  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n    = fp->_wide_data->_IO_buf_base;\n  fp->_wide_data->_IO_write_end = ((fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n\t\t\t\t   ? fp->_wide_data->_IO_buf_base\n\t\t\t\t   : fp->_wide_data->_IO_buf_end);\n\n  return to_do == 0 ? 0 : WEOF;\n}",
    "_IO_wfile_underflow": "_IO_wfile_underflow (FILE *fp){\n  struct _IO_codecvt *cd;\n  enum __codecvt_result status;\n  ssize_t count;\n\n  /* C99 requires EOF to be \"sticky\".  */\n  if (fp->_flags & _IO_EOF_SEEN)\n    return WEOF;\n\n  if (__glibc_unlikely (fp->_flags & _IO_NO_READS))\n    {\n      fp->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n    return *fp->_wide_data->_IO_read_ptr;\n\n  cd = fp->_codecvt;\n\n  /* Maybe there is something left in the external buffer.  */\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    {\n      /* There is more in the external.  Convert it.  */\n      const char *read_stop = (const char *) fp->_IO_read_ptr;\n\n      fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;\n      fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr =\n\tfp->_wide_data->_IO_buf_base;\n      status = __libio_codecvt_in (cd, &fp->_wide_data->_IO_state,\n\t\t\t\t   fp->_IO_read_ptr, fp->_IO_read_end,\n\t\t\t\t   &read_stop,\n\t\t\t\t   fp->_wide_data->_IO_read_ptr,\n\t\t\t\t   fp->_wide_data->_IO_buf_end,\n\t\t\t\t   &fp->_wide_data->_IO_read_end);\n\n      fp->_IO_read_base = fp->_IO_read_ptr;\n      fp->_IO_read_ptr = (char *) read_stop;\n\n      /* If we managed to generate some text return the next character.  */\n      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n\treturn *fp->_wide_data->_IO_read_ptr;\n\n      if (status == __codecvt_error)\n\t{\n\t  __set_errno (EILSEQ);\n\t  fp->_flags |= _IO_ERR_SEEN;\n\t  return WEOF;\n\t}\n\n      /* Move the remaining content of the read buffer to the beginning.  */\n      memmove (fp->_IO_buf_base, fp->_IO_read_ptr,\n\t       fp->_IO_read_end - fp->_IO_read_ptr);\n      fp->_IO_read_end = (fp->_IO_buf_base\n\t\t\t  + (fp->_IO_read_end - fp->_IO_read_ptr));\n      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_buf_base;\n    }\n  else\n    fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =\n      fp->_IO_buf_base;\n\n  if (fp->_IO_buf_base == NULL)\n    {\n      /* Maybe we already have a push back pointer.  */\n      if (fp->_IO_save_base != NULL)\n\t{\n\t  free (fp->_IO_save_base);\n\t  fp->_flags &= ~_IO_IN_BACKUP;\n\t}\n      _IO_doallocbuf (fp);\n\n      fp->_IO_read_base = fp->_IO_read_ptr = fp->_IO_read_end =\n\tfp->_IO_buf_base;\n    }\n\n  fp->_IO_write_base = fp->_IO_write_ptr = fp->_IO_write_end =\n    fp->_IO_buf_base;\n\n  if (fp->_wide_data->_IO_buf_base == NULL)\n    {\n      /* Maybe we already have a push back pointer.  */\n      if (fp->_wide_data->_IO_save_base != NULL)\n\t{\n\t  free (fp->_wide_data->_IO_save_base);\n\t  fp->_flags &= ~_IO_IN_BACKUP;\n\t}\n      _IO_wdoallocbuf (fp);\n    }\n\n  /* FIXME This can/should be moved to genops ?? */\n  if (fp->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n    {\n      /* We used to flush all line-buffered stream.  This really isn't\n\t required by any standard.  My recollection is that\n\t traditional Unix systems did this for stdout.  stderr better\n\t not be line buffered.  So we do just that here\n\t explicitly.  --drepper */\n      _IO_acquire_lock (stdout);\n\n      if ((stdout->_flags & (_IO_LINKED | _IO_NO_WRITES | _IO_LINE_BUF))\n\t  == (_IO_LINKED | _IO_LINE_BUF))\n\t_IO_OVERFLOW (stdout, EOF);\n\n      _IO_release_lock (stdout);\n    }\n\n  _IO_switch_to_get_mode (fp);\n\n  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr =\n    fp->_wide_data->_IO_buf_base;\n  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_buf_base;\n  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr =\n    fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_buf_base;\n\n  const char *read_ptr_copy;\n  char accbuf[MB_LEN_MAX];\n  size_t naccbuf = 0;\n again:\n  count = _IO_SYSREAD (fp, fp->_IO_read_end,\n\t\t       fp->_IO_buf_end - fp->_IO_read_end);\n  if (count <= 0)\n    {\n      if (count == 0 && naccbuf == 0)\n\t{\n\t  fp->_flags |= _IO_EOF_SEEN;\n\t  fp->_offset = _IO_pos_BAD;\n\t}\n      else\n\tfp->_flags |= _IO_ERR_SEEN, count = 0;\n    }\n  fp->_IO_read_end += count;\n  if (count == 0)\n    {\n      if (naccbuf != 0)\n\t/* There are some bytes in the external buffer but they don't\n\t   convert to anything.  */\n\t__set_errno (EILSEQ);\n      return WEOF;\n    }\n  if (fp->_offset != _IO_pos_BAD)\n    _IO_pos_adjust (fp->_offset, count);\n\n  /* Now convert the read input.  */\n  fp->_wide_data->_IO_last_state = fp->_wide_data->_IO_state;\n  fp->_IO_read_base = fp->_IO_read_ptr;\n  const char *from = fp->_IO_read_ptr;\n  const char *to = fp->_IO_read_end;\n  size_t to_copy = count;\n  if (__glibc_unlikely (naccbuf != 0))\n    {\n      to_copy = MIN (sizeof (accbuf) - naccbuf, count);\n      to = __mempcpy (&accbuf[naccbuf], from, to_copy);\n      naccbuf += to_copy;\n      from = accbuf;\n    }\n  status = __libio_codecvt_in (cd, &fp->_wide_data->_IO_state,\n\t\t\t       from, to, &read_ptr_copy,\n\t\t\t       fp->_wide_data->_IO_read_end,\n\t\t\t       fp->_wide_data->_IO_buf_end,\n\t\t\t       &fp->_wide_data->_IO_read_end);\n\n  if (__glibc_unlikely (naccbuf != 0))\n    fp->_IO_read_ptr += MAX (0, read_ptr_copy - &accbuf[naccbuf - to_copy]);\n  else\n    fp->_IO_read_ptr = (char *) read_ptr_copy;\n  if (fp->_wide_data->_IO_read_end == fp->_wide_data->_IO_buf_base)\n    {\n      if (status == __codecvt_error)\n\t{\n\tout_eilseq:\n\t  __set_errno (EILSEQ);\n\t  fp->_flags |= _IO_ERR_SEEN;\n\t  return WEOF;\n\t}\n\n      /* The read bytes make no complete character.  Try reading again.  */\n      assert (status == __codecvt_partial);\n\n      if (naccbuf == 0)\n\t{\n\t  if (fp->_IO_read_base < fp->_IO_read_ptr)\n\t    {\n\t      /* Partially used the buffer for some input data that\n\t\t produces no output.  */\n\t      size_t avail = fp->_IO_read_end - fp->_IO_read_ptr;\n\t      memmove (fp->_IO_read_base, fp->_IO_read_ptr, avail);\n\t      fp->_IO_read_ptr = fp->_IO_read_base;\n\t      fp->_IO_read_end -= avail;\n\t      goto again;\n\t    }\n\t  naccbuf = fp->_IO_read_end - fp->_IO_read_ptr;\n\t  if (naccbuf >= sizeof (accbuf))\n\t    goto out_eilseq;\n\n\t  memcpy (accbuf, fp->_IO_read_ptr, naccbuf);\n\t}\n      else\n\t{\n\t  size_t used = read_ptr_copy - accbuf;\n\t  if (used > 0)\n\t    {\n\t      memmove (accbuf, read_ptr_copy, naccbuf - used);\n\t      naccbuf -= used;\n\t    }\n\n\t  if (naccbuf == sizeof (accbuf))\n\t    goto out_eilseq;\n\t}\n\n      fp->_IO_read_ptr = fp->_IO_read_end = fp->_IO_read_base;\n\n      goto again;\n    }\n\n  return *fp->_wide_data->_IO_read_ptr;\n}",
    "_IO_wfile_overflow": "_IO_wfile_overflow (FILE *f, wint_t wch){\n  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n    {\n      f->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  /* If currently reading or no buffer allocated. */\n  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0\n      || f->_wide_data->_IO_write_base == NULL)\n    {\n      /* Allocate a buffer if needed. */\n      if (f->_wide_data->_IO_write_base == 0)\n\t{\n\t  _IO_wdoallocbuf (f);\n\t  _IO_free_wbackup_area (f);\n\t  _IO_wsetg (f, f->_wide_data->_IO_buf_base,\n\t\t     f->_wide_data->_IO_buf_base, f->_wide_data->_IO_buf_base);\n\n\t  if (f->_IO_write_base == NULL)\n\t    {\n\t      _IO_doallocbuf (f);\n\t      _IO_setg (f, f->_IO_buf_base, f->_IO_buf_base, f->_IO_buf_base);\n\t    }\n\t}\n      else\n\t{\n\t  /* Otherwise must be currently reading.  If _IO_read_ptr\n\t     (and hence also _IO_read_end) is at the buffer end,\n\t     logically slide the buffer forwards one block (by setting\n\t     the read pointers to all point at the beginning of the\n\t     block).  This makes room for subsequent output.\n\t     Otherwise, set the read pointers to _IO_read_end (leaving\n\t     that alone, so it can continue to correspond to the\n\t     external position). */\n\t  if (f->_wide_data->_IO_read_ptr == f->_wide_data->_IO_buf_end)\n\t    {\n\t      f->_IO_read_end = f->_IO_read_ptr = f->_IO_buf_base;\n\t      f->_wide_data->_IO_read_end = f->_wide_data->_IO_read_ptr =\n\t\tf->_wide_data->_IO_buf_base;\n\t    }\n\t}\n      f->_wide_data->_IO_write_ptr = f->_wide_data->_IO_read_ptr;\n      f->_wide_data->_IO_write_base = f->_wide_data->_IO_write_ptr;\n      f->_wide_data->_IO_write_end = f->_wide_data->_IO_buf_end;\n      f->_wide_data->_IO_read_base = f->_wide_data->_IO_read_ptr =\n\tf->_wide_data->_IO_read_end;\n\n      f->_IO_write_ptr = f->_IO_read_ptr;\n      f->_IO_write_base = f->_IO_write_ptr;\n      f->_IO_write_end = f->_IO_buf_end;\n      f->_IO_read_base = f->_IO_read_ptr = f->_IO_read_end;\n\n      f->_flags |= _IO_CURRENTLY_PUTTING;\n      if (f->_flags & (_IO_LINE_BUF | _IO_UNBUFFERED))\n\tf->_wide_data->_IO_write_end = f->_wide_data->_IO_write_ptr;\n    }\n  if (wch == WEOF)\n    return _IO_do_flush (f);\n  if (f->_wide_data->_IO_write_ptr == f->_wide_data->_IO_buf_end)\n    /* Buffer is really full */\n    if (_IO_do_flush (f) == EOF)\n      return WEOF;\n  *f->_wide_data->_IO_write_ptr++ = wch;\n  if ((f->_flags & _IO_UNBUFFERED)\n      || ((f->_flags & _IO_LINE_BUF) && wch == L'\\n'))\n    if (_IO_do_flush (f) == EOF)\n      return WEOF;\n  return wch;\n}",
    "_IO_wfile_sync": "_IO_wfile_sync (FILE *fp){\n  ssize_t delta;\n  wint_t retval = 0;\n\n  /*    char* ptr = cur_ptr(); */\n  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n    if (_IO_do_flush (fp))\n      return WEOF;\n  delta = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n  if (delta != 0)\n    {\n      /* We have to find out how many bytes we have to go back in the\n\t external buffer.  */\n      struct _IO_codecvt *cv = fp->_codecvt;\n      off64_t new_pos;\n\n      int clen = __libio_codecvt_encoding (cv);\n\n      if (clen > 0)\n\t/* It is easy, a fixed number of input bytes are used for each\n\t   wide character.  */\n\tdelta *= clen;\n      else\n\t{\n\t  /* We have to find out the hard way how much to back off.\n\t     To do this we determine how much input we needed to\n\t     generate the wide characters up to the current reading\n\t     position.  */\n\t  int nread;\n\t  size_t wnread = (fp->_wide_data->_IO_read_ptr\n\t\t\t   - fp->_wide_data->_IO_read_base);\n\t  fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n\t  nread = __libio_codecvt_length (cv, &fp->_wide_data->_IO_state,\n\t\t\t\t\t  fp->_IO_read_base,\n\t\t\t\t\t  fp->_IO_read_end, wnread);\n\t  fp->_IO_read_ptr = fp->_IO_read_base + nread;\n\t  delta = -(fp->_IO_read_end - fp->_IO_read_base - nread);\n\t}\n\n      new_pos = _IO_SYSSEEK (fp, delta, 1);\n      if (new_pos != (off64_t) EOF)\n\t{\n\t  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n\t  fp->_IO_read_end = fp->_IO_read_ptr;\n\t}\n      else if (errno == ESPIPE)\n\t; /* Ignore error from unseekable devices. */\n      else\n\tretval = WEOF;\n    }\n  if (retval != WEOF)\n    fp->_offset = _IO_pos_BAD;\n  /* FIXME: Cleanup - can this be shared? */\n  /*    setg(base(), ptr, ptr); */\n  return retval;\n}",
    "_IO_wfile_seekoff": "_IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode){\n  off64_t result;\n  off64_t delta, new_offset;\n  long int count;\n\n  /* Short-circuit into a separate function.  We don't want to mix any\n     functionality and we don't want to touch anything inside the FILE\n     object. */\n  if (mode == 0)\n    return do_ftell_wide (fp);\n\n  /* POSIX.1 8.2.3.7 says that after a call the fflush() the file\n     offset of the underlying file must be exact.  */\n  int must_be_exact = ((fp->_wide_data->_IO_read_base\n\t\t\t== fp->_wide_data->_IO_read_end)\n\t\t       && (fp->_wide_data->_IO_write_base\n\t\t\t   == fp->_wide_data->_IO_write_ptr));\n\n  bool was_writing = ((fp->_wide_data->_IO_write_ptr\n\t\t       > fp->_wide_data->_IO_write_base)\n\t\t      || _IO_in_put_mode (fp));\n\n  /* Flush unwritten characters.\n     (This may do an unneeded write if we seek within the buffer.\n     But to be able to switch to reading, we would need to set\n     egptr to pptr.  That can't be done in the current design,\n     which assumes file_ptr() is eGptr.  Anyway, since we probably\n     end up flushing when we close(), it doesn't make much difference.)\n     FIXME: simulate mem-mapped files. */\n  if (was_writing && _IO_switch_to_wget_mode (fp))\n    return WEOF;\n\n  if (fp->_wide_data->_IO_buf_base == NULL)\n    {\n      /* It could be that we already have a pushback buffer.  */\n      if (fp->_wide_data->_IO_read_base != NULL)\n\t{\n\t  free (fp->_wide_data->_IO_read_base);\n\t  fp->_flags &= ~_IO_IN_BACKUP;\n\t}\n      _IO_doallocbuf (fp);\n      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base);\n      _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n    }\n\n  switch (dir)\n    {\n      struct _IO_codecvt *cv;\n      int clen;\n\n    case _IO_seek_cur:\n      /* Adjust for read-ahead (bytes is buffer).  To do this we must\n\t find out which position in the external buffer corresponds to\n\t the current position in the internal buffer.  */\n      cv = fp->_codecvt;\n      clen = __libio_codecvt_encoding (cv);\n\n      if (mode != 0 || !was_writing)\n\t{\n\t  if (clen > 0)\n\t    {\n\t      offset -= (fp->_wide_data->_IO_read_end\n\t\t\t - fp->_wide_data->_IO_read_ptr) * clen;\n\t      /* Adjust by readahead in external buffer.  */\n\t      offset -= fp->_IO_read_end - fp->_IO_read_ptr;\n\t    }\n\t  else\n\t    {\n\t      int nread;\n\n\t      delta = (fp->_wide_data->_IO_read_ptr\n\t\t       - fp->_wide_data->_IO_read_base);\n\t      fp->_wide_data->_IO_state = fp->_wide_data->_IO_last_state;\n\t      nread = __libio_codecvt_length (cv,\n\t\t\t\t\t      &fp->_wide_data->_IO_state,\n\t\t\t\t\t      fp->_IO_read_base,\n\t\t\t\t\t      fp->_IO_read_end, delta);\n\t      fp->_IO_read_ptr = fp->_IO_read_base + nread;\n\t      fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_read_ptr;\n\t      offset -= fp->_IO_read_end - fp->_IO_read_base - nread;\n\t    }\n\t}\n\n      if (fp->_offset == _IO_pos_BAD)\n\tgoto dumb;\n\n      /* Make offset absolute, assuming current pointer is file_ptr(). */\n      offset += fp->_offset;\n\n      dir = _IO_seek_set;\n      break;\n    case _IO_seek_set:\n      break;\n    case _IO_seek_end:\n      {\n\tstruct __stat64_t64 st;\n\tif (_IO_SYSSTAT (fp, &st) == 0 && S_ISREG (st.st_mode))\n\t  {\n\t    offset += st.st_size;\n\t    dir = _IO_seek_set;\n\t  }\n\telse\n\t  goto dumb;\n      }\n    }\n\n  _IO_free_wbackup_area (fp);\n\n  /* At this point, dir==_IO_seek_set. */\n\n  /* If destination is within current buffer, optimize: */\n  if (fp->_offset != _IO_pos_BAD && fp->_IO_read_base != NULL\n      && !_IO_in_backup (fp))\n    {\n      off64_t start_offset = (fp->_offset\n                              - (fp->_IO_read_end - fp->_IO_buf_base));\n      if (offset >= start_offset && offset < fp->_offset)\n\t{\n\t  _IO_setg (fp, fp->_IO_buf_base,\n\t\t    fp->_IO_buf_base + (offset - start_offset),\n\t\t    fp->_IO_read_end);\n\t  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n\t  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t\t     fp->_wide_data->_IO_buf_base,\n\t\t     fp->_wide_data->_IO_buf_base);\n\t  _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n\t\t     fp->_wide_data->_IO_buf_base);\n\n\t  if (adjust_wide_data (fp, false))\n\t    goto dumb;\n\n\t  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n\t  goto resync;\n\t}\n    }\n\n  if (fp->_flags & _IO_NO_READS)\n    goto dumb;\n\n  /* Try to seek to a block boundary, to improve kernel page management. */\n  new_offset = offset & ~(fp->_IO_buf_end - fp->_IO_buf_base - 1);\n  delta = offset - new_offset;\n  if (delta > fp->_IO_buf_end - fp->_IO_buf_base)\n    {\n      new_offset = offset;\n      delta = 0;\n    }\n  result = _IO_SYSSEEK (fp, new_offset, 0);\n  if (result < 0)\n    return EOF;\n  if (delta == 0)\n    count = 0;\n  else\n    {\n      count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n\t\t\t   (must_be_exact\n\t\t\t    ? delta : fp->_IO_buf_end - fp->_IO_buf_base));\n      if (count < delta)\n\t{\n\t  /* We weren't allowed to read, but try to seek the remainder. */\n\t  offset = count == EOF ? delta : delta-count;\n\t  dir = _IO_seek_cur;\n\t  goto dumb;\n\t}\n    }\n  _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base + delta,\n\t    fp->_IO_buf_base + count);\n  _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n  _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t     fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n  _IO_wsetp (fp, fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n\n  if (adjust_wide_data (fp, true))\n    goto dumb;\n\n  fp->_offset = result + count;\n  _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n  return offset;\n dumb:\n\n  _IO_unsave_markers (fp);\n  result = _IO_SYSSEEK (fp, offset, dir);\n  if (result != EOF)\n    {\n      _IO_mask_flags (fp, 0, _IO_EOF_SEEN);\n      fp->_offset = result;\n      _IO_setg (fp, fp->_IO_buf_base, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_setp (fp, fp->_IO_buf_base, fp->_IO_buf_base);\n      _IO_wsetg (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base, fp->_wide_data->_IO_buf_base);\n      _IO_wsetp (fp, fp->_wide_data->_IO_buf_base,\n\t\t fp->_wide_data->_IO_buf_base);\n    }\n  return result;\n\nresync:\n  /* We need to do it since it is possible that the file offset in\n     the kernel may be changed behind our back. It may happen when\n     we fopen a file and then do a fork. One process may access the\n     file and the kernel file offset will be changed. */\n  if (fp->_offset >= 0)\n    _IO_SYSSEEK (fp, fp->_offset, 0);\n\n  return offset;\n}",
    "_IO_wfile_xsputn": "_IO_wfile_xsputn (FILE *f, const void *data, size_t n){\n  const wchar_t *s = (const wchar_t *) data;\n  size_t to_do = n;\n  int must_flush = 0;\n  size_t count;\n\n  if (n <= 0)\n    return 0;\n  /* This is an optimized implementation.\n     If the amount to be written straddles a block boundary\n     (or the filebuf is unbuffered), use sys_write directly. */\n\n  /* First figure out how much space is available in the buffer. */\n  count = f->_wide_data->_IO_write_end - f->_wide_data->_IO_write_ptr;\n  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n    {\n      count = f->_wide_data->_IO_buf_end - f->_wide_data->_IO_write_ptr;\n      if (count >= n)\n\t{\n\t  const wchar_t *p;\n\t  for (p = s + n; p > s; )\n\t    {\n\t      if (*--p == L'\\n')\n\t\t{\n\t\t  count = p - s + 1;\n\t\t  must_flush = 1;\n\t\t  break;\n\t\t}\n\t    }\n\t}\n    }\n  /* Then fill the buffer. */\n  if (count > 0)\n    {\n      if (count > to_do)\n\tcount = to_do;\n      if (count > 20)\n\t{\n\t  f->_wide_data->_IO_write_ptr =\n\t    __wmempcpy (f->_wide_data->_IO_write_ptr, s, count);\n\t  s += count;\n\t}\n      else\n\t{\n\t  wchar_t *p = f->_wide_data->_IO_write_ptr;\n\t  int i = (int) count;\n\t  while (--i >= 0)\n\t    *p++ = *s++;\n\t  f->_wide_data->_IO_write_ptr = p;\n\t}\n      to_do -= count;\n    }\n  if (to_do > 0)\n    to_do -= _IO_wdefault_xsputn (f, s, to_do);\n  if (must_flush\n      && f->_wide_data->_IO_write_ptr != f->_wide_data->_IO_write_base)\n    _IO_wdo_write (f, f->_wide_data->_IO_write_base,\n\t\t   f->_wide_data->_IO_write_ptr\n\t\t   - f->_wide_data->_IO_write_base);\n\n  return n - to_do;\n}",
    "_IO_least_wmarker": "_IO_least_wmarker (FILE *fp, wchar_t *end_p){\n  ssize_t least_so_far = end_p - fp->_wide_data->_IO_read_base;\n  struct _IO_marker *mark;\n  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n    if (mark->_pos < least_so_far)\n      least_so_far = mark->_pos;\n  return least_so_far;\n}",
    "_IO_switch_to_main_wget_area": "_IO_switch_to_main_wget_area (FILE *fp){\n  wchar_t *tmp;\n  fp->_flags &= ~_IO_IN_BACKUP;\n  /* Swap _IO_read_end and _IO_save_end. */\n  tmp = fp->_wide_data->_IO_read_end;\n  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_save_end;\n  fp->_wide_data->_IO_save_end= tmp;\n  /* Swap _IO_read_base and _IO_save_base. */\n  tmp = fp->_wide_data->_IO_read_base;\n  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_save_base;\n  fp->_wide_data->_IO_save_base = tmp;\n  /* Set _IO_read_ptr. */\n  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_base;\n}",
    "_IO_switch_to_wbackup_area": "_IO_switch_to_wbackup_area (FILE *fp){\n  wchar_t *tmp;\n  fp->_flags |= _IO_IN_BACKUP;\n  /* Swap _IO_read_end and _IO_save_end. */\n  tmp = fp->_wide_data->_IO_read_end;\n  fp->_wide_data->_IO_read_end = fp->_wide_data->_IO_save_end;\n  fp->_wide_data->_IO_save_end = tmp;\n  /* Swap _IO_read_base and _IO_save_base. */\n  tmp = fp->_wide_data->_IO_read_base;\n  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_save_base;\n  fp->_wide_data->_IO_save_base = tmp;\n  /* Set _IO_read_ptr.  */\n  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end;\n}",
    "_IO_wsetb": "_IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a){\n  if (f->_wide_data->_IO_buf_base && !(f->_flags2 & _IO_FLAGS2_USER_WBUF))\n    free (f->_wide_data->_IO_buf_base);\n  f->_wide_data->_IO_buf_base = b;\n  f->_wide_data->_IO_buf_end = eb;\n  if (a)\n    f->_flags2 &= ~_IO_FLAGS2_USER_WBUF;\n  else\n    f->_flags2 |= _IO_FLAGS2_USER_WBUF;\n}",
    "_IO_wdefault_pbackfail": "_IO_wdefault_pbackfail (FILE *fp, wint_t c){\n  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n      && !_IO_in_backup (fp)\n      && (wint_t) fp->_IO_read_ptr[-1] == c)\n    --fp->_IO_read_ptr;\n  else\n    {\n      /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/\n      if (!_IO_in_backup (fp))\n\t{\n\t  /* We need to keep the invariant that the main get area\n\t     logically follows the backup area.  */\n\t  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n\t      && _IO_have_wbackup (fp))\n\t    {\n\t      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_ptr))\n\t\treturn WEOF;\n\t    }\n\t  else if (!_IO_have_wbackup (fp))\n\t    {\n\t      /* No backup buffer: allocate one. */\n\t      /* Use nshort buffer, if unused? (probably not)  FIXME */\n\t      int backup_size = 128;\n\t      wchar_t *bbuf = (wchar_t *) malloc (backup_size\n\t\t\t\t\t\t  * sizeof (wchar_t));\n\t      if (bbuf == NULL)\n\t\treturn WEOF;\n\t      fp->_wide_data->_IO_save_base = bbuf;\n\t      fp->_wide_data->_IO_save_end = (fp->_wide_data->_IO_save_base\n\t\t\t\t\t      + backup_size);\n\t      fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_save_end;\n\t    }\n\t  fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_read_ptr;\n\t  _IO_switch_to_wbackup_area (fp);\n\t}\n      else if (fp->_wide_data->_IO_read_ptr <= fp->_wide_data->_IO_read_base)\n\t{\n\t  /* Increase size of existing backup buffer. */\n\t  size_t new_size;\n\t  size_t old_size = (fp->_wide_data->_IO_read_end\n                             - fp->_wide_data->_IO_read_base);\n\t  wchar_t *new_buf;\n\t  new_size = 2 * old_size;\n\t  new_buf = (wchar_t *) malloc (new_size * sizeof (wchar_t));\n\t  if (new_buf == NULL)\n\t    return WEOF;\n\t  __wmemcpy (new_buf + (new_size - old_size),\n\t\t     fp->_wide_data->_IO_read_base, old_size);\n\t  free (fp->_wide_data->_IO_read_base);\n\t  _IO_wsetg (fp, new_buf, new_buf + (new_size - old_size),\n\t\t     new_buf + new_size);\n\t  fp->_wide_data->_IO_backup_base = fp->_wide_data->_IO_read_ptr;\n\t}\n\n      *--fp->_wide_data->_IO_read_ptr = c;\n    }\n  return c;\n}",
    "_IO_wdefault_finish": "_IO_wdefault_finish (FILE *fp, int dummy){\n  struct _IO_marker *mark;\n  if (fp->_wide_data->_IO_buf_base && !(fp->_flags2 & _IO_FLAGS2_USER_WBUF))\n    {\n      free (fp->_wide_data->_IO_buf_base);\n      fp->_wide_data->_IO_buf_base = fp->_wide_data->_IO_buf_end = NULL;\n    }\n\n  for (mark = fp->_markers; mark != NULL; mark = mark->_next)\n    mark->_sbuf = NULL;\n\n  if (fp->_IO_save_base)\n    {\n      free (fp->_wide_data->_IO_save_base);\n      fp->_IO_save_base = NULL;\n    }\n\n#ifdef _IO_MTSAFE_IO\n  if (fp->_lock != NULL)\n    _IO_lock_fini (*fp->_lock);\n#endif\n\n  _IO_un_link ((struct _IO_FILE_plus *) fp);\n}",
    "_IO_wdefault_uflow": "_IO_wdefault_uflow (FILE *fp){\n  wint_t wch;\n  wch = _IO_UNDERFLOW (fp);\n  if (wch == WEOF)\n    return WEOF;\n  return *fp->_wide_data->_IO_read_ptr++;\n}",
    "__woverflow": "__woverflow (FILE *f, wint_t wch){\n  if (f->_mode == 0)\n    _IO_fwide (f, 1);\n  return _IO_OVERFLOW (f, wch);\n}",
    "__wuflow": "__wuflow (FILE *fp){\n  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n    return WEOF;\n\n  if (fp->_mode == 0)\n    _IO_fwide (fp, 1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_wget_mode (fp) == EOF)\n      return WEOF;\n  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n    return *fp->_wide_data->_IO_read_ptr++;\n  if (_IO_in_backup (fp))\n    {\n      _IO_switch_to_main_wget_area (fp);\n      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n\treturn *fp->_wide_data->_IO_read_ptr++;\n    }\n  if (_IO_have_markers (fp))\n    {\n      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_end))\n\treturn WEOF;\n    }\n  else if (_IO_have_wbackup (fp))\n    _IO_free_wbackup_area (fp);\n  return _IO_UFLOW (fp);\n}",
    "__wunderflow": "__wunderflow (FILE *fp){\n  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n    return WEOF;\n\n  if (fp->_mode == 0)\n    _IO_fwide (fp, 1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_wget_mode (fp) == EOF)\n      return WEOF;\n  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n    return *fp->_wide_data->_IO_read_ptr;\n  if (_IO_in_backup (fp))\n    {\n      _IO_switch_to_main_wget_area (fp);\n      if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n\treturn *fp->_wide_data->_IO_read_ptr;\n    }\n  if (_IO_have_markers (fp))\n    {\n      if (save_for_wbackup (fp, fp->_wide_data->_IO_read_end))\n\treturn WEOF;\n    }\n  else if (_IO_have_backup (fp))\n    _IO_free_wbackup_area (fp);\n  return _IO_UNDERFLOW (fp);\n}",
    "_IO_wdefault_xsputn": "_IO_wdefault_xsputn (FILE *f, const void *data, size_t n){\n  const wchar_t *s = (const wchar_t *) data;\n  size_t more = n;\n  if (more <= 0)\n    return 0;\n  for (;;)\n    {\n      /* Space available. */\n      ssize_t count = (f->_wide_data->_IO_write_end\n                       - f->_wide_data->_IO_write_ptr);\n      if (count > 0)\n\t{\n\t  if ((size_t) count > more)\n\t    count = more;\n\t  if (count > 20)\n\t    {\n\t      f->_wide_data->_IO_write_ptr =\n\t\t__wmempcpy (f->_wide_data->_IO_write_ptr, s, count);\n\t      s += count;\n            }\n\t  else if (count <= 0)\n\t    count = 0;\n\t  else\n\t    {\n\t      wchar_t *p = f->_wide_data->_IO_write_ptr;\n\t      ssize_t i;\n\t      for (i = count; --i >= 0; )\n\t\t*p++ = *s++;\n\t      f->_wide_data->_IO_write_ptr = p;\n            }\n\t  more -= count;\n        }\n      if (more == 0 || __woverflow (f, *s++) == WEOF)\n\tbreak;\n      more--;\n    }\n  return n - more;\n}",
    "_IO_wdefault_xsgetn": "_IO_wdefault_xsgetn (FILE *fp, void *data, size_t n){\n  size_t more = n;\n  wchar_t *s = (wchar_t*) data;\n  for (;;)\n    {\n      /* Data available. */\n      ssize_t count = (fp->_wide_data->_IO_read_end\n                       - fp->_wide_data->_IO_read_ptr);\n      if (count > 0)\n\t{\n\t  if ((size_t) count > more)\n\t    count = more;\n\t  if (count > 20)\n\t    {\n\t      s = __wmempcpy (s, fp->_wide_data->_IO_read_ptr, count);\n\t      fp->_wide_data->_IO_read_ptr += count;\n\t    }\n\t  else if (count <= 0)\n\t    count = 0;\n\t  else\n\t    {\n\t      wchar_t *p = fp->_wide_data->_IO_read_ptr;\n\t      int i = (int) count;\n\t      while (--i >= 0)\n\t\t*s++ = *p++;\n\t      fp->_wide_data->_IO_read_ptr = p;\n            }\n            more -= count;\n        }\n      if (more == 0 || __wunderflow (fp) == WEOF)\n\tbreak;\n    }\n  return n - more;\n}",
    "_IO_wdoallocbuf": "_IO_wdoallocbuf (FILE *fp){\n  if (fp->_wide_data->_IO_buf_base)\n    return;\n  if (!(fp->_flags & _IO_UNBUFFERED))\n    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)\n      return;\n  _IO_wsetb (fp, fp->_wide_data->_shortbuf,\n\t\t     fp->_wide_data->_shortbuf + 1, 0);\n}",
    "_IO_wdefault_doallocate": "_IO_wdefault_doallocate (FILE *fp){\n  wchar_t *buf = (wchar_t *)malloc (BUFSIZ);\n  if (__glibc_unlikely (buf == NULL))\n    return EOF;\n\n  _IO_wsetb (fp, buf, buf + BUFSIZ / sizeof *buf, 1);\n  return 1;\n}",
    "_IO_switch_to_wget_mode": "_IO_switch_to_wget_mode (FILE *fp){\n  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF)\n      return EOF;\n  if (_IO_in_backup (fp))\n    fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_backup_base;\n  else\n    {\n      fp->_wide_data->_IO_read_base = fp->_wide_data->_IO_buf_base;\n      if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_read_end)\n\tfp->_wide_data->_IO_read_end = fp->_wide_data->_IO_write_ptr;\n    }\n  fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_write_ptr;\n\n  fp->_wide_data->_IO_write_base = fp->_wide_data->_IO_write_ptr\n    = fp->_wide_data->_IO_write_end = fp->_wide_data->_IO_read_ptr;\n\n  fp->_flags &= ~_IO_CURRENTLY_PUTTING;\n  return 0;\n}",
    "_IO_free_wbackup_area": "_IO_free_wbackup_area (FILE *fp){\n  if (_IO_in_backup (fp))\n    _IO_switch_to_main_wget_area (fp);  /* Just in case. */\n  free (fp->_wide_data->_IO_save_base);\n  fp->_wide_data->_IO_save_base = NULL;\n  fp->_wide_data->_IO_save_end = NULL;\n  fp->_wide_data->_IO_backup_base = NULL;\n}",
    "_IO_sputbackwc": "_IO_sputbackwc (FILE *fp, wint_t c){\n  wint_t result;\n\n  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base\n      && (wchar_t)fp->_wide_data->_IO_read_ptr[-1] == (wchar_t) c)\n    {\n      fp->_wide_data->_IO_read_ptr--;\n      result = c;\n    }\n  else\n    result = _IO_PBACKFAIL (fp, c);\n\n  if (result != WEOF)\n    fp->_flags &= ~_IO_EOF_SEEN;\n\n  return result;\n}",
    "_IO_sungetwc": "_IO_sungetwc (FILE *fp){\n  wint_t result;\n\n  if (fp->_wide_data->_IO_read_ptr > fp->_wide_data->_IO_read_base)\n    {\n      fp->_wide_data->_IO_read_ptr--;\n      result = *fp->_wide_data->_IO_read_ptr;\n    }\n  else\n    result = _IO_PBACKFAIL (fp, EOF);\n\n  if (result != WEOF)\n    fp->_flags &= ~_IO_EOF_SEEN;\n\n  return result;\n}",
    "_IO_adjust_wcolumn": "_IO_adjust_wcolumn (unsigned start, const wchar_t *line, int count){\n  const wchar_t *ptr = line + count;\n  while (ptr > line)\n    if (*--ptr == L'\\n')\n      return line + count - ptr - 1;\n  return start + count;\n}",
    "_IO_init_wmarker": "_IO_init_wmarker (struct _IO_marker *marker, FILE *fp){\n  marker->_sbuf = fp;\n  if (_IO_in_put_mode (fp))\n    _IO_switch_to_wget_mode (fp);\n  if (_IO_in_backup (fp))\n    marker->_pos = fp->_wide_data->_IO_read_ptr - fp->_wide_data->_IO_read_end;\n  else\n    marker->_pos = (fp->_wide_data->_IO_read_ptr\n\t\t    - fp->_wide_data->_IO_read_base);\n\n  /* Should perhaps sort the chain? */\n  marker->_next = fp->_markers;\n  fp->_markers = marker;\n}",
    "_IO_wmarker_delta": "_IO_wmarker_delta (struct _IO_marker *mark){\n  int cur_pos;\n  if (mark->_sbuf == NULL)\n    return BAD_DELTA;\n  if (_IO_in_backup (mark->_sbuf))\n    cur_pos = (mark->_sbuf->_wide_data->_IO_read_ptr\n\t       - mark->_sbuf->_wide_data->_IO_read_end);\n  else\n    cur_pos = (mark->_sbuf->_wide_data->_IO_read_ptr\n\t       - mark->_sbuf->_wide_data->_IO_read_base);\n  return mark->_pos - cur_pos;\n}",
    "_IO_seekwmark": "_IO_seekwmark (FILE *fp, struct _IO_marker *mark, int delta){\n  if (mark->_sbuf != fp)\n    return EOF;\n if (mark->_pos >= 0)\n    {\n      if (_IO_in_backup (fp))\n\t_IO_switch_to_main_wget_area (fp);\n      fp->_wide_data->_IO_read_ptr = (fp->_wide_data->_IO_read_base\n\t\t\t\t      + mark->_pos);\n    }\n  else\n    {\n      if (!_IO_in_backup (fp))\n\t_IO_switch_to_wbackup_area (fp);\n      fp->_wide_data->_IO_read_ptr = fp->_wide_data->_IO_read_end + mark->_pos;\n    }\n  return 0;\n}",
    "_IO_unsave_wmarkers": "_IO_unsave_wmarkers (FILE *fp){\n  struct _IO_marker *mark = fp->_markers;\n  if (mark)\n    {\n      fp->_markers = 0;\n    }\n\n  if (_IO_have_backup (fp))\n    _IO_free_wbackup_area (fp);\n}",
    "open_wmemstream": "*\nopen_wmemstream (wchar_t **bufloc, size_t *sizeloc){\n  struct locked_FILE\n  {\n    struct _IO_FILE_wmemstream fp;\n#ifdef _IO_MTSAFE_IO\n    _IO_lock_t lock;\n#endif\n    struct _IO_wide_data wd;\n  } *new_f;\n  wchar_t *buf;\n\n  new_f = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));\n  if (new_f == NULL)\n    return NULL;\n#ifdef _IO_MTSAFE_IO\n  new_f->fp._sf._sbf._f._lock = &new_f->lock;\n#endif\n\n  buf = calloc (1, BUFSIZ);\n  if (buf == NULL)\n    {\n      free (new_f);\n      return NULL;\n    }\n  _IO_no_init (&new_f->fp._sf._sbf._f, 0, 0, &new_f->wd, &_IO_wmem_jumps);\n  _IO_fwide (&new_f->fp._sf._sbf._f, 1);\n  _IO_wstr_init_static (&new_f->fp._sf._sbf._f, buf,\n\t\t\tBUFSIZ / sizeof (wchar_t), buf);\n  new_f->fp._sf._sbf._f._flags2 &= ~_IO_FLAGS2_USER_WBUF;\n  new_f->fp._sf._s._allocate_buffer_unused = (_IO_alloc_type) malloc;\n  new_f->fp._sf._s._free_buffer_unused = (_IO_free_type) free;\n\n  new_f->fp.bufloc = bufloc;\n  new_f->fp.sizeloc = sizeloc;\n\n  /* Disable single thread optimization.  BZ 21735.  */\n  new_f->fp._sf._sbf._f._flags2 |= _IO_FLAGS2_NEED_LOCK;\n\n  return (FILE *) &new_f->fp._sf._sbf;\n}",
    "__ctype_get_mb_cur_max": "__ctype_get_mb_cur_max (void){\n  union locale_data_value u;\n\n  u.string = nl_langinfo (_NL_CTYPE_MB_CUR_MAX);\n  return ((size_t []) { 1, 1, 1, 2, 2, 3, 4 })[u.word];\n}",
    "__duplocale": "__duplocale (locale_t dataset){\n  /* This static object is returned for newlocale (LC_ALL_MASK, \"C\").  */\n  if (dataset == _nl_C_locobj_ptr)\n    return dataset;\n\n  /* Handle a special value.  */\n  if (dataset == LC_GLOBAL_LOCALE)\n    dataset = &_nl_global_locale;\n\n  locale_t result;\n  int cnt;\n  size_t names_len = 0;\n\n  /* Calculate the total space we need to store all the names.  */\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    if (cnt != LC_ALL && dataset->__names[cnt] != _nl_C_name)\n      names_len += strlen (dataset->__names[cnt]) + 1;\n\n  /* Get memory.  */\n  result = malloc (sizeof (struct __locale_struct) + names_len);\n\n  if (result != NULL)\n    {\n      char *namep = (char *) (result + 1);\n\n      /* We modify global data (the usage counts).  */\n      __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\tif (cnt != LC_ALL)\n\t  {\n\t    result->__locales[cnt] = dataset->__locales[cnt];\n\t    if (result->__locales[cnt]->usage_count < MAX_USAGE_COUNT)\n\t      ++result->__locales[cnt]->usage_count;\n\n\t    if (dataset->__names[cnt] == _nl_C_name)\n\t      result->__names[cnt] = _nl_C_name;\n\t    else\n\t      {\n\t\tresult->__names[cnt] = namep;\n\t\tnamep = __stpcpy (namep, dataset->__names[cnt]) + 1;\n\t      }\n\t  }\n\n      /* Update the special members.  */\n      result->__ctype_b = dataset->__ctype_b;\n      result->__ctype_tolower = dataset->__ctype_tolower;\n      result->__ctype_toupper = dataset->__ctype_toupper;\n\n      /* It's done.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n    }\n\n  return result;\n}",
    "__freelocale": "__freelocale (locale_t dataset){\n  int cnt;\n\n  /* This static object is returned for newlocale (LC_ALL_MASK, \"C\").  */\n  if (dataset == _nl_C_locobj_ptr)\n    return;\n\n  /* We modify global data (the usage counts).  */\n  __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    if (cnt != LC_ALL && dataset->__locales[cnt]->usage_count != UNDELETABLE)\n      /* We can remove the data.  */\n      _nl_remove_locale (cnt, dataset->__locales[cnt]);\n\n  /* It's done.  */\n  __libc_rwlock_unlock (__libc_setlocale_lock);\n\n  /* Free the locale_t handle itself.  */\n  free (dataset);\n}",
    "__newlocale": "__newlocale (int category_mask, const char *locale, locale_t base){\n  /* Intermediate memory for result.  */\n  const char *newnames[__LC_LAST];\n  struct __locale_struct result;\n  locale_t result_ptr;\n  char *locale_path;\n  size_t locale_path_len;\n  const char *locpath_var;\n  int cnt;\n  size_t names_len;\n\n  /* We treat LC_ALL in the same way as if all bits were set.  */\n  if (category_mask == 1 << LC_ALL)\n    category_mask = (1 << __LC_LAST) - 1 - (1 << LC_ALL);\n\n  /* Sanity check for CATEGORY argument.  */\n  if ((category_mask & ~((1 << __LC_LAST) - 1 - (1 << LC_ALL))) != 0)\n    ERROR_RETURN;\n\n  /* `newlocale' does not support asking for the locale name. */\n  if (locale == NULL)\n    ERROR_RETURN;\n\n  if (base == _nl_C_locobj_ptr)\n    /* We're to modify BASE, returned for a previous call with \"C\".\n       We can't really modify the read-only structure, so instead\n       start over by copying it.  */\n    base = NULL;\n\n  if ((base == NULL || category_mask == (1 << __LC_LAST) - 1 - (1 << LC_ALL))\n      && (category_mask == 0 || !strcmp (locale, \"C\")))\n    /* Asking for the \"C\" locale needn't allocate a new object.  */\n    return _nl_C_locobj_ptr;\n\n  /* Allocate memory for the result.  */\n  if (base != NULL)\n    result = *base;\n  else\n    /* Fill with pointers to C locale data.  */\n    result = _nl_C_locobj;\n\n  /* If no category is to be set we return BASE if available or a\n     dataset using the C locale data.  */\n  if (category_mask == 0)\n    {\n      result_ptr = (locale_t) malloc (sizeof (struct __locale_struct));\n      if (result_ptr == NULL)\n\treturn NULL;\n      *result_ptr = result;\n\n      goto update;\n    }\n\n  /* We perhaps really have to load some data.  So we determine the\n     path in which to look for the data now.  The environment variable\n     `LOCPATH' must only be used when the binary has no SUID or SGID\n     bit set.  If using the default path, we tell _nl_find_locale\n     by passing null and it can check the canonical locale archive.  */\n  locale_path = NULL;\n  locale_path_len = 0;\n\n  locpath_var = getenv (\"LOCPATH\");\n  if (locpath_var != NULL && locpath_var[0] != '\\0')\n    {\n      if (__argz_create_sep (locpath_var, ':',\n\t\t\t     &locale_path, &locale_path_len) != 0)\n\treturn NULL;\n\n      if (__argz_add_sep (&locale_path, &locale_path_len,\n\t\t\t  _nl_default_locale_path, ':') != 0)\n\treturn NULL;\n    }\n\n  /* Get the names for the locales we are interested in.  We either\n     allow a composite name or a single name.  */\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    if (cnt != LC_ALL)\n      newnames[cnt] = locale;\n  if (strchr (locale, ';') != NULL)\n    {\n      /* This is a composite name.  Make a copy and split it up.  */\n      char *np = strdupa (locale);\n      char *cp;\n      int specified_mask = 0;\n\n      while ((cp = strchr (np, '=')) != NULL)\n\t{\n\t  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\t    if (cnt != LC_ALL\n\t\t&& (size_t) (cp - np) == _nl_category_name_sizes[cnt]\n\t\t&& memcmp (np, (_nl_category_names_get (cnt)), cp - np) == 0)\n\t      break;\n\n\t  if (cnt == __LC_LAST)\n\t    /* Bogus category name.  */\n\t    ERROR_RETURN;\n\n\t  /* Found the category this clause sets.  */\n\t  specified_mask |= 1 << cnt;\n\t  newnames[cnt] = ++cp;\n\t  cp = strchr (cp, ';');\n\t  if (cp != NULL)\n\t    {\n\t      /* Examine the next clause.  */\n\t      *cp = '\\0';\n\t      np = cp + 1;\n\t    }\n\t  else\n\t    /* This was the last clause.  We are done.  */\n\t    break;\n\t}\n\n      if (category_mask &~ specified_mask)\n\t/* The composite name did not specify all categories we need.  */\n\tERROR_RETURN;\n    }\n\n  /* Protect global data.  */\n  __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n  /* Now process all categories we are interested in.  */\n  names_len = 0;\n  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n    {\n      if ((category_mask & 1 << cnt) != 0)\n\t{\n\t  result.__locales[cnt] = _nl_find_locale (locale_path,\n\t\t\t\t\t\t   locale_path_len,\n\t\t\t\t\t\t   cnt, &newnames[cnt]);\n\t  if (result.__locales[cnt] == NULL)\n\t    {\n\t    free_cnt_data_and_exit:\n\t      while (cnt-- > 0)\n\t\tif (((category_mask & 1 << cnt) != 0)\n\t\t    && result.__locales[cnt]->usage_count != UNDELETABLE)\n\t\t  /* We can remove the data.  */\n\t\t  _nl_remove_locale (cnt, result.__locales[cnt]);\n\n              /* Critical section left.  */\n              __libc_rwlock_unlock (__libc_setlocale_lock);\n\t      return NULL;\n\t    }\n\n\t  if (newnames[cnt] != _nl_C_name)\n\t    names_len += strlen (newnames[cnt]) + 1;\n\t}\n      else if (cnt != LC_ALL && result.__names[cnt] != _nl_C_name)\n\t/* Tally up the unchanged names from BASE as well.  */\n\tnames_len += strlen (result.__names[cnt]) + 1;\n    }\n\n  /* We successfully loaded all required data.  Allocate a new structure.\n     We can't just reuse the BASE pointer, because the name strings are\n     changing and we need the old name string area intact so we can copy\n     out of it into the new one without overlap problems should some\n     category's name be getting longer.  */\n  result_ptr = malloc (sizeof (struct __locale_struct) + names_len);\n  if (result_ptr == NULL)\n    {\n      cnt = __LC_LAST;\n      goto free_cnt_data_and_exit;\n    }\n\n  if (base == NULL)\n    {\n      /* Fill in this new structure from scratch.  */\n\n      char *namep = (char *) (result_ptr + 1);\n\n      /* Install copied new names in the new structure's __names array.\n\t If resolved to \"C\", that is already in RESULT.__names to start.  */\n      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\tif ((category_mask & 1 << cnt) != 0 && newnames[cnt] != _nl_C_name)\n\t  {\n\t    result.__names[cnt] = namep;\n\t    namep = __stpcpy (namep, newnames[cnt]) + 1;\n\t  }\n\n      *result_ptr = result;\n    }\n  else\n    {\n      /* We modify the base structure.  */\n\n      char *namep = (char *) (result_ptr + 1);\n\n      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\tif ((category_mask & 1 << cnt) != 0)\n\t  {\n\t    if (base->__locales[cnt]->usage_count != UNDELETABLE)\n\t      /* We can remove the old data.  */\n\t      _nl_remove_locale (cnt, base->__locales[cnt]);\n\t    result_ptr->__locales[cnt] = result.__locales[cnt];\n\n\t    if (newnames[cnt] == _nl_C_name)\n\t      result_ptr->__names[cnt] = _nl_C_name;\n\t    else\n\t      {\n\t\tresult_ptr->__names[cnt] = namep;\n\t\tnamep = __stpcpy (namep, newnames[cnt]) + 1;\n\t      }\n\t  }\n\telse if (cnt != LC_ALL)\n\t  {\n\t    /* The RESULT members point into the old BASE structure.  */\n\t    result_ptr->__locales[cnt] = result.__locales[cnt];\n\t    if (result.__names[cnt] == _nl_C_name)\n\t      result_ptr->__names[cnt] = _nl_C_name;\n\t    else\n\t      {\n\t\tresult_ptr->__names[cnt] = namep;\n\t\tnamep = __stpcpy (namep, result.__names[cnt]) + 1;\n\t      }\n\t  }\n\n      free (base);\n    }\n\n  /* Critical section left.  */\n  __libc_rwlock_unlock (__libc_setlocale_lock);\n\n  /* Update the special members.  */\n update:\n  {\n    union locale_data_value *ctypes = result_ptr->__locales[LC_CTYPE]->values;\n    result_ptr->__ctype_b = (const unsigned short int *)\n      ctypes[_NL_ITEM_INDEX (_NL_CTYPE_CLASS)].string + 128;\n    result_ptr->__ctype_tolower = (const int *)\n      ctypes[_NL_ITEM_INDEX (_NL_CTYPE_TOLOWER)].string + 128;\n    result_ptr->__ctype_toupper = (const int *)\n      ctypes[_NL_ITEM_INDEX (_NL_CTYPE_TOUPPER)].string + 128;\n  }\n\n  return result_ptr;\n}",
    "nl_langinfo": "*\nnl_langinfo (nl_item item){\n  return __nl_langinfo_l (item, _NL_CURRENT_LOCALE);\n}",
    "__nl_langinfo_l": "*\n__nl_langinfo_l (nl_item item, locale_t l){\n  int category = _NL_ITEM_CATEGORY (item);\n  unsigned int index = _NL_ITEM_INDEX (item);\n  const struct __locale_data *data;\n\n  if (category < 0 || category == LC_ALL || category >= __LC_LAST)\n    /* Bogus category: bogus item.  */\n    return (char *) \"\";\n\n  /* Special case value for NL_LOCALE_NAME (category).\n     This is not a real item index in the string table.  */\n  if (index == _NL_ITEM_INDEX (_NL_LOCALE_NAME (category)))\n    return (char *) l->__names[category];\n\n#if defined NL_CURRENT_INDIRECT\n  /* Make direct reference to every _nl_current_CATEGORY symbol,\n     since we know only at runtime which categories are used.  */\n  switch (category)\n    {\n# define DEFINE_CATEGORY(category, category_name, items, a) \\\n      case category: data = *_nl_current_##category; break;\n# include \"categories.def\"\n# undef DEFINE_CATEGORY\n    default:                   /* Should be impossible.  */\n      abort();\n    }\n#else\n  data = l->__locales[category];\n#endif\n\n  if (index >= data->nstrings)\n    /* Bogus index for this category: bogus item.  */\n    return (char *) \"\";\n\n  /* Return the string for the specified item.  */\n  return (char *) data->values[index].string;\n}",
    "setlocale": "*\nsetlocale (int category, const char *locale){\n  char *locale_path;\n  size_t locale_path_len;\n  const char *locpath_var;\n  char *composite;\n\n  /* Sanity check for CATEGORY argument.  */\n  if (__builtin_expect (category, 0) < 0\n      || __builtin_expect (category, 0) >= __LC_LAST)\n    ERROR_RETURN;\n\n  /* Does user want name of current locale?  */\n  if (locale == NULL)\n    return (char *) _nl_global_locale.__names[category];\n\n  /* Protect global data.  */\n  __libc_rwlock_wrlock (__libc_setlocale_lock);\n\n  if (strcmp (locale, _nl_global_locale.__names[category]) == 0)\n    {\n      /* Changing to the same thing.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n\n      return (char *) _nl_global_locale.__names[category];\n    }\n\n  /* We perhaps really have to load some data.  So we determine the\n     path in which to look for the data now.  The environment variable\n     `LOCPATH' must only be used when the binary has no SUID or SGID\n     bit set.  If using the default path, we tell _nl_find_locale\n     by passing null and it can check the canonical locale archive.  */\n  locale_path = NULL;\n  locale_path_len = 0;\n\n  locpath_var = getenv (\"LOCPATH\");\n  if (locpath_var != NULL && locpath_var[0] != '\\0')\n    {\n      if (__argz_create_sep (locpath_var, ':',\n\t\t\t     &locale_path, &locale_path_len) != 0\n\t  || __argz_add_sep (&locale_path, &locale_path_len,\n\t\t\t     _nl_default_locale_path, ':') != 0)\n\t{\n\t  __libc_rwlock_unlock (__libc_setlocale_lock);\n\t  return NULL;\n\t}\n    }\n\n  if (category == LC_ALL)\n    {\n      /* The user wants to set all categories.  The desired locales\n\t for the individual categories can be selected by using a\n\t composite locale name.  This is a semi-colon separated list\n\t of entries of the form `CATEGORY=VALUE'.  */\n      const char *newnames[__LC_LAST];\n      struct __locale_data *newdata[__LC_LAST];\n      /* Copy of the locale argument, for in-place splitting.  */\n      char *locale_copy = NULL;\n\n      /* Set all name pointers to the argument name.  */\n      for (category = 0; category < __LC_LAST; ++category)\n\tif (category != LC_ALL)\n\t  newnames[category] = (char *) locale;\n\n      if (__glibc_unlikely (strchr (locale, ';') != NULL))\n\t{\n\t  /* This is a composite name.  Make a copy and split it up.  */\n\t  locale_copy = __strdup (locale);\n\t  if (__glibc_unlikely (locale_copy == NULL))\n\t    {\n\t      __libc_rwlock_unlock (__libc_setlocale_lock);\n\t      return NULL;\n\t    }\n\t  char *np = locale_copy;\n\t  char *cp;\n\t  int cnt;\n\n\t  while ((cp = strchr (np, '=')) != NULL)\n\t    {\n\t      for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\t\tif (cnt != LC_ALL\n\t\t    && (size_t) (cp - np) == _nl_category_name_sizes[cnt]\n\t\t    && (memcmp (np, (_nl_category_names_get (cnt)), cp - np)\n\t\t\t== 0))\n\t\t  break;\n\n\t      if (cnt == __LC_LAST)\n\t\t{\n\t\terror_return:\n\t\t  __libc_rwlock_unlock (__libc_setlocale_lock);\n\t\t  free (locale_copy);\n\n\t\t  /* Bogus category name.  */\n\t\t  ERROR_RETURN;\n\t\t}\n\n\t      /* Found the category this clause sets.  */\n\t      newnames[cnt] = ++cp;\n\t      cp = strchr (cp, ';');\n\t      if (cp != NULL)\n\t\t{\n\t\t  /* Examine the next clause.  */\n\t\t  *cp = '\\0';\n\t\t  np = cp + 1;\n\t\t}\n\t      else\n\t\t/* This was the last clause.  We are done.  */\n\t\tbreak;\n\t    }\n\n\t  for (cnt = 0; cnt < __LC_LAST; ++cnt)\n\t    if (cnt != LC_ALL && newnames[cnt] == locale)\n\t      /* The composite name did not specify all categories.  */\n\t      goto error_return;\n\t}\n\n      /* Load the new data for each category.  */\n      while (category-- > 0)\n\tif (category != LC_ALL)\n\t  {\n\t    newdata[category] = _nl_find_locale (locale_path, locale_path_len,\n\t\t\t\t\t\t category,\n\t\t\t\t\t\t &newnames[category]);\n\n\t    if (newdata[category] == NULL)\n\t      {\n#ifdef NL_CURRENT_INDIRECT\n\t\tif (newnames[category] == _nl_C_name)\n\t\t  /* Null because it's the weak value of _nl_C_LC_FOO.  */\n\t\t  continue;\n#endif\n\t\tbreak;\n\t      }\n\n\t    /* We must not simply free a global locale since we have\n\t       no control over the usage.  So we mark it as\n\t       un-deletable.  And yes, the 'if' is needed, the data\n\t       might be in read-only memory.  */\n\t    if (newdata[category]->usage_count != UNDELETABLE)\n\t      newdata[category]->usage_count = UNDELETABLE;\n\n\t    /* Make a copy of locale name.  */\n\t    if (newnames[category] != _nl_C_name)\n\t      {\n\t\tif (strcmp (newnames[category],\n\t\t\t    _nl_global_locale.__names[category]) == 0)\n\t\t  newnames[category] = _nl_global_locale.__names[category];\n\t\telse\n\t\t  {\n\t\t    newnames[category] = __strdup (newnames[category]);\n\t\t    if (newnames[category] == NULL)\n\t\t      break;\n\t\t  }\n\t      }\n\t  }\n\n      /* Create new composite name.  */\n      composite = (category >= 0\n\t\t   ? NULL : new_composite_name (LC_ALL, newnames));\n      if (composite != NULL)\n\t{\n\t  /* Now we have loaded all the new data.  Put it in place.  */\n\t  for (category = 0; category < __LC_LAST; ++category)\n\t    if (category != LC_ALL)\n\t      {\n\t\tsetdata (category, newdata[category]);\n\t\tsetname (category, newnames[category]);\n\t      }\n\t  setname (LC_ALL, composite);\n\n\t  /* We successfully loaded a new locale.  Let the message catalog\n\t     functions know about this.  */\n\t  ++_nl_msg_cat_cntr;\n\t}\n      else\n\tfor (++category; category < __LC_LAST; ++category)\n\t  if (category != LC_ALL && newnames[category] != _nl_C_name\n\t      && newnames[category] != _nl_global_locale.__names[category])\n\t    free ((char *) newnames[category]);\n\n      /* Critical section left.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n\n      /* Free the resources.  */\n      free (locale_path);\n      free (locale_copy);\n\n      return composite;\n    }\n  else\n    {\n      struct __locale_data *newdata = NULL;\n      const char *newname[1] = { locale };\n\n      if (CATEGORY_USED (category))\n\t{\n\t  /* Only actually load the data if anything will use it.  */\n\t  newdata = _nl_find_locale (locale_path, locale_path_len, category,\n\t\t\t\t     &newname[0]);\n\t  if (newdata == NULL)\n\t    goto abort_single;\n\n\t  /* We must not simply free a global locale since we have no\n\t     control over the usage.  So we mark it as un-deletable.\n\n\t     Note: do not remove the `if', it's necessary to cope with\n\t     the builtin locale data.  */\n\t  if (newdata->usage_count != UNDELETABLE)\n\t    newdata->usage_count = UNDELETABLE;\n\t}\n\n      /* Make a copy of locale name.  */\n      if (newname[0] != _nl_C_name)\n\t{\n\t  newname[0] = __strdup (newname[0]);\n\t  if (newname[0] == NULL)\n\t    goto abort_single;\n\t}\n\n      /* Create new composite name.  */\n      composite = new_composite_name (category, newname);\n      if (composite == NULL)\n\t{\n\t  if (newname[0] != _nl_C_name)\n\t    free ((char *) newname[0]);\n\n\t  /* Say that we don't have any data loaded.  */\n\tabort_single:\n\t  newname[0] = NULL;\n\t}\n      else\n\t{\n\t  if (CATEGORY_USED (category))\n\t    setdata (category, newdata);\n\n\t  setname (category, newname[0]);\n\t  setname (LC_ALL, composite);\n\n\t  /* We successfully loaded a new locale.  Let the message catalog\n\t     functions know about this.  */\n\t  ++_nl_msg_cat_cntr;\n\t}\n\n      /* Critical section left.  */\n      __libc_rwlock_unlock (__libc_setlocale_lock);\n\n      /* Free the resources (the locale path variable.  */\n      free (locale_path);\n\n      return (char *) newname[0];\n    }\n}",
    "__uselocale": "__uselocale (locale_t newloc){\n  locale_t oldloc = _NL_CURRENT_LOCALE;\n\n  if (newloc != NULL)\n    {\n      const locale_t locobj\n\t= newloc == LC_GLOBAL_LOCALE ? &_nl_global_locale : newloc;\n      __libc_tsd_set (locale_t, LOCALE, locobj);\n\n#ifdef NL_CURRENT_INDIRECT\n      /* Now we must update all the per-category thread-local variables to\n\t point into the new current locale for this thread.  The magic\n\t symbols _nl_current_LC_FOO_used are defined to meaningless values\n\t if _nl_current_LC_FOO was linked in.  By using weak references to\n\t both symbols and testing the address of _nl_current_LC_FOO_used,\n\t we can avoid accessing the _nl_current_LC_FOO thread-local\n\t variable at all when no code referring to it was linked in.  We\n\t need the special bogus symbol because while TLS symbols can be\n\t weak, there is no reasonable way to test for the default-zero\n\t value as with a heap symbol (taking the address would just use\n\t some bogus offset from our thread pointer).  */\n\n# define DEFINE_CATEGORY(category, category_name, items, a) \\\n      {\t\t\t\t\t\t\t\t\t      \\\n\textern char _nl_current_##category##_used;\t\t\t      \\\n\tweak_extern (_nl_current_##category##_used)\t\t\t      \\\n\tweak_extern (_nl_current_##category)\t\t\t\t      \\\n\tif (&_nl_current_##category##_used != 0)\t\t\t      \\\n\t  _nl_current_##category = &locobj->__locales[category];\t      \\\n      }\n# include \"categories.def\"\n# undef\tDEFINE_CATEGORY\n#endif\n\n      /* Update the special tsd cache of some locale data.  */\n      __libc_tsd_set (const uint16_t *, CTYPE_B, (void *) locobj->__ctype_b);\n      __libc_tsd_set (const int32_t *, CTYPE_TOLOWER,\n\t\t      (void *) locobj->__ctype_tolower);\n      __libc_tsd_set (const int32_t *, CTYPE_TOUPPER,\n\t\t      (void *) locobj->__ctype_toupper);\n    }\n\n  return oldloc == &_nl_global_locale ? LC_GLOBAL_LOCALE : oldloc;\n}",
    "endutxent": "endutxent (void){\n  __endutent ();\n}",
    "getlogin": "*\ngetlogin (void){\n  int res = __getlogin_r_loginuid (name, sizeof (name));\n  if (res >= 0)\n    return res == 0 ? name : NULL;\n\n  return getlogin_fd0 ();\n}",
    "__getlogin_r_chk": "__getlogin_r_chk (char *buf, size_t buflen, size_t nreal){\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return getlogin_r (buf, buflen);\n}",
    "getutmp": "getutmp (const struct utmpx *utmpx, struct utmp *utmp){\n  assert (sizeof (struct utmp) == sizeof (struct utmpx));\n  memcpy (utmp, utmpx, sizeof (struct utmp));\n}",
    "getutmpx": "getutmpx (const struct utmp *utmp, struct utmpx *utmpx){\n  memset (utmpx, 0, sizeof (struct utmpx));\n  utmpx->ut_type = utmp->ut_type;\n  utmpx->ut_pid = utmp->ut_pid;\n  memcpy (utmpx->ut_line, utmp->ut_line, sizeof (utmp->ut_line));\n  memcpy (utmpx->ut_user, utmp->ut_user, sizeof (utmp->ut_user));\n  memcpy (utmpx->ut_id, utmp->ut_id, sizeof (utmp->ut_id));\n  memcpy (utmpx->ut_host, utmp->ut_host, sizeof (utmp->ut_host));\n  utmpx->ut_tv = utmp->ut_tv;\n}",
    "getutxent": "*\ngetutxent (void){\n  return (struct utmpx *) __getutent ();\n}",
    "getutxid": "*\ngetutxid (const struct utmpx *id){\n  return (struct utmpx *) __getutid ((const struct utmp *) id);\n}",
    "getutxline": "*\ngetutxline (const struct utmpx *line){\n  return (struct utmpx *) __getutline ((const struct utmp *) line);\n}",
    "__ptsname_r_chk": "__ptsname_r_chk (int fd, char *buf, size_t buflen, size_t nreal){\n  if (buflen > nreal)\n    __chk_fail ();\n\n  return __ptsname_r (fd, buf, buflen);\n}",
    "pututxline": "*\npututxline (const struct utmpx *utmpx){\n  return (struct utmpx *) __pututline ((const struct utmp *) utmpx);\n}",
    "setlogin": "setlogin (const char *name){\n  error_t err;\n  if (err = __USEPORT (PROC, __proc_setlogin (port, name)))\n    return __hurd_fail (err);\n  return 0;\n}",
    "setutxent": "setutxent (void){\n  return __setutent ();\n}",
    "updwtmpx": "updwtmpx (const char *wtmpx_file, const struct utmpx *utmpx){\n  __updwtmp (wtmpx_file, (const struct utmp *) utmpx);\n}",
    "utmpxname": "utmpxname (const char *file){\n  return __utmpname (file);\n}",
    "__libc_alloc_buffer_alloc_array": "*\n__libc_alloc_buffer_alloc_array (struct alloc_buffer *buf, size_t element_size,\n                                 size_t align, size_t count){\n  uintptr_t current = buf->__alloc_buffer_current;\n  /* The caller asserts that align is a power of two.  */\n  uintptr_t aligned = ALIGN_UP (current, align);\n  size_t size;\n  bool overflow = __builtin_mul_overflow (element_size, count, &size);\n  uintptr_t new_current = aligned + size;\n  if (!overflow                /* Multiplication did not overflow.  */\n      && aligned >= current    /* No overflow in align step.  */\n      && new_current >= size   /* No overflow in size computation.  */\n      && new_current <= buf->__alloc_buffer_end) /* Room in buffer.  */\n    {\n      buf->__alloc_buffer_current = new_current;\n      return (void *) aligned;\n    }\n  else\n    {\n      alloc_buffer_mark_failed (buf);\n      return NULL;\n    }\n}",
    "__libc_alloc_buffer_allocate": "__libc_alloc_buffer_allocate (size_t size, void **pptr){\n  *pptr = malloc (size);\n  if (*pptr == NULL)\n    return (struct alloc_buffer)\n      {\n        .__alloc_buffer_current = __ALLOC_BUFFER_INVALID_POINTER,\n        .__alloc_buffer_end = __ALLOC_BUFFER_INVALID_POINTER\n      };\n  else\n    return alloc_buffer_create (*pptr, size);\n}",
    "__libc_alloc_buffer_copy_bytes": "__libc_alloc_buffer_copy_bytes (struct alloc_buffer buf,\n                                const void *src, size_t len){\n  void *ptr = alloc_buffer_alloc_bytes (&buf, len);\n  if (ptr != NULL)\n    memcpy (ptr, src, len);\n  return buf;\n}",
    "__libc_alloc_buffer_copy_string": "__libc_alloc_buffer_copy_string (struct alloc_buffer buf, const char *src){\n  return __libc_alloc_buffer_copy_bytes (buf, src, strlen (src) + 1);\n}",
    "__libc_alloc_buffer_create_failure": "__libc_alloc_buffer_create_failure (void *start, size_t size){\n  char buf[200];\n  __snprintf (buf, sizeof (buf), \"Fatal glibc error: \"\n              \"invalid allocation buffer of size %zu\\n\",\n              size);\n  __libc_fatal (buf);\n}",
    "__libc_dynarray_at_failure": "__libc_dynarray_at_failure (size_t size, size_t index){\n#ifdef _LIBC\n  char buf[200];\n  __snprintf (buf, sizeof (buf), \"Fatal glibc error: \"\n              \"array index %zu not less than array length %zu\\n\",\n              index, size);\n __libc_fatal (buf);\n#else\n abort ();\n#endif\n}",
    "__libc_dynarray_emplace_enlarge": "__libc_dynarray_emplace_enlarge (struct dynarray_header *list,\n                                 void *scratch, size_t element_size){\n  size_t new_allocated;\n  if (list->allocated == 0)\n    {\n      /* No scratch buffer provided.  Choose a reasonable default\n         size.  */\n      if (element_size < 4)\n        new_allocated = 16;\n      else if (element_size < 8)\n        new_allocated = 8;\n      else\n        new_allocated = 4;\n    }\n  else\n    /* Increase the allocated size, using an exponential growth\n       policy.  */\n    {\n      new_allocated = list->allocated + list->allocated / 2 + 1;\n      if (new_allocated <= list->allocated)\n        {\n          /* Overflow.  */\n          __set_errno (ENOMEM);\n          return false;\n        }\n    }\n\n  size_t new_size;\n  if (INT_MULTIPLY_WRAPV (new_allocated, element_size, &new_size))\n    return false;\n  void *new_array;\n  if (list->array == scratch)\n    {\n      /* The previous array was not heap-allocated.  */\n      new_array = malloc (new_size);\n      if (new_array != NULL && list->array != NULL)\n        memcpy (new_array, list->array, list->used * element_size);\n    }\n  else\n    new_array = realloc (list->array, new_size);\n  if (new_array == NULL)\n    return false;\n  list->array = new_array;\n  list->allocated = new_allocated;\n  return true;\n}",
    "__libc_dynarray_finalize": "__libc_dynarray_finalize (struct dynarray_header *list,\n                          void *scratch, size_t element_size,\n                          struct dynarray_finalize_result *result){\n  if (__dynarray_error (list))\n    /* The caller will reported the deferred error.  */\n    return false;\n\n  size_t used = list->used;\n\n  /* Empty list.  */\n  if (used == 0)\n    {\n      /* An empty list could still be backed by a heap-allocated\n         array.  Free it if necessary.  */\n      if (list->array != scratch)\n        free (list->array);\n      *result = (struct dynarray_finalize_result) { NULL, 0 };\n      return true;\n    }\n\n  size_t allocation_size = used * element_size;\n  void *heap_array = malloc (allocation_size);\n  if (heap_array != NULL)\n    {\n      /* The new array takes ownership of the strings.  */\n      if (list->array != NULL)\n        memcpy (heap_array, list->array, allocation_size);\n      if (list->array != scratch)\n        free (list->array);\n      *result = (struct dynarray_finalize_result)\n        { .array = heap_array, .length = used };\n      return true;\n    }\n  else\n    /* The caller will perform the freeing operation.  */\n    return false;\n}",
    "__libc_dynarray_resize": "__libc_dynarray_resize (struct dynarray_header *list, size_t size,\n                        void *scratch, size_t element_size){\n  /* The existing allocation provides sufficient room.  */\n  if (size <= list->allocated)\n    {\n      list->used = size;\n      return true;\n    }\n\n  /* Otherwise, use size as the new allocation size.  The caller is\n     expected to provide the final size of the array, so there is no\n     over-allocation here.  */\n\n  size_t new_size_bytes;\n  if (INT_MULTIPLY_WRAPV (size, element_size, &new_size_bytes))\n    {\n      /* Overflow.  */\n      __set_errno (ENOMEM);\n      return false;\n    }\n  void *new_array;\n  if (list->array == scratch)\n    {\n      /* The previous array was not heap-allocated.  */\n      new_array = malloc (new_size_bytes);\n      if (new_array != NULL && list->array != NULL)\n        memcpy (new_array, list->array, list->used * element_size);\n    }\n  else\n    new_array = realloc (list->array, new_size_bytes);\n  if (new_array == NULL)\n    return false;\n  list->array = new_array;\n  list->allocated = size;\n  list->used = size;\n  return true;\n}",
    "__libc_dynarray_resize_clear": "__libc_dynarray_resize_clear (struct dynarray_header *list, size_t size,\n                              void *scratch, size_t element_size){\n  size_t old_size = list->used;\n  if (!__libc_dynarray_resize (list, size, scratch, element_size))\n    return false;\n  /* __libc_dynarray_resize already checked for overflow.  */\n  char *array = list->array;\n  memset (array + (old_size * element_size), 0,\n          (size - old_size) * element_size);\n  return true;\n}",
    "malloc_usable_size": "malloc_usable_size (void *mem){\n  if (mem == NULL)\n    return 0;\n\n  if (__is_malloc_debug_enabled (MALLOC_MCHECK_HOOK))\n    return mcheck_usable_size (mem);\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return malloc_check_get_size (mem);\n\n  mchunkptr p = mem2chunk (mem);\n  if (DUMPED_MAIN_ARENA_CHUNK (p))\n    return chunksize (p) - SIZE_SZ;\n\n  return musable (mem);\n}",
    "malloc_info": "malloc_info (int options, FILE *fp){\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return __malloc_info (options, fp);\n\n  int (*LIBC_SYMBOL (malloc_info)) (int, FILE *) = LOAD_SYM (malloc_info);\n  if (LIBC_SYMBOL (malloc_info) == NULL)\n    return -1;\n\n  return LIBC_SYMBOL (malloc_info) (options, fp);\n}",
    "mallopt": "mallopt (int param_number, int value){\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return __libc_mallopt (param_number, value);\n\n  int (*LIBC_SYMBOL (mallopt)) (int, int) = LOAD_SYM (mallopt);\n  if (LIBC_SYMBOL (mallopt) == NULL)\n    return 0;\n\n  return LIBC_SYMBOL (mallopt) (param_number, value);\n}",
    "malloc_stats": "malloc_stats (void){\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return __malloc_stats ();\n\n  void (*LIBC_SYMBOL (malloc_stats)) (void) = LOAD_SYM (malloc_stats);\n  if (LIBC_SYMBOL (malloc_stats) == NULL)\n    return;\n\n  LIBC_SYMBOL (malloc_stats) ();\n}",
    "mallinfo2": "mallinfo2 (void){\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return __libc_mallinfo2 ();\n\n  struct mallinfo2 (*LIBC_SYMBOL (mallinfo2)) (void) = LOAD_SYM (mallinfo2);\n  if (LIBC_SYMBOL (mallinfo2) == NULL)\n    {\n      struct mallinfo2 ret = {0};\n      return ret;\n    }\n\n  return LIBC_SYMBOL (mallinfo2) ();\n}",
    "mallinfo": "mallinfo (void){\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return __libc_mallinfo ();\n\n  struct mallinfo (*LIBC_SYMBOL (mallinfo)) (void) = LOAD_SYM (mallinfo);\n  if (LIBC_SYMBOL (mallinfo) == NULL)\n    {\n      struct mallinfo ret = {0};\n      return ret;\n    }\n\n  return LIBC_SYMBOL (mallinfo) ();\n}",
    "malloc_trim": "malloc_trim (size_t s){\n  if (__is_malloc_debug_enabled (MALLOC_CHECK_HOOK))\n    return __malloc_trim (s);\n\n  int (*LIBC_SYMBOL (malloc_trim)) (size_t) = LOAD_SYM (malloc_trim);\n  if (LIBC_SYMBOL (malloc_trim) == NULL)\n    return 0;\n\n  return LIBC_SYMBOL (malloc_trim) (s);\n}",
    "__libc_malloc": "*\n__libc_malloc (size_t bytes){\n  mstate ar_ptr;\n  void *victim;\n\n  _Static_assert (PTRDIFF_MAX <= SIZE_MAX / 2,\n                  \"PTRDIFF_MAX is not more than half of SIZE_MAX\");\n\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n#if USE_TCACHE\n  /* int_free also calls request2size, be careful to not pad twice.  */\n  size_t tbytes = checked_request2size (bytes);\n  if (tbytes == 0)\n    {\n      __set_errno (ENOMEM);\n      return NULL;\n    }\n  size_t tc_idx = csize2tidx (tbytes);\n\n  MAYBE_INIT_TCACHE ();\n\n  DIAG_PUSH_NEEDS_COMMENT;\n  if (tc_idx < mp_.tcache_bins\n      && tcache != NULL\n      && tcache->counts[tc_idx] > 0)\n    {\n      victim = tcache_get (tc_idx);\n      return tag_new_usable (victim);\n    }\n  DIAG_POP_NEEDS_COMMENT;\n#endif\n\n  if (SINGLE_THREAD_P)\n    {\n      victim = tag_new_usable (_int_malloc (&main_arena, bytes));\n      assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||\n\t      &main_arena == arena_for_chunk (mem2chunk (victim)));\n      return victim;\n    }\n\n  arena_get (ar_ptr, bytes);\n\n  victim = _int_malloc (ar_ptr, bytes);\n  /* Retry with another arena only if we were able to find a usable arena\n     before.  */\n  if (!victim && ar_ptr != NULL)\n    {\n      LIBC_PROBE (memory_malloc_retry, 1, bytes);\n      ar_ptr = arena_get_retry (ar_ptr, bytes);\n      victim = _int_malloc (ar_ptr, bytes);\n    }\n\n  if (ar_ptr != NULL)\n    __libc_lock_unlock (ar_ptr->mutex);\n\n  victim = tag_new_usable (victim);\n\n  assert (!victim || chunk_is_mmapped (mem2chunk (victim)) ||\n          ar_ptr == arena_for_chunk (mem2chunk (victim)));\n  return victim;\n}",
    "__libc_free": "__libc_free (void *mem){\n  mstate ar_ptr;\n  mchunkptr p;                          /* chunk corresponding to mem */\n\n  if (mem == 0)                              /* free(0) has no effect */\n    return;\n\n  /* Quickly check that the freed pointer matches the tag for the memory.\n     This gives a useful double-free detection.  */\n  if (__glibc_unlikely (mtag_enabled))\n    *(volatile char *)mem;\n\n  int err = errno;\n\n  p = mem2chunk (mem);\n\n  if (chunk_is_mmapped (p))                       /* release mmapped memory. */\n    {\n      /* See if the dynamic brk/mmap threshold needs adjusting.\n\t Dumped fake mmapped chunks do not affect the threshold.  */\n      if (!mp_.no_dyn_threshold\n          && chunksize_nomask (p) > mp_.mmap_threshold\n          && chunksize_nomask (p) <= DEFAULT_MMAP_THRESHOLD_MAX)\n        {\n          mp_.mmap_threshold = chunksize (p);\n          mp_.trim_threshold = 2 * mp_.mmap_threshold;\n          LIBC_PROBE (memory_mallopt_free_dyn_thresholds, 2,\n                      mp_.mmap_threshold, mp_.trim_threshold);\n        }\n      munmap_chunk (p);\n    }\n  else\n    {\n      MAYBE_INIT_TCACHE ();\n\n      /* Mark the chunk as belonging to the library again.  */\n      (void)tag_region (chunk2mem (p), memsize (p));\n\n      ar_ptr = arena_for_chunk (p);\n      _int_free (ar_ptr, p, 0);\n    }\n\n  __set_errno (err);\n}",
    "__libc_realloc": "*\n__libc_realloc (void *oldmem, size_t bytes){\n  mstate ar_ptr;\n  INTERNAL_SIZE_T nb;         /* padded request size */\n\n  void *newp;             /* chunk to return */\n\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n\n#if REALLOC_ZERO_BYTES_FREES\n  if (bytes == 0 && oldmem != NULL)\n    {\n      __libc_free (oldmem); return 0;\n    }\n#endif\n\n  /* realloc of null is supposed to be same as malloc */\n  if (oldmem == 0)\n    return __libc_malloc (bytes);\n\n  /* Perform a quick check to ensure that the pointer's tag matches the\n     memory's tag.  */\n  if (__glibc_unlikely (mtag_enabled))\n    *(volatile char*) oldmem;\n\n  /* chunk corresponding to oldmem */\n  const mchunkptr oldp = mem2chunk (oldmem);\n\n  /* Return the chunk as is if the request grows within usable bytes, typically\n     into the alignment padding.  We want to avoid reusing the block for\n     shrinkages because it ends up unnecessarily fragmenting the address space.\n     This is also why the heuristic misses alignment padding for THP for\n     now.  */\n  size_t usable = musable (oldmem);\n  if (bytes <= usable)\n    {\n      size_t difference = usable - bytes;\n      if ((unsigned long) difference < 2 * sizeof (INTERNAL_SIZE_T)\n\t  || (chunk_is_mmapped (oldp) && difference <= GLRO (dl_pagesize)))\n\treturn oldmem;\n    }\n\n  /* its size */\n  const INTERNAL_SIZE_T oldsize = chunksize (oldp);\n\n  if (chunk_is_mmapped (oldp))\n    ar_ptr = NULL;\n  else\n    {\n      MAYBE_INIT_TCACHE ();\n      ar_ptr = arena_for_chunk (oldp);\n    }\n\n  /* Little security check which won't hurt performance: the allocator\n     never wraps around at the end of the address space.  Therefore\n     we can exclude some size values which might appear here by\n     accident or by \"design\" from some intruder.  */\n  if ((__builtin_expect ((uintptr_t) oldp > (uintptr_t) -oldsize, 0)\n       || __builtin_expect (misaligned_chunk (oldp), 0)))\n      malloc_printerr (\"realloc(): invalid pointer\");\n\n  nb = checked_request2size (bytes);\n  if (nb == 0)\n    {\n      __set_errno (ENOMEM);\n      return NULL;\n    }\n\n  if (chunk_is_mmapped (oldp))\n    {\n      void *newmem;\n\n#if HAVE_MREMAP\n      newp = mremap_chunk (oldp, nb);\n      if (newp)\n\t{\n\t  void *newmem = chunk2mem_tag (newp);\n\t  /* Give the new block a different tag.  This helps to ensure\n\t     that stale handles to the previous mapping are not\n\t     reused.  There's a performance hit for both us and the\n\t     caller for doing this, so we might want to\n\t     reconsider.  */\n\t  return tag_new_usable (newmem);\n\t}\n#endif\n      /* Note the extra SIZE_SZ overhead. */\n      if (oldsize - SIZE_SZ >= nb)\n        return oldmem;                         /* do nothing */\n\n      /* Must alloc, copy, free. */\n      newmem = __libc_malloc (bytes);\n      if (newmem == 0)\n        return 0;              /* propagate failure */\n\n      memcpy (newmem, oldmem, oldsize - CHUNK_HDR_SZ);\n      munmap_chunk (oldp);\n      return newmem;\n    }\n\n  if (SINGLE_THREAD_P)\n    {\n      newp = _int_realloc (ar_ptr, oldp, oldsize, nb);\n      assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||\n\t      ar_ptr == arena_for_chunk (mem2chunk (newp)));\n\n      return newp;\n    }\n\n  __libc_lock_lock (ar_ptr->mutex);\n\n  newp = _int_realloc (ar_ptr, oldp, oldsize, nb);\n\n  __libc_lock_unlock (ar_ptr->mutex);\n  assert (!newp || chunk_is_mmapped (mem2chunk (newp)) ||\n          ar_ptr == arena_for_chunk (mem2chunk (newp)));\n\n  if (newp == NULL)\n    {\n      /* Try harder to allocate memory in other arenas.  */\n      LIBC_PROBE (memory_realloc_retry, 2, bytes, oldmem);\n      newp = __libc_malloc (bytes);\n      if (newp != NULL)\n        {\n\t  size_t sz = memsize (oldp);\n\t  memcpy (newp, oldmem, sz);\n\t  (void) tag_region (chunk2mem (oldp), sz);\n          _int_free (ar_ptr, oldp, 0);\n        }\n    }\n\n  return newp;\n}",
    "__libc_memalign": "*\n__libc_memalign (size_t alignment, size_t bytes){\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n\n  void *address = RETURN_ADDRESS (0);\n  return _mid_memalign (alignment, bytes, address);\n}",
    "aligned_alloc": "*\nweak_function\naligned_alloc (size_t alignment, size_t bytes){\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n\n/* Similar to memalign, but starting with ISO C17 the standard\n   requires an error for alignments that are not supported by the\n   implementation.  Valid alignments for the current implementation\n   are non-negative powers of two.  */\n  if (!powerof2 (alignment) || alignment == 0)\n    {\n      __set_errno (EINVAL);\n      return 0;\n    }\n\n  void *address = RETURN_ADDRESS (0);\n  return _mid_memalign (alignment, bytes, address);\n}",
    "__libc_valloc": "*\n__libc_valloc (size_t bytes){\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n\n  void *address = RETURN_ADDRESS (0);\n  size_t pagesize = GLRO (dl_pagesize);\n  return _mid_memalign (pagesize, bytes, address);\n}",
    "__libc_pvalloc": "*\n__libc_pvalloc (size_t bytes){\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n\n  void *address = RETURN_ADDRESS (0);\n  size_t pagesize = GLRO (dl_pagesize);\n  size_t rounded_bytes;\n  /* ALIGN_UP with overflow check.  */\n  if (__glibc_unlikely (__builtin_add_overflow (bytes,\n\t\t\t\t\t\tpagesize - 1,\n\t\t\t\t\t\t&rounded_bytes)))\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n  rounded_bytes = rounded_bytes & -(pagesize - 1);\n\n  return _mid_memalign (pagesize, rounded_bytes, address);\n}",
    "__libc_calloc": "*\n__libc_calloc (size_t n, size_t elem_size){\n  mstate av;\n  mchunkptr oldtop;\n  INTERNAL_SIZE_T sz, oldtopsize;\n  void *mem;\n  unsigned long clearsize;\n  unsigned long nclears;\n  INTERNAL_SIZE_T *d;\n  ptrdiff_t bytes;\n\n  if (__glibc_unlikely (__builtin_mul_overflow (n, elem_size, &bytes)))\n    {\n       __set_errno (ENOMEM);\n       return NULL;\n    }\n\n  sz = bytes;\n\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n\n  MAYBE_INIT_TCACHE ();\n\n  if (SINGLE_THREAD_P)\n    av = &main_arena;\n  else\n    arena_get (av, sz);\n\n  if (av)\n    {\n      /* Check if we hand out the top chunk, in which case there may be no\n\t need to clear. */\n#if MORECORE_CLEARS\n      oldtop = top (av);\n      oldtopsize = chunksize (top (av));\n# if MORECORE_CLEARS < 2\n      /* Only newly allocated memory is guaranteed to be cleared.  */\n      if (av == &main_arena &&\n\t  oldtopsize < mp_.sbrk_base + av->max_system_mem - (char *) oldtop)\n\toldtopsize = (mp_.sbrk_base + av->max_system_mem - (char *) oldtop);\n# endif\n      if (av != &main_arena)\n\t{\n\t  heap_info *heap = heap_for_ptr (oldtop);\n\t  if (oldtopsize < (char *) heap + heap->mprotect_size - (char *) oldtop)\n\t    oldtopsize = (char *) heap + heap->mprotect_size - (char *) oldtop;\n\t}\n#endif\n    }\n  else\n    {\n      /* No usable arenas.  */\n      oldtop = 0;\n      oldtopsize = 0;\n    }\n  mem = _int_malloc (av, sz);\n\n  assert (!mem || chunk_is_mmapped (mem2chunk (mem)) ||\n          av == arena_for_chunk (mem2chunk (mem)));\n\n  if (!SINGLE_THREAD_P)\n    {\n      if (mem == 0 && av != NULL)\n\t{\n\t  LIBC_PROBE (memory_calloc_retry, 1, sz);\n\t  av = arena_get_retry (av, sz);\n\t  mem = _int_malloc (av, sz);\n\t}\n\n      if (av != NULL)\n\t__libc_lock_unlock (av->mutex);\n    }\n\n  /* Allocation failed even after a retry.  */\n  if (mem == 0)\n    return 0;\n\n  mchunkptr p = mem2chunk (mem);\n\n  /* If we are using memory tagging, then we need to set the tags\n     regardless of MORECORE_CLEARS, so we zero the whole block while\n     doing so.  */\n  if (__glibc_unlikely (mtag_enabled))\n    return tag_new_zero_region (mem, memsize (p));\n\n  INTERNAL_SIZE_T csz = chunksize (p);\n\n  /* Two optional cases in which clearing not necessary */\n  if (chunk_is_mmapped (p))\n    {\n      if (__builtin_expect (perturb_byte, 0))\n        return memset (mem, 0, sz);\n\n      return mem;\n    }\n\n#if MORECORE_CLEARS\n  if (perturb_byte == 0 && (p == oldtop && csz > oldtopsize))\n    {\n      /* clear only the bytes from non-freshly-sbrked memory */\n      csz = oldtopsize;\n    }\n#endif\n\n  /* Unroll clear of <= 36 bytes (72 if 8byte sizes).  We know that\n     contents have an odd number of INTERNAL_SIZE_T-sized words;\n     minimally 3.  */\n  d = (INTERNAL_SIZE_T *) mem;\n  clearsize = csz - SIZE_SZ;\n  nclears = clearsize / sizeof (INTERNAL_SIZE_T);\n  assert (nclears >= 3);\n\n  if (nclears > 9)\n    return memset (d, 0, clearsize);\n\n  else\n    {\n      *(d + 0) = 0;\n      *(d + 1) = 0;\n      *(d + 2) = 0;\n      if (nclears > 4)\n        {\n          *(d + 3) = 0;\n          *(d + 4) = 0;\n          if (nclears > 6)\n            {\n              *(d + 5) = 0;\n              *(d + 6) = 0;\n              if (nclears > 8)\n                {\n                  *(d + 7) = 0;\n                  *(d + 8) = 0;\n                }\n            }\n        }\n    }\n\n  return mem;\n}",
    "__libc_mallinfo": "__libc_mallinfo (void){\n  struct mallinfo m;\n  struct mallinfo2 m2 = __libc_mallinfo2 ();\n\n  m.arena = m2.arena;\n  m.ordblks = m2.ordblks;\n  m.smblks = m2.smblks;\n  m.hblks = m2.hblks;\n  m.hblkhd = m2.hblkhd;\n  m.usmblks = m2.usmblks;\n  m.fsmblks = m2.fsmblks;\n  m.uordblks = m2.uordblks;\n  m.fordblks = m2.fordblks;\n  m.keepcost = m2.keepcost;\n\n  return m;\n}",
    "__libc_mallopt": "__libc_mallopt (int param_number, int value){\n  mstate av = &main_arena;\n  int res = 1;\n\n  if (!__malloc_initialized)\n    ptmalloc_init ();\n  __libc_lock_lock (av->mutex);\n\n  LIBC_PROBE (memory_mallopt, 2, param_number, value);\n\n  /* We must consolidate main arena before changing max_fast\n     (see definition of set_max_fast).  */\n  malloc_consolidate (av);\n\n  /* Many of these helper functions take a size_t.  We do not worry\n     about overflow here, because negative int values will wrap to\n     very large size_t values and the helpers have sufficient range\n     checking for such conversions.  Many of these helpers are also\n     used by the tunables macros in arena.c.  */\n\n  switch (param_number)\n    {\n    case M_MXFAST:\n      res = do_set_mxfast (value);\n      break;\n\n    case M_TRIM_THRESHOLD:\n      res = do_set_trim_threshold (value);\n      break;\n\n    case M_TOP_PAD:\n      res = do_set_top_pad (value);\n      break;\n\n    case M_MMAP_THRESHOLD:\n      res = do_set_mmap_threshold (value);\n      break;\n\n    case M_MMAP_MAX:\n      res = do_set_mmaps_max (value);\n      break;\n\n    case M_CHECK_ACTION:\n      res = do_set_mallopt_check (value);\n      break;\n\n    case M_PERTURB:\n      res = do_set_perturb_byte (value);\n      break;\n\n    case M_ARENA_TEST:\n      if (value > 0)\n\tres = do_set_arena_test (value);\n      break;\n\n    case M_ARENA_MAX:\n      if (value > 0)\n\tres = do_set_arena_max (value);\n      break;\n    }\n  __libc_lock_unlock (av->mutex);\n  return res;\n}",
    "mcheck_check_all": "mcheck_check_all (void){\n#if !IS_IN (libc)\n  __mcheck_checkptr (NULL);\n#endif\n}",
    "mcheck": "mcheck (void (*func) (enum mcheck_status)){\n#if IS_IN (libc)\n  return -1;\n#else\n  return __mcheck_initialize (func, false);\n#endif\n}",
    "mcheck_pedantic": "mcheck_pedantic (void (*func) (enum mcheck_status)){\n#if IS_IN (libc)\n  return -1;\n#else\n  return __mcheck_initialize (func, true);\n#endif\n}",
    "mprobe": "mprobe (void *ptr){\n#if IS_IN (libc)\n  return MCHECK_DISABLED;\n#else\n  return __mcheck_checkptr (ptr);\n#endif\n}",
    "mmap": "*\nmmap (void *start, size_t len, int prot, int flags, int fd, off_t offset){\n  void *result = NULL;\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return NULL;\n\n      me ();\n    }\n\n  /* Always get a block.  We don't need extra memory.  */\n  result = (*mmapp)(start, len, prot, flags, fd, offset);\n\n  if (!not_me && trace_mmap)\n    {\n      int idx = (flags & MAP_ANON\n                 ? idx_mmap_a : prot & PROT_WRITE ? idx_mmap_w : idx_mmap_r);\n\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx], 1, memory_order_relaxed);\n      /* Keep track of total memory consumption for `malloc'.  */\n      atomic_fetch_add_explicit (&total[idx], len, memory_order_relaxed);\n      /* Keep track of total memory requirement.  */\n      atomic_fetch_add_explicit (&grand_total, len, memory_order_relaxed);\n      /* Remember the size of the request.  */\n      if (len < 65536)\n        atomic_fetch_add_explicit (&histogram[len / 16], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        atomic_fetch_add_explicit (&large, 1, memory_order_relaxed);\n      /* Total number of calls of any of the functions.  */\n      atomic_fetch_add_explicit (&calls_total, 1, memory_order_relaxed);\n\n      /* Check for failures.  */\n      if (result == NULL)\n        atomic_fetch_add_explicit (&failed[idx], 1, memory_order_relaxed);\n      else if (idx == idx_mmap_w)\n        /* Update the allocation data and write out the records if\n           necessary.  Note the first parameter is NULL which means\n           the size is not tracked.  */\n        update_data (NULL, len, 0);\n    }\n\n  /* Return the pointer to the user buffer.  */\n  return result;\n}",
    "mmap64": "*\nmmap64 (void *start, size_t len, int prot, int flags, int fd, off64_t offset){\n  void *result = NULL;\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return NULL;\n\n      me ();\n    }\n\n  /* Always get a block.  We don't need extra memory.  */\n  result = (*mmap64p)(start, len, prot, flags, fd, offset);\n\n  if (!not_me && trace_mmap)\n    {\n      int idx = (flags & MAP_ANON\n                 ? idx_mmap_a : prot & PROT_WRITE ? idx_mmap_w : idx_mmap_r);\n\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx], 1, memory_order_relaxed);\n      /* Keep track of total memory consumption for `malloc'.  */\n      atomic_fetch_add_explicit (&total[idx], len, memory_order_relaxed);\n      /* Keep track of total memory requirement.  */\n      atomic_fetch_add_explicit (&grand_total, len, memory_order_relaxed);\n      /* Remember the size of the request.  */\n      if (len < 65536)\n        atomic_fetch_add_explicit (&histogram[len / 16], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        atomic_fetch_add_explicit (&large, 1, memory_order_relaxed);\n      /* Total number of calls of any of the functions.  */\n      atomic_fetch_add_explicit (&calls_total, 1, memory_order_relaxed);\n\n      /* Check for failures.  */\n      if (result == NULL)\n        atomic_fetch_add_explicit (&failed[idx], 1, memory_order_relaxed);\n      else if (idx == idx_mmap_w)\n        /* Update the allocation data and write out the records if\n           necessary.  Note the first parameter is NULL which means\n           the size is not tracked.  */\n        update_data (NULL, len, 0);\n    }\n\n  /* Return the pointer to the user buffer.  */\n  return result;\n}",
    "mremap": "*\nmremap (void *start, size_t old_len, size_t len, int flags, ...){\n  void *result = NULL;\n  va_list ap;\n\n  va_start (ap, flags);\n  void *newaddr = (flags & MREMAP_FIXED) ? va_arg (ap, void *) : NULL;\n  va_end (ap);\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return NULL;\n\n      me ();\n    }\n\n  /* Always get a block.  We don't need extra memory.  */\n  result = (*mremapp)(start, old_len, len, flags, newaddr);\n\n  if (!not_me && trace_mmap)\n    {\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx_mremap], 1, memory_order_relaxed);\n      if (len > old_len)\n        {\n          /* Keep track of total memory consumption for `malloc'.  */\n          atomic_fetch_add_explicit (&total[idx_mremap], len - old_len,\n\t\t\t\t     memory_order_relaxed);\n          /* Keep track of total memory requirement.  */\n          atomic_fetch_add_explicit (&grand_total, len - old_len,\n\t\t\t\t     memory_order_relaxed);\n        }\n      /* Remember the size of the request.  */\n      if (len < 65536)\n        atomic_fetch_add_explicit (&histogram[len / 16], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        atomic_fetch_add_explicit (&large, 1, memory_order_relaxed);\n      /* Total number of calls of any of the functions.  */\n      atomic_fetch_add_explicit (&calls_total, 1, memory_order_relaxed);\n\n      /* Check for failures.  */\n      if (result == NULL)\n        atomic_fetch_add_explicit (&failed[idx_mremap], 1,\n\t\t\t\t   memory_order_relaxed);\n      else\n        {\n          /* Record whether the reduction/increase happened in place.  */\n          if (start == result)\n            atomic_fetch_add_explicit (&inplace_mremap, 1,\n\t\t\t\t       memory_order_relaxed);\n          /* Was the buffer increased?  */\n          if (old_len > len)\n            atomic_fetch_add_explicit (&decreasing_mremap, 1,\n\t\t\t\t       memory_order_relaxed);\n\n          /* Update the allocation data and write out the records if\n             necessary.  Note the first parameter is NULL which means\n             the size is not tracked.  */\n          update_data (NULL, len, old_len);\n        }\n    }\n\n  /* Return the pointer to the user buffer.  */\n  return result;\n}",
    "munmap": "munmap (void *start, size_t len){\n  int result;\n\n  /* Determine real implementation if not already happened.  */\n  if (__glibc_unlikely (initialized <= 0))\n    {\n      if (initialized == -1)\n        return -1;\n\n      me ();\n    }\n\n  /* Do the real work.  */\n  result = (*munmapp)(start, len);\n\n  if (!not_me && trace_mmap)\n    {\n      /* Keep track of number of calls.  */\n      atomic_fetch_add_explicit (&calls[idx_munmap], 1, memory_order_relaxed);\n\n      if (__glibc_likely (result == 0))\n        {\n          /* Keep track of total memory freed using `free'.  */\n          atomic_fetch_add_explicit (&total[idx_munmap], len,\n\t\t\t\t     memory_order_relaxed);\n\n          /* Update the allocation data and write out the records if\n             necessary.  */\n          update_data (NULL, 0, len);\n        }\n      else\n        atomic_fetch_add_explicit (&failed[idx_munmap], 1,\n\t\t\t\t   memory_order_relaxed);\n    }\n\n  return result;\n}",
    "tr_break": "tr_break (void){\n}",
    "mtrace": "mtrace (void){\n#if !IS_IN (libc)\n  do_mtrace ();\n#endif\n}",
    "muntrace": "muntrace (void){\n#if !IS_IN (libc)\n  do_muntrace ();\n#endif\n}",
    "_obstack_begin": "_obstack_begin (struct obstack *h,\n\t\tint size, int alignment,\n\t\tvoid *(*chunkfun) (long),\n\t\tvoid (*freefun) (void *)){\n  struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n\t Use the values for range checking, because if range checking is off,\n\t the extra bytes won't be missed terribly, but if range checking is on\n\t and we used a larger request, a whole extra 4096 bytes would be\n\t allocated.\n\n\t These number are irrelevant to the new GNU malloc.  I suspect it is\n\t less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n\t\t    + 4 + DEFAULT_ROUNDING - 1)\n\t\t   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*) (void *, long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->use_extra_arg = 0;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n\t\t\t\t\t       alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
    "_obstack_begin_1": "_obstack_begin_1 (struct obstack *h, int size, int alignment,\n\t\t  void *(*chunkfun) (void *, long),\n\t\t  void (*freefun) (void *, void *),\n\t\t  void *arg){\n  struct _obstack_chunk *chunk; /* points to new chunk */\n\n  if (alignment == 0)\n    alignment = DEFAULT_ALIGNMENT;\n  if (size == 0)\n    /* Default size is what GNU malloc can fit in a 4096-byte block.  */\n    {\n      /* 12 is sizeof (mhead) and 4 is EXTRA from GNU malloc.\n\t Use the values for range checking, because if range checking is off,\n\t the extra bytes won't be missed terribly, but if range checking is on\n\t and we used a larger request, a whole extra 4096 bytes would be\n\t allocated.\n\n\t These number are irrelevant to the new GNU malloc.  I suspect it is\n\t less sensitive to the size of the request.  */\n      int extra = ((((12 + DEFAULT_ROUNDING - 1) & ~(DEFAULT_ROUNDING - 1))\n\t\t    + 4 + DEFAULT_ROUNDING - 1)\n\t\t   & ~(DEFAULT_ROUNDING - 1));\n      size = 4096 - extra;\n    }\n\n  h->chunkfun = (struct _obstack_chunk * (*)(void *,long)) chunkfun;\n  h->freefun = (void (*) (void *, struct _obstack_chunk *)) freefun;\n  h->chunk_size = size;\n  h->alignment_mask = alignment - 1;\n  h->extra_arg = arg;\n  h->use_extra_arg = 1;\n\n  chunk = h->chunk = CALL_CHUNKFUN (h, h->chunk_size);\n  if (!chunk)\n    (*obstack_alloc_failed_handler) ();\n  h->next_free = h->object_base = __PTR_ALIGN ((char *) chunk, chunk->contents,\n\t\t\t\t\t       alignment - 1);\n  h->chunk_limit = chunk->limit\n    = (char *) chunk + h->chunk_size;\n  chunk->prev = 0;\n  /* The initial chunk now contains no empty object.  */\n  h->maybe_empty_object = 0;\n  h->alloc_failed = 0;\n  return 1;\n}",
    "_obstack_newchunk": "_obstack_newchunk (struct obstack *h, int length){\n  struct _obstack_chunk *old_chunk = h->chunk;\n  struct _obstack_chunk *new_chunk;\n  long new_size;\n  long obj_size = h->next_free - h->object_base;\n  long i;\n  long already;\n  char *object_base;\n\n  /* Compute size for new chunk.  */\n  new_size = (obj_size + length) + (obj_size >> 3) + h->alignment_mask + 100;\n  if (new_size < h->chunk_size)\n    new_size = h->chunk_size;\n\n  /* Allocate and initialize the new chunk.  */\n  new_chunk = CALL_CHUNKFUN (h, new_size);\n  if (!new_chunk)\n    (*obstack_alloc_failed_handler)();\n  h->chunk = new_chunk;\n  new_chunk->prev = old_chunk;\n  new_chunk->limit = h->chunk_limit = (char *) new_chunk + new_size;\n\n  /* Compute an aligned object_base in the new chunk */\n  object_base =\n    __PTR_ALIGN ((char *) new_chunk, new_chunk->contents, h->alignment_mask);\n\n  /* Move the existing object to the new chunk.\n     Word at a time is fast and is safe if the object\n     is sufficiently aligned.  */\n  if (h->alignment_mask + 1 >= DEFAULT_ALIGNMENT)\n    {\n      for (i = obj_size / sizeof (COPYING_UNIT) - 1;\n\t   i >= 0; i--)\n\t((COPYING_UNIT *) object_base)[i]\n\t  = ((COPYING_UNIT *) h->object_base)[i];\n      /* We used to copy the odd few remaining bytes as one extra COPYING_UNIT,\n\t but that can cross a page boundary on a machine\n\t which does not do strict alignment for COPYING_UNITS.  */\n      already = obj_size / sizeof (COPYING_UNIT) * sizeof (COPYING_UNIT);\n    }\n  else\n    already = 0;\n  /* Copy remaining bytes one by one.  */\n  for (i = already; i < obj_size; i++)\n    object_base[i] = h->object_base[i];\n\n  /* If the object just copied was the only data in OLD_CHUNK,\n     free that chunk and remove it from the chain.\n     But not if that chunk might contain an empty object.  */\n  if (!h->maybe_empty_object\n      && (h->object_base\n\t  == __PTR_ALIGN ((char *) old_chunk, old_chunk->contents,\n\t\t\t  h->alignment_mask)))\n    {\n      new_chunk->prev = old_chunk->prev;\n      CALL_FREEFUN (h, old_chunk);\n    }\n\n  h->object_base = object_base;\n  h->next_free = h->object_base + obj_size;\n  /* The new chunk certainly contains no empty object yet.  */\n  h->maybe_empty_object = 0;\n}",
    "_obstack_allocated_p": "_obstack_allocated_p (struct obstack *h, void *obj){\n  struct _obstack_chunk *lp;    /* below addr of any objects in this chunk */\n  struct _obstack_chunk *plp;   /* point to previous chunk if any */\n\n  lp = (h)->chunk;\n  /* We use >= rather than > since the object cannot be exactly at\n     the beginning of the chunk but might be an empty object exactly\n     at the end of an adjacent chunk.  */\n  while (lp != 0 && ((void *) lp >= obj || (void *) (lp)->limit < obj))\n    {\n      plp = lp->prev;\n      lp = plp;\n    }\n  return lp != 0;\n}",
    "_obstack_memory_used": "_obstack_memory_used (struct obstack *h){\n  struct _obstack_chunk *lp;\n  int nbytes = 0;\n\n  for (lp = h->chunk; lp != 0; lp = lp->prev)\n    {\n      nbytes += lp->limit - (char *) lp;\n    }\n  return nbytes;\n}",
    "__libc_reallocarray": "*\n__libc_reallocarray (void *optr, size_t nmemb, size_t elem_size){\n  size_t bytes;\n  if (__builtin_mul_overflow (nmemb, elem_size, &bytes))\n    {\n      __set_errno (ENOMEM);\n      return 0;\n    }\n  return realloc (optr, bytes);\n}",
    "__libc_scratch_buffer_grow": "__libc_scratch_buffer_grow (struct scratch_buffer *buffer){\n  void *new_ptr;\n  size_t new_length = buffer->length * 2;\n\n  /* Discard old buffer.  */\n  scratch_buffer_free (buffer);\n\n  /* Check for overflow.  */\n  if (__glibc_likely (new_length >= buffer->length))\n    new_ptr = malloc (new_length);\n  else\n    {\n      __set_errno (ENOMEM);\n      new_ptr = NULL;\n    }\n\n  if (__glibc_unlikely (new_ptr == NULL))\n    {\n      /* Buffer must remain valid to free.  */\n      scratch_buffer_init (buffer);\n      return false;\n    }\n\n  /* Install new heap-based buffer.  */\n  buffer->data = new_ptr;\n  buffer->length = new_length;\n  return true;\n}",
    "__libc_scratch_buffer_grow_preserve": "__libc_scratch_buffer_grow_preserve (struct scratch_buffer *buffer){\n  size_t new_length = 2 * buffer->length;\n  void *new_ptr;\n\n  if (buffer->data == buffer->__space.__c)\n    {\n      /* Move buffer to the heap.  No overflow is possible because\n\t buffer->length describes a small buffer on the stack.  */\n      new_ptr = malloc (new_length);\n      if (new_ptr == NULL)\n\treturn false;\n      memcpy (new_ptr, buffer->__space.__c, buffer->length);\n    }\n  else\n    {\n      /* Buffer was already on the heap.  Check for overflow.  */\n      if (__glibc_likely (new_length >= buffer->length))\n\tnew_ptr = realloc (buffer->data, new_length);\n      else\n\t{\n\t  __set_errno (ENOMEM);\n\t  new_ptr = NULL;\n\t}\n\n      if (__glibc_unlikely (new_ptr == NULL))\n\t{\n\t  /* Deallocate, but buffer must remain valid to free.  */\n\t  free (buffer->data);\n\t  scratch_buffer_init (buffer);\n\t  return false;\n\t}\n    }\n\n  /* Install new heap-based buffer.  */\n  buffer->data = new_ptr;\n  buffer->length = new_length;\n  return true;\n}",
    "__libc_scratch_buffer_set_array_size": "__libc_scratch_buffer_set_array_size (struct scratch_buffer *buffer,\n\t\t\t\t      size_t nelem, size_t size){\n  size_t new_length = nelem * size;\n\n  /* Avoid overflow check if both values are small. */\n  if ((nelem | size) >> (sizeof (size_t) * CHAR_BIT / 2) != 0\n      && nelem != 0 && size != new_length / nelem)\n    {\n      /* Overflow.  Discard the old buffer, but it must remain valid\n\t to free.  */\n      scratch_buffer_free (buffer);\n      scratch_buffer_init (buffer);\n      __set_errno (ENOMEM);\n      return false;\n    }\n\n  if (new_length <= buffer->length)\n    return true;\n\n  /* Discard old buffer.  */\n  scratch_buffer_free (buffer);\n\n  char *new_ptr = malloc (new_length);\n  if (new_ptr == NULL)\n    {\n      /* Buffer must remain valid to free.  */\n      scratch_buffer_init (buffer);\n      return false;\n    }\n\n  /* Install new heap-based buffer.  */\n  buffer->data = new_ptr;\n  buffer->length = new_length;\n  return true;\n}",
    "__libc_freeres": "__libc_freeres (void){\n  /* This function might be called from different places.  So better\n     protect for multiple executions since these are fatal.  */\n  static long int already_called;\n\n  if (!atomic_compare_and_exchange_bool_acq (&already_called, 1, 0))\n    {\n      call_function_static_weak (__nss_module_freeres);\n      call_function_static_weak (__nss_action_freeres);\n      call_function_static_weak (__nss_database_freeres);\n\n      _IO_cleanup ();\n\n      /* We run the resource freeing after IO cleanup.  */\n      call_function_static_weak (__dl_libc_freemem);\n      call_function_static_weak (__hdestroy);\n      call_function_static_weak (__gconv_cache_freemem);\n      call_function_static_weak (__gconv_conf_freemem);\n      call_function_static_weak (__gconv_db_freemem);\n      call_function_static_weak (__gconv_dl_freemem);\n      call_function_static_weak (__intl_freemem);\n      call_function_static_weak (__libio_freemem);\n      call_function_static_weak (__libc_fstab_freemem);\n\n#ifdef USE_NSCD\n      call_function_static_weak (__nscd_gr_map_freemem);\n      call_function_static_weak (__nscd_hst_map_freemem);\n      call_function_static_weak (__nscd_pw_map_freemem);\n      call_function_static_weak (__nscd_serv_map_freemem);\n      call_function_static_weak (__nscd_group_map_freemem);\n#endif\n\n      call_function_static_weak (__libc_regcomp_freemem);\n      call_function_static_weak (__libc_atfork_freemem);\n      /* __res_thread_freeres deallocates the per-thread resolv_context);\n\t which in turn drop the reference count of the current global object.\n\t So it need to be before __libc_resolv_conf_freemem.  */\n      call_function_static_weak (__res_thread_freeres);\n      call_function_static_weak (__libc_resolv_conf_freemem);\n      call_function_static_weak (__libc_printf_freemem);\n      call_function_static_weak (__libc_fmtmsg_freemem);\n      call_function_static_weak (__libc_setenv_freemem);\n#if SHLIB_COMPAT (libc, GLIBC_2_0, GLIBC_2_31)\n      call_function_static_weak (__rpc_freemem);\n      call_function_static_weak (__rpc_thread_destroy);\n#endif\n      call_function_static_weak (__libc_getaddrinfo_freemem);\n      call_function_static_weak (__libc_tzset_freemem);\n      call_function_static_weak (__libc_localealias_freemem);\n\n#if PTHREAD_IN_LIBC\n      call_function_static_weak (__gai_freemem);\n\n      call_function_static_weak (__aio_freemem);\n#endif\n\n      call_function_static_weak (__libpthread_freeres);\n\n#ifdef SHARED\n      __libc_unwind_link_freeres ();\n#endif\n\n      call_function_static_weak (__libc_dlerror_result_free);\n\n#ifdef SHARED\n      GLRO (dl_libc_freeres) ();\n#endif\n\n      call_free_static_weak (__libc_fgetgrent_freemem_ptr);\n      call_free_static_weak (__libc_fgetsgent_freeres_ptr);\n      call_free_static_weak (__libc_getnetgrent_freemem_ptr);\n      call_free_static_weak (__libc_rcmd_freemem_ptr);\n      call_free_static_weak (__libc_rexec_freemem_ptr);\n      call_free_static_weak (__libc_mntent_freemem_ptr);\n      call_free_static_weak (__libc_fgetpwent_freemem_ptr);\n      call_free_static_weak (__libc_resolv_res_hconf_freemem_ptr);\n      call_free_static_weak (__libc_fgetspent_freemem_ptr);\n      call_free_static_weak (__libc_tzfile_freemem_ptr);\n      call_free_static_weak (__libc_getnameinfo_freemem_ptr);\n      call_free_static_weak (__libc_getutent_freemem_ptr);\n      call_free_static_weak (__libc_getutid_freemem_ptr);\n      call_free_static_weak (__libc_getutline_freemem_ptr);\n      call_free_static_weak (__libc_reg_printf_freemem_ptr);\n      call_free_static_weak (__libc_reg_type_freemem_ptr);\n\n      call_free_static_weak (__libc_getgrgid_freemem_ptr);\n      call_free_static_weak (__libc_getgrnam_freemem_ptr);\n      call_free_static_weak (__libc_getpwnam_freemem_ptr);\n      call_free_static_weak (__libc_getpwuid_freemem_ptr);\n      call_free_static_weak (__libc_getspnam_freemem_ptr);\n      call_free_static_weak (__libc_getaliasbyname_freemem_ptr);\n      call_free_static_weak (__libc_gethostbyaddr_freemem_ptr);\n      call_free_static_weak (__libc_gethostbyname_freemem_ptr);\n      call_free_static_weak (__libc_gethostbyname2_freemem_ptr);\n      call_free_static_weak (__libc_getnetbyaddr_freemem_ptr);\n      call_free_static_weak (__libc_getnetbyname_freemem_ptr);\n      call_free_static_weak (__libc_getprotobynumber_freemem_ptr);\n      call_free_static_weak (__libc_getprotobyname_freemem_ptr);\n      call_free_static_weak (__libc_getrpcbyname_freemem_ptr);\n      call_free_static_weak (__libc_getrpcbynumber_freemem_ptr);\n      call_free_static_weak (__libc_getservbyname_freemem_ptr);\n      call_free_static_weak (__libc_getservbyport_freemem_ptr);\n\n      call_free_static_weak (__libc_getgrent_freemem_ptr);\n      call_free_static_weak (__libc_getpwent_freemem_ptr);\n      call_free_static_weak (__libc_getspent_freemem_ptr);\n      call_free_static_weak (__libc_getaliasent_freemem_ptr);\n      call_free_static_weak (__libc_gethostent_freemem_ptr);\n      call_free_static_weak (__libc_getnetent_freemem_ptr);\n      call_free_static_weak (__libc_getprotoent_freemem_ptr);\n      call_free_static_weak (__libc_getrpcent_freemem_ptr);\n      call_free_static_weak (__libc_getservent_freemem_ptr);\n\n      call_free_static_weak (__libc_efgcvt_freemem_ptr);\n      call_free_static_weak (__libc_qefgcvt_freemem_ptr);\n\n      call_freeres_system_funcs;\n    }\n}",
    "twalk": "twalk (const void *root, void (*action) (const void *, VISIT, int)){\n  struct twalk_with_twalk_r_closure closure = { action, 0 };\n  twalk_r (root, twalk_with_twalk_r_action, &closure);\n}",
    "fedisableexcept": "fedisableexcept (int excepts){\n  unsigned short int new_exc, old_exc;\n  unsigned int new;\n\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Get the current control word of the x87 FPU.  */\n  __asm__ (\"fstcw %0\" : \"=m\" (*&new_exc));\n\n  old_exc = (~new_exc) & FE_ALL_EXCEPT;\n\n  new_exc |= excepts;\n  __asm__ (\"fldcw %0\" : : \"m\" (*&new_exc));\n\n  /* And now the same for the SSE MXCSR register.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&new));\n\n  /* The SSE exception masks are shifted by 7 bits.  */\n  new |= excepts << 7;\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&new));\n\n  return old_exc;\n}",
    "feenableexcept": "feenableexcept (int excepts){\n  unsigned short int new_exc, old_exc;\n  unsigned int new;\n\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Get the current control word of the x87 FPU.  */\n  __asm__ (\"fstcw %0\" : \"=m\" (*&new_exc));\n\n  old_exc = (~new_exc) & FE_ALL_EXCEPT;\n\n  new_exc &= ~excepts;\n  __asm__ (\"fldcw %0\" : : \"m\" (*&new_exc));\n\n  /* And now the same for the SSE MXCSR register.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&new));\n\n  /* The SSE exception masks are shifted by 7 bits.  */\n  new &= ~(excepts << 7);\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&new));\n\n  return old_exc;\n}",
    "fegetexcept": "fegetexcept (void){\n  unsigned short int exc;\n\n  /* Get the current control word.  */\n  __asm__ (\"fstcw %0\" : \"=m\" (*&exc));\n\n  return (~exc) & FE_ALL_EXCEPT;\n}",
    "fegetmode": "fegetmode (femode_t *modep){\n  _FPU_GETCW (modep->__control_word);\n  __asm__ (\"stmxcsr %0\" : \"=m\" (modep->__mxcsr));\n  return 0;\n}",
    "fesetexcept": "fesetexcept (int excepts){\n  unsigned int mxcsr;\n\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&mxcsr));\n  mxcsr |= excepts & FE_ALL_EXCEPT;\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&mxcsr));\n\n  return 0;\n}",
    "fesetmode": "fesetmode (const femode_t *modep){\n  fpu_control_t cw;\n  unsigned int mxcsr;\n  __asm__ (\"stmxcsr %0\" : \"=m\" (mxcsr));\n  /* Preserve SSE exception flags but restore other state in\n     MXCSR.  */\n  mxcsr &= FE_ALL_EXCEPT_X86;\n  if (modep == FE_DFL_MODE)\n    {\n      cw = _FPU_DEFAULT;\n      /* Default MXCSR state has all bits zero except for those\n\t masking exceptions.  */\n      mxcsr |= FE_ALL_EXCEPT_X86 << 7;\n    }\n  else\n    {\n      cw = modep->__control_word;\n      mxcsr |= modep->__mxcsr & ~FE_ALL_EXCEPT_X86;\n    }\n  _FPU_SETCW (cw);\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (mxcsr));\n  return 0;\n}",
    "fetestexceptflag": "fetestexceptflag (const fexcept_t *flagp, int excepts){\n  /* Most versions of fegetexceptflag store exceptions in a form such\n     that this works.  */\n  return *flagp & excepts & FE_ALL_EXCEPT;\n}",
    "fetestexcept": "fetestexcept (int excepts){\n  int temp;\n  unsigned int mxscr;\n\n  /* Get current exceptions.  */\n  __asm__ (\"fnstsw %0\\n\"\n\t   \"stmxcsr %1\" : \"=m\" (*&temp), \"=m\" (*&mxscr));\n\n  return (temp | mxscr) & excepts & FE_ALL_EXCEPT;\n}",
    "matherr": "matherr (struct exception *s){\n  printf (\"matherr is working\\n\");\n  fail = 0;\n  return 1;\n}",
    "acct": "acct (const char *name){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_allocate_once_slow": "*\n__libc_allocate_once_slow (void **place, void *(*allocate) (void *closure),\n                           void (*deallocate) (void *closure, void *ptr),\n                           void *closure){\n  void *result = allocate (closure);\n  if (result == NULL)\n    return NULL;\n\n  /* This loop implements a strong CAS on *place, with acquire-release\n     MO semantics, from a weak CAS with relaxed-release MO.  */\n  while (true)\n    {\n      /* Synchronizes with the acquire MO load in allocate_once.  */\n      void *expected = NULL;\n      if (atomic_compare_exchange_weak_release (place, &expected, result))\n        return result;\n\n      /* The failed CAS has relaxed MO semantics, so perform another\n         acquire MO load.  */\n      void *other_result = atomic_load_acquire (place);\n      if (other_result == NULL)\n        /* Spurious failure.  Try again.  */\n        continue;\n\n      /* We lost the race.  Free what we allocated and return the\n         other result.  */\n      if (deallocate == NULL)\n        free (result);\n      else\n        deallocate (closure, result);\n      return other_result;\n    }\n\n  return result;\n}",
    "chflags": "chflags (const char *file, unsigned long int flags){\n  error_t err;\n  file_t port = __file_name_lookup (file, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = __file_chflags (port, flags);\n  __mach_port_deallocate (__mach_task_self (), port);\n  if (err)\n    return __hurd_fail (err);\n  return 0;\n}",
    "chroot": "chroot (const char *path){\n  const char *lookup;\n  size_t len;\n  file_t dir, root;\n  error_t err;\n\n  /* Append trailing \"/.\" to directory name to force ENOTDIR if it's not a\n     directory and EACCES if we don't have search permission.  */\n  len = strlen (path);\n  if (len >= 2 && path[len - 2] == '/' && path[len - 1] == '.')\n    lookup = path;\n  else if (len == 0)\n    /* Special-case empty file name according to POSIX.  */\n    return __hurd_fail (ENOENT);\n  else\n    {\n      char *n = alloca (len + 3);\n      memcpy (n, path, len);\n      n[len] = '/';\n      n[len + 1] = '.';\n      n[len + 2] = '\\0';\n      lookup = n;\n    }\n\n  dir = __file_name_lookup (lookup, 0, 0);\n  if (dir == MACH_PORT_NULL)\n    return -1;\n\n  /* Prevent going through DIR's ..  */\n  err = __file_reparent (dir, MACH_PORT_NULL, &root);\n  __mach_port_deallocate (__mach_task_self (), dir);\n  if (err)\n    return __hurd_fail (err);\n\n  _hurd_port_set (&_hurd_ports[INIT_PORT_CRDIR], root);\n  return 0;\n}",
    "daemon": "daemon (int nochdir, int noclose){\n  int fd;\n\n  switch (__fork ())\n    {\n    case -1:\n      return -1;\n\n    case 0:\n      break;\n\n    default:\n      _exit (0);\n    }\n\n  if (__setsid () == -1)\n    return -1;\n\n  if (!nochdir)\n    (void) __chdir (\"/\");\n\n  if (!noclose)\n    {\n      struct __stat64_t64 st;\n\n      fd = __open_nocancel (_PATH_DEVNULL, O_RDWR, 0);\n      if (fd != -1 && __glibc_likely (__fstat64_time64 (fd, &st) == 0))\n        {\n          if (__builtin_expect (S_ISCHR (st.st_mode), 1) != 0\n#if defined DEV_NULL_MAJOR && defined DEV_NULL_MINOR\n              && (st.st_rdev == makedev (DEV_NULL_MAJOR, DEV_NULL_MINOR))\n#endif\n             )\n            {\n              (void) __dup2 (fd, STDIN_FILENO);\n              (void) __dup2 (fd, STDOUT_FILENO);\n              (void) __dup2 (fd, STDERR_FILENO);\n              if (fd > 2)\n                (void) __close (fd);\n            }\n          else\n            {\n              /* We must set an errno value since no function call\n                 actually failed.  */\n              __close_nocancel_nostatus (fd);\n              __set_errno (ENODEV);\n              return -1;\n            }\n        }\n      else\n        {\n          __close_nocancel_nostatus (fd);\n          return -1;\n        }\n    }\n\n  return 0;\n}",
    "dirname": "*\ndirname (char *path){\n  static const char dot[] = \".\";\n  char *last_slash;\n\n  /* Find last '/'.  */\n  last_slash = path != NULL ? strrchr (path, '/') : NULL;\n\n  if (last_slash != NULL && last_slash != path && last_slash[1] == '\\0')\n    {\n      /* Determine whether all remaining characters are slashes.  */\n      char *runp;\n\n      for (runp = last_slash; runp != path; --runp)\n\tif (runp[-1] != '/')\n\t  break;\n\n      /* The '/' is the last character, we have to look further.  */\n      if (runp != path)\n\tlast_slash = __memrchr (path, '/', runp - path);\n    }\n\n  if (last_slash != NULL)\n    {\n      /* Determine whether all remaining characters are slashes.  */\n      char *runp;\n\n      for (runp = last_slash; runp != path; --runp)\n\tif (runp[-1] != '/')\n\t  break;\n\n      /* Terminate the path.  */\n      if (runp == path)\n\t{\n\t  /* The last slash is the first character in the string.  We have to\n\t     return \"/\".  As a special case we have to return \"//\" if there\n\t     are exactly two slashes at the beginning of the string.  See\n\t     XBD 4.10 Path Name Resolution for more information.  */\n\t  if (last_slash == path + 1)\n\t    ++last_slash;\n\t  else\n\t    last_slash = path + 1;\n\t}\n      else\n\tlast_slash = runp;\n\n      last_slash[0] = '\\0';\n    }\n  else\n    /* This assignment is ill-designed but the XPG specs require to\n       return a string containing \".\" in any case no directory part is\n       found and so a static and constant string is required.  */\n    path = (char *) dot;\n\n  return path;\n}",
    "vwarn": "vwarn (const char *format, __gnuc_va_list ap){\n  __vwarn_internal (format, ap, 0);\n}",
    "vwarnx": "vwarnx (const char *format, __gnuc_va_list ap){\n  __vwarnx_internal (format, ap, 0);\n}",
    "warn": "warn (const char *format, ...){\n  VA (vwarn (format, ap))\n}",
    "warnx": "warnx (const char *format, ...){\n  VA (vwarnx (format, ap))\n}",
    "verr": "verr (int status, const char *format, __gnuc_va_list ap){\n  vwarn (format, ap);\n  exit (status);\n}",
    "verrx": "verrx (int status, const char *format, __gnuc_va_list ap){\n  vwarnx (format, ap);\n  exit (status);\n}",
    "err": "void\nerr (int status, const char *format, ...){\n  VA (verr (status, format, ap))\n}",
    "errx": "errx (int status, const char *format, ...){\n  VA (verrx (status, format, ap))\n}",
    "error": "error(const char *const string, ...){\n\tva_list args;\n\tva_start(args, string);\n\tverror(string, args);\n\tva_end(args);\n\terrors = true;\n}",
    "error_at_line": "error_at_line (int status, int errnum, const char *file_name,\n\t       unsigned int line_number, const char *message, ...){\n  va_list ap;\n  va_start (ap, message);\n  __error_at_line_internal (status, errnum, file_name, line_number,\n\t\t\t    message, ap, 0);\n  va_end (ap);\n}",
    "fchflags": "fchflags (int fd, unsigned long int flags){\n  error_t err;\n\n  if (err = HURD_DPORT_USE (fd, __file_chflags (port, flags)))\n    return __hurd_dfail (fd, err);\n\n  return 0;\n}",
    "fdatasync": "fdatasync (int fd){\n  return SYSCALL_CANCEL (fdatasync, fd);\n}",
    "fgetxattr": "fgetxattr (int fd, const char *name, void *value, size_t size){\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_get (port, name, value, &size));\n\n  return err ? __hurd_dfail (fd, err) : size;\n}",
    "flistxattr": "flistxattr (int fd, char *list, size_t size){\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_list (port, list, &size));\n\n  return err ? __hurd_dfail (fd, err) : size;\n}",
    "fremovexattr": "fremovexattr (int fd, const char *name){\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_remove (port, name));\n\n  return err ? __hurd_dfail (fd, err) : 0;\n}",
    "fsetxattr": "fsetxattr (int fd, const char *name, const void *value, size_t size, int flags){\n  error_t err;\n\n  err = HURD_DPORT_USE (fd, _hurd_xattr_set (port, name, value, size, flags));\n\n  return err ? __hurd_dfail (fd, err) : 0;\n}",
    "setfsent": "setfsent (void){\n  return fstab_init (1) != NULL;\n}",
    "getfsent": "*\ngetfsent (void){\n  struct fstab_state *state;\n\n  state = fstab_init (0);\n  if (state == NULL)\n    return NULL;\n  if (fstab_fetch (state) == NULL)\n    return NULL;\n  return fstab_convert (state);\n}",
    "getfsspec": "*\ngetfsspec (const char *name){\n  struct fstab_state *state;\n  struct mntent *m;\n\n  state = fstab_init (1);\n  if (state == NULL)\n    return NULL;\n  while ((m = fstab_fetch (state)) != NULL)\n    if (strcmp (m->mnt_fsname, name) == 0)\n      return fstab_convert (state);\n  return NULL;\n}",
    "getfsfile": "*\ngetfsfile (const char *name){\n  struct fstab_state *state;\n  struct mntent *m;\n\n  state = fstab_init (1);\n  if (state == NULL)\n    return NULL;\n  while ((m = fstab_fetch (state)) != NULL)\n    if (strcmp (m->mnt_dir, name) == 0)\n      return fstab_convert (state);\n  return NULL;\n}",
    "endfsent": "endfsent (void){\n  struct fstab_state *state;\n\n  state = &fstab_state;\n  if (state->fs_fp != NULL)\n    {\n      (void) __endmntent (state->fs_fp);\n      state->fs_fp = NULL;\n    }\n}",
    "fsync": "fsync (int fd){\n  return SYSCALL_CANCEL (fsync, fd);\n}",
    "futimesat": "futimesat (int fd, const char *file, const struct timeval tvp[2]){\n  if (fd < 0\n      && (file == NULL\n          || (fd != AT_FDCWD && file[0] != '/')))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__getauxval": "__getauxval (unsigned long int type){\n  unsigned long int result;\n\n  if (__getauxval2 (type, &result))\n    return result;\n\n  __set_errno (ENOENT);\n  return 0;\n}",
    "getdomainname": "getdomainname (char *name, size_t len){\n  /* The NIS domain name is just the contents of the file /etc/nisdomain.  */\n  ssize_t n = _hurd_get_host_config (\"/etc/nisdomain\", name, len);\n  return n < 0 ? -1 : 0;\n}",
    "gethostid": "gethostid (void){\n  char hostname[MAXHOSTNAMELEN + 1];\n  struct hostent hostbuf, *hp;\n  int32_t id;\n  struct in_addr in;\n  int herr;\n  int fd;\n\n  /* First try to get the ID from a former invocation of sethostid.  */\n  fd = __open_nocancel (HOSTIDFILE, O_RDONLY|O_LARGEFILE, 0);\n  if (fd >= 0)\n    {\n      ssize_t n = __read_nocancel (fd, &id, sizeof (id));\n\n      __close_nocancel_nostatus (fd);\n\n      if (n == sizeof (id))\n\treturn id;\n    }\n\n  /* Getting from the file was not successful.  An intelligent guess\n     for a unique number of a host is its IP address.  To get the IP\n     address we need to know the host name.  */\n  if (__gethostname (hostname, MAXHOSTNAMELEN) < 0 || hostname[0] == '\\0')\n    /* This also fails.  Return and arbitrary value.  */\n    return 0;\n\n  /* Determine the IP address of the host name.  */\n  struct scratch_buffer tmpbuf;\n  scratch_buffer_init (&tmpbuf);\n  while (true)\n    {\n      int ret = __gethostbyname_r (hostname, &hostbuf,\n\t\t\t\t   tmpbuf.data, tmpbuf.length, &hp, &herr);\n      if (ret == 0 && hp != NULL)\n\tbreak;\n      else\n\t{\n\t  /* Enlarge the buffer on ERANGE.  */\n\t  if (ret != 0 && herr == NETDB_INTERNAL && errno == ERANGE)\n\t    {\n\t      if (!scratch_buffer_grow (&tmpbuf))\n\t\treturn 0;\n\t    }\n\t  /* Other errors are a failure.  Return an arbitrary value.  */\n\t  else\n\t    {\n\t      scratch_buffer_free (&tmpbuf);\n\t      return 0;\n\t    }\n\t}\n    }\n\n  in.s_addr = 0;\n  memcpy (&in, hp->h_addr,\n\t  (int) sizeof (in) < hp->h_length ? (int) sizeof (in) : hp->h_length);\n  scratch_buffer_free (&tmpbuf);\n  /* For the return value to be not exactly the IP address we do some\n     bit fiddling.  */\n  return (int32_t) (in.s_addr << 16 | in.s_addr >> 16);\n}",
    "getloadavg": "getloadavg (double loadavg[], int nelem){\n  struct sysinfo info;\n\n  if (__sysinfo (&info) != 0)\n    return -1;\n\n  nelem = CLAMP (nelem, 0, array_length (info.loads));\n\n  for (int i = 0; i < nelem; i++)\n    loadavg[i] = (double) info.loads[i] / SYSINFO_LOADS_SCALE;\n\n  return nelem;\n}",
    "__getpagesize": "__getpagesize (void){\n  int result;\n\n  if (GLRO(dl_pagesize) != 0)\n    return GLRO(dl_pagesize);\n\n  result = INTERNAL_SYSCALL_CALL (getpagesize);\n  /* The only possible error is ENOSYS.  */\n  if (!INTERNAL_SYSCALL_ERROR_P (result))\n    return result;\n\n  return 4096;\n}",
    "getpass": "*\ngetpass (const char *prompt){\n  FILE *in, *out;\n  struct termios s, t;\n  int tty_changed;\n  static char *buf;\n  static size_t bufsize;\n  ssize_t nread;\n\n  /* Try to write to and read from the terminal if we can.\n     If we can't open the terminal, use stderr and stdin.  */\n\n  in = fopen (\"/dev/tty\", \"w+ce\");\n  if (in == NULL)\n    {\n      in = stdin;\n      out = stderr;\n    }\n  else\n    {\n      /* We do the locking ourselves.  */\n      __fsetlocking (in, FSETLOCKING_BYCALLER);\n\n      out = in;\n    }\n\n  /* Make sure the stream we opened is closed even if the thread is\n     canceled.  */\n  __libc_cleanup_push (call_fclose, in == out ? in : NULL);\n\n  flockfile (out);\n\n  /* Turn echoing off if it is on now.  */\n\n  if (__tcgetattr (fileno (in), &t) == 0)\n    {\n      /* Save the old one. */\n      s = t;\n      /* Tricky, tricky. */\n      t.c_lflag &= ~(ECHO|ISIG);\n      tty_changed = (tcsetattr (fileno (in), TCSAFLUSH|TCSASOFT, &t) == 0);\n    }\n  else\n    tty_changed = 0;\n\n  /* Write the prompt.  */\n  __fxprintf (out, \"%s\", prompt);\n  __fflush_unlocked (out);\n\n  /* Read the password.  */\n  nread = __getline (&buf, &bufsize, in);\n  if (buf != NULL)\n    {\n      if (nread < 0)\n\tbuf[0] = '\\0';\n      else if (buf[nread - 1] == '\\n')\n\t{\n\t  /* Remove the newline.  */\n\t  buf[nread - 1] = '\\0';\n\t  if (tty_changed)\n\t    /* Write the newline that was not echoed.  */\n\t    __fxprintf (out, \"\\n\");\n\t}\n    }\n\n  /* Restore the original setting.  */\n  if (tty_changed)\n    (void) tcsetattr (fileno (in), TCSAFLUSH|TCSASOFT, &s);\n\n  funlockfile (out);\n\n  __libc_cleanup_pop (0);\n\n  if (in != stdin)\n    /* We opened the terminal; now close it.  */\n    fclose (in);\n\n  return buf;\n}",
    "getusershell": "*\ngetusershell (void){\n\tchar *ret;\n\n\tif (curshell == NULL)\n\t\tcurshell = initshells();\n\tret = *curshell;\n\tif (ret != NULL)\n\t\tcurshell++;\n\treturn (ret);\n}",
    "endusershell": "endusershell (void){\n\n\tfree(shells);\n\tshells = NULL;\n\tfree(strings);\n\tstrings = NULL;\n\tcurshell = NULL;\n}",
    "setusershell": "setusershell (void){\n\n\tcurshell = initshells();\n}",
    "getxattr": "getxattr (const char *path, const char *name, void *value, size_t size){\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_get (port, name, value, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "gtty": "gtty (int fd, struct sgttyb *params){\n  return __ioctl (fd, TIOCGETP, (void *) params);\n}",
    "hsearch": "*\nhsearch (ENTRY item, ACTION action){\n  ENTRY *result;\n\n  (void) __hsearch_r (item, action, &result, &htab);\n\n  return result;\n}",
    "hcreate": "hcreate (size_t nel){\n  return __hcreate_r (nel, &htab);\n}",
    "insque": "insque (void *elem, void *prev){\n  if (prev == NULL)\n    {\n      ((struct qelem *) elem)->q_forw = NULL;\n      ((struct qelem *) elem)->q_back = NULL;\n    }\n  else\n    {\n      struct qelem *next = ((struct qelem *) prev)->q_forw;\n      ((struct qelem *) prev)->q_forw = (struct qelem *) elem;\n      if (next != NULL)\n\tnext->q_back = (struct qelem *) elem;\n      ((struct qelem *) elem)->q_forw = next;\n      ((struct qelem *) elem)->q_back = (struct qelem *) prev;\n    }\n}",
    "remque": "remque (void *elem){\n  struct qelem *next = ((struct qelem *) elem)->q_forw;\n  struct qelem *prev = ((struct qelem *) elem)->q_back;\n  if (next != NULL)\n    next->q_back = prev;\n  if (prev != NULL)\n    prev->q_forw = (struct qelem *) next;\n}",
    "lgetxattr": "lgetxattr (const char *path, const char *name, void *value, size_t size){\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_get (port, name, value, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "listxattr": "listxattr (const char *path, char *list, size_t size){\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_list (port, list, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "llistxattr": "llistxattr (const char *path, char *list, size_t size){\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_list (port, list, &size);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "lremovexattr": "lremovexattr (const char *path, const char *name){\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_remove (port, name);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return __hurd_fail (err);\n}",
    "lsearch": "*\nlsearch (const void *key, void *base, size_t *nmemb, size_t size,\n\t __compar_fn_t compar){\n  void *result;\n\n  /* Try to find it.  */\n  result = lfind (key, base, nmemb, size, compar);\n  if (result == NULL)\n    {\n      /* Not available.  Insert at the end.  */\n      result = memcpy (base + (*nmemb) * size, key, size);\n      ++(*nmemb);\n    }\n\n  return result;\n}",
    "lfind": "*\nlfind (const void *key, const void *base, size_t *nmemb, size_t size,\n       __compar_fn_t compar){\n  const void *result = base;\n  size_t cnt = 0;\n\n  while (cnt < *nmemb && (*compar) (key, result) != 0)\n    {\n      result += size;\n      ++cnt;\n    }\n\n  return cnt < *nmemb ? (void *) result : NULL;\n}",
    "lsetxattr": "lsetxattr (const char *path, const char *name, const void *value, size_t size,\n\t   int flags){\n  error_t err;\n  file_t port = __file_name_lookup (path, O_NOLINK, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_set (port, name, value, size, flags);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return err ? __hurd_fail (err) : size;\n}",
    "__madvise": "__madvise (void *addr, size_t len, int advice){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mincore": "mincore (void *__start, size_t __len, unsigned char *__vec){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mkdtemp": "*\nmkdtemp (char *template){\n  if (__gen_tempname (template, 0, 0, __GT_DIR))\n    return NULL;\n  else\n    return template;\n}",
    "mkostemp": "mkostemp (char *template, int flags){\n  return __gen_tempname (template, 0, flags, __GT_FILE);\n}",
    "mkostemp64": "mkostemp64 (char *template, int flags){\n  return __gen_tempname (template, 0, flags | O_LARGEFILE, __GT_FILE);\n}",
    "mkostemps": "mkostemps (char *template, int suffixlen, int flags){\n  if (suffixlen < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __gen_tempname (template, suffixlen, flags, __GT_FILE);\n}",
    "mkostemps64": "mkostemps64 (char *template, int suffixlen, int flags){\n  if (suffixlen < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __gen_tempname (template, suffixlen, flags | O_LARGEFILE, __GT_FILE);\n}",
    "mkstemp": "mkstemp (char *template){\n  return __gen_tempname (template, 0, 0, __GT_FILE);\n}",
    "mkstemp64": "mkstemp64 (char *template){\n  return __gen_tempname (template, 0, O_LARGEFILE, __GT_FILE);\n}",
    "mkstemps": "mkstemps (char *template, int suffixlen){\n  if (suffixlen < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __gen_tempname (template, suffixlen, 0, __GT_FILE);\n}",
    "mkstemps64": "mkstemps64 (char *template, int suffixlen){\n  if (suffixlen < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __gen_tempname (template, suffixlen, O_LARGEFILE, __GT_FILE);\n}",
    "__mktemp": "*\n__mktemp (char *template){\n  if (__gen_tempname (template, 0, 0, __GT_NOCREATE) < 0)\n    /* We return the null string if we can't find a unique file name.  */\n    template[0] = '\\0';\n\n  return template;\n}",
    "mlock": "mlock (const void *addr, size_t len){\n  mach_port_t host;\n  vm_address_t page;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    host = __mach_host_self();\n\n  page = trunc_page ((vm_address_t) addr);\n  len = round_page ((vm_address_t) addr + len) - page;\n\n  err = __vm_wire (host, __mach_task_self (), page, len, VM_PROT_READ);\n  if (host != __mach_host_self())\n    __mach_port_deallocate (__mach_task_self (), host);\n\n  return err ? __hurd_fail (err) : 0;\n}",
    "mlockall": "mlockall (int flags){\n  mach_port_t host;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    return __hurd_fail (err);\n\n  err = __vm_wire_all (host, __mach_task_self (), flags);\n  __mach_port_deallocate (__mach_task_self (), host);\n  return err ? __hurd_fail (err) : 0;\n}",
    "__mmap": "*\n__mmap (void *addr, size_t len, int prot, int flags, int fd, off_t offset){\n  MMAP_CHECK_PAGE_UNIT ();\n\n  if (offset & MMAP_OFF_LOW_MASK)\n    return (void *) INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n#ifdef __NR_mmap2\n  return (void *) MMAP_CALL (mmap2, addr, len, prot, flags, fd,\n\t\t\t     offset / (uint32_t) MMAP2_PAGE_UNIT);\n#else\n  return (void *) MMAP_CALL (mmap, addr, len, prot, flags, fd,\n\t\t\t     MMAP_ADJUST_OFFSET (offset));\n#endif\n}",
    "getmntent": "*\ngetmntent (FILE *stream){\n  struct mntent_buffer *buffer = allocate_once (&mntent_buffer,\n\t\t\t\t\t\tallocate, deallocate, NULL);\n  if (buffer == NULL)\n    /* If no core is available we don't have a chance to run the\n       program successfully and so returning NULL is an acceptable\n       result.  */\n    return NULL;\n\n  return __getmntent_r (stream, &buffer->m,\n\t\t\tbuffer->buffer, sizeof (buffer->buffer));\n}",
    "__setmntent": "*\n__setmntent (const char *file, const char *mode){\n  /* Extend the mode parameter with \"c\" to disable cancellation in the\n     I/O functions and \"e\" to set FD_CLOEXEC.  */\n  size_t modelen = strlen (mode);\n  char newmode[modelen + 3];\n  memcpy (mempcpy (newmode, mode, modelen), \"ce\", 3);\n  FILE *result = fopen (file, newmode);\n\n  if (result != NULL)\n    /* We do the locking ourselves.  */\n    __fsetlocking (result, FSETLOCKING_BYCALLER);\n\n  return result;\n}",
    "__getmntent_r": "*\n__getmntent_r (FILE *stream, struct mntent *mp, char *buffer, int bufsiz){\n  struct mntent *result;\n\n  flockfile (stream);\n  while (true)\n    if (get_mnt_entry (stream, mp, buffer, bufsiz))\n      {\n\t/* If the file system is autofs look for a mount option hint\n\t   (\"ignore\") to skip the entry.  */\n\tif (strcmp (mp->mnt_type, \"autofs\") == 0 && __hasmntopt (mp, \"ignore\"))\n\t  memset (mp, 0, sizeof (*mp));\n\telse\n\t  {\n\t    result = mp;\n\t    break;\n\t  }\n      }\n    else\n      {\n\tresult = NULL;\n\tbreak;\n      }\n  funlockfile (stream);\n\n  return result;\n}",
    "__mprotect": "__mprotect (void *addr, size_t len, int prot){\n  kern_return_t err;\n  vm_prot_t vmprot;\n\n  vmprot = VM_PROT_NONE;\n  if (prot & PROT_READ)\n    vmprot |= VM_PROT_READ;\n  if (prot & PROT_WRITE)\n    vmprot |= VM_PROT_WRITE;\n  if (prot & PROT_EXEC)\n    vmprot |= VM_PROT_EXECUTE;\n\n  if (err = __vm_protect (__mach_task_self (),\n\t\t\t  (vm_address_t) addr, (vm_size_t) len,\n\t\t\t  0, vmprot))\n    {\n      errno = err;\n      return -1;\n    }\n  return 0;\n}",
    "msync": "msync (void *addr, size_t length, int flags){\n  return SYSCALL_CANCEL (msync, addr, length, flags);\n}",
    "munlock": "munlock (const void *addr, size_t len){\n  mach_port_t host;\n  vm_address_t page;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    host = __mach_host_self();\n\n  page = trunc_page ((vm_address_t) addr);\n  len = round_page ((vm_address_t) addr + len) - page;\n\n  err = __vm_wire (host, __mach_task_self (), page, len, VM_PROT_NONE);\n  if (host != __mach_host_self())\n    __mach_port_deallocate (__mach_task_self (), host);\n\n  return err ? __hurd_fail (err) : 0;\n}",
    "munlockall": "munlockall (void){\n  mach_port_t host;\n  error_t err;\n\n  err = __get_privileged_ports (&host, NULL);\n  if (err)\n    return __hurd_fail (err);\n\n  err = __vm_wire_all (host, __mach_task_self (), VM_WIRE_NONE);\n  __mach_port_deallocate (__mach_task_self (), host);\n  return err ? __hurd_fail (err) : 0;\n}",
    "__munmap": "__munmap (void *addr, size_t len){\n  kern_return_t err;\n\n  if (addr == 0)\n    {\n      errno = EINVAL;\n      return -1;\n    }\n\n  if (err = __vm_deallocate (__mach_task_self (),\n\t\t\t     (vm_address_t) addr, (vm_size_t) len))\n    {\n      errno = err;\n      return -1;\n    }\n  return 0;\n}",
    "preadv": "preadv (int fd, const struct iovec *vector, int count, off_t offset){\n  ssize_t result = SYSCALL_CANCEL (preadv, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset));\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n  return __atomic_preadv_replacement (fd, vector, count, offset);\n}",
    "preadv2": "preadv2 (int fd, const struct iovec *vector, int count, off_t offset,\n\t int flags){\n  ssize_t result = SYSCALL_CANCEL (preadv2, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset), flags);\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n\n  /* Trying to emulate the preadv2 syscall flags is troublesome:\n\n     * We can not temporary change the file state of the O_DSYNC and O_SYNC\n       flags to emulate RWF_{D}SYNC (attempts to change the state of using\n       fcntl are silently ignored).\n\n     * IOCB_HIPRI requires the file opened in O_DIRECT and uses an internal\n       semantic not provided by any other flag (O_NONBLOCK for instance).  */\n\n  if (flags != 0)\n    {\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n  if (offset == -1)\n    return __readv (fd, vector, count);\n  else\n    return preadv (fd, vector, count, offset);\n}",
    "preadv64": "preadv64 (int fd, const struct iovec *vector, int count, off64_t offset){\n  ssize_t result = SYSCALL_CANCEL (preadv, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset));\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n  return __atomic_preadv64_replacement (fd, vector, count, offset);\n}",
    "preadv64v2": "preadv64v2 (int fd, const struct iovec *vector, int count, off64_t offset,\n\t    int flags){\n  ssize_t result = SYSCALL_CANCEL (preadv2, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset), flags);\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n\n  /* Trying to emulate the preadv2 syscall flags is troublesome:\n\n     * We can not temporary change the file state of the O_DSYNC and O_SYNC\n       flags to emulate RWF_{D}SYNC (attempts to change the state of using\n       fcntl are silently ignored).\n\n     * IOCB_HIPRI requires the file opened in O_DIRECT and uses an internal\n       semantic not provided by any other flag (O_NONBLOCK for instance).  */\n\n  if (flags != 0)\n    {\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n\n  if (offset == -1)\n    return __readv (fd, vector, count);\n  else\n    return preadv64 (fd, vector, count, offset);\n}",
    "ptrace": "ptrace (enum __ptrace_request request, ...){\n  long int res, ret;\n  va_list ap;\n  pid_t pid;\n  void *addr, *data;\n\n  va_start (ap, request);\n  pid = va_arg (ap, pid_t);\n  addr = va_arg (ap, void *);\n  data = va_arg (ap, void *);\n  va_end (ap);\n\n  if (request > 0 && request < 4)\n    data = &ret;\n\n  res = INLINE_SYSCALL (ptrace, 4, request, pid, addr, data);\n  if (res >= 0 && request > 0 && request < 4)\n    {\n      __set_errno (0);\n      return ret;\n    }\n\n  return res;\n}",
    "pwritev": "pwritev (int fd, const struct iovec *vector, int count, off_t offset){\n  ssize_t result = SYSCALL_CANCEL (pwritev, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset));\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n  return __atomic_pwritev_replacement (fd, vector, count, offset);\n}",
    "pwritev2": "pwritev2 (int fd, const struct iovec *vector, int count, off_t offset,\n\t  int flags){\n\n  ssize_t result = SYSCALL_CANCEL (pwritev2, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset), flags);\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n\n  /* Trying to emulate the pwritev2 syscall flags is troublesome:\n\n     * We can not temporary change the file state of the O_DSYNC and O_SYNC\n       flags to emulate RWF_{D}SYNC (attempts to change the state of using\n       fcntl are silently ignored).\n\n     * IOCB_HIPRI requires the file opened in O_DIRECT and uses an internal\n       semantic not provided by any other flag (O_NONBLOCK for instance).  */\n\n  if (flags != 0)\n    {\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n  if (offset == -1)\n    return __writev (fd, vector, count);\n  else\n    return pwritev (fd, vector, count, offset);\n}",
    "pwritev64": "pwritev64 (int fd, const struct iovec *vector, int count, off64_t offset){\n  ssize_t result = SYSCALL_CANCEL (pwritev, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset));\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n  return __atomic_pwritev64_replacement (fd, vector, count, offset);\n}",
    "pwritev64v2": "pwritev64v2 (int fd, const struct iovec *vector, int count, off64_t offset,\n\t     int flags){\n  ssize_t result = SYSCALL_CANCEL (pwritev2, fd, vector, count,\n\t\t\t\t   LO_HI_LONG (offset), flags);\n  if (result >= 0 || errno != ENOSYS)\n    return result;\n\n  /* Trying to emulate the pwritev2 syscall flags is troublesome:\n\n     * We can not temporary change the file state of the O_DSYNC and O_SYNC\n       flags to emulate RWF_{D}SYNC (attempts to change the state of using\n       fcntl are silently ignored).\n\n     * IOCB_HIPRI requires the file opened in O_DIRECT and uses an internal\n       semantic not provided by any other flag (O_NONBLOCK for instance).  */\n\n  if (flags != 0)\n    {\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n  if (offset == -1)\n    return __writev (fd, vector, count);\n  else\n    return pwritev64 (fd, vector, count, offset);\n}",
    "reboot": "reboot (int howto){\n  return INLINE_SYSCALL (reboot, 3, (int) 0xfee1dead, 672274793, howto);\n}",
    "step": "step (const char *string, const char *expbuf){\n  regmatch_t match;\t/* We only need info about the full match.  */\n\n  expbuf += __alignof (regex_t *);\n  expbuf -= ((uintptr_t) expbuf) % __alignof__ (regex_t *);\n\n  if (__regexec ((const regex_t *) expbuf, string, 1, &match, REG_NOTEOL)\n      == REG_NOMATCH)\n    return 0;\n\n  loc1 = (char *) string + match.rm_so;\n  loc2 = (char *) string + match.rm_eo;\n  return 1;\n}",
    "advance": "advance (const char *string, const char *expbuf){\n  regmatch_t match;\t/* We only need info about the full match.  */\n\n  expbuf += __alignof__ (regex_t *);\n  expbuf -= ((uintptr_t) expbuf) % __alignof__ (regex_t *);\n\n  if (__regexec ((const regex_t *) expbuf, string, 1, &match, REG_NOTEOL)\n      == REG_NOMATCH\n      /* We have to check whether the check is at the beginning of the\n\t buffer.  */\n      || match.rm_so != 0)\n    return 0;\n\n  loc2 = (char *) string + match.rm_eo;\n  return 1;\n}",
    "removexattr": "removexattr (const char *path, const char *name){\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_remove (port, name);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return __hurd_fail (err);\n}",
    "__sbrk": "*\n__sbrk (intptr_t increment){\n  void *result;\n\n  HURD_CRITICAL_BEGIN;\n  __mutex_lock (&_hurd_brk_lock);\n  result = (void *) _hurd_brk;\n  if (increment != 0 && _hurd_set_brk (_hurd_brk + increment) < 0)\n    result = (void *) -1;\n  __mutex_unlock (&_hurd_brk_lock);\n  HURD_CRITICAL_END;\n\n  return result;\n}",
    "__select": "__select (int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,\n\t  struct timeval *timeout){\n  struct __timeval64 tv64, *ptv64 = NULL;\n  if (timeout != NULL)\n    {\n      tv64 = valid_timeval_to_timeval64 (*timeout);\n      ptv64 = &tv64;\n    }\n  int r = __select64 (nfds, readfds, writefds, exceptfds, ptv64);\n  if (timeout != NULL)\n    /* The remanining timeout will be always less the input TIMEOUT.  */\n    *timeout = valid_timeval64_to_timeval (tv64);\n  return r;\n}",
    "setdomainname": "setdomainname (const char *name, size_t len){\n  /* The NIS domain name is just the contents of the file /etc/nisdomain.  */\n  ssize_t n = _hurd_set_host_config (\"/etc/nisdomain\", name, len);\n  return n < 0 ? -1 : 0;\n}",
    "setegid": "setegid (gid_t gid){\n  int result;\n\n  if (gid == (gid_t) ~0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n#ifdef __NR_setresgid32\n  result = INLINE_SETXID_SYSCALL (setresgid32, 3, -1, gid, -1);\n#else\n  result = INLINE_SETXID_SYSCALL (setresgid, 3, -1, gid, -1);\n#endif\n\n  return result;\n}",
    "seteuid": "seteuid (uid_t uid){\n  int result;\n\n  if (uid == (uid_t) ~0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n#ifdef __NR_setresuid32\n  result = INLINE_SETXID_SYSCALL (setresuid32, 3, -1, uid, -1);\n#else\n  result = INLINE_SETXID_SYSCALL (setresuid, 3, -1, uid, -1);\n#endif\n\n  return result;\n}",
    "sethostid": "sethostid (long int id){\n  int fd;\n  ssize_t written;\n  int32_t id32 = id;\n\n  /* Test for appropriate rights to set host ID.  */\n  if (__libc_enable_secure)\n    {\n      __set_errno (EPERM);\n      return -1;\n    }\n\n  /* Make sure the ID is not too large.  Needed for bi-arch support.   */\n  if (id32 != id)\n    {\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n\n  /* Open file for writing.  Everybody is allowed to read this file.  */\n  fd = __open_nocancel (HOSTIDFILE, O_CREAT|O_WRONLY|O_TRUNC, 0644);\n  if (fd < 0)\n    return -1;\n\n  written = __write_nocancel (fd, &id32, sizeof (id32));\n\n  __close_nocancel_nostatus (fd);\n\n  return written != sizeof (id32) ? -1 : 0;\n}",
    "sethostname": "sethostname (const char *name, size_t len){\n  /* The host name is just the contents of the file /etc/hostname.  */\n  ssize_t n = _hurd_set_host_config (\"/etc/hostname\", name, len);\n  return n < 0 ? -1 : 0;\n}",
    "setxattr": "setxattr (const char *path, const char *name, const void *value, size_t size,\n\t  int flags){\n  error_t err;\n  file_t port = __file_name_lookup (path, 0, 0);\n  if (port == MACH_PORT_NULL)\n    return -1;\n  err = _hurd_xattr_set (port, name, value, size, flags);\n  __mach_port_deallocate (__mach_task_self (), port);\n  return __hurd_fail (err);\n}",
    "sstk": "* attribute_compat_text_section\nsstk (int increment){\n  __set_errno (ENOSYS);\n  return (void *) -1;\n}",
    "stty": "stty (int fd, const struct sgttyb *params){\n  return __ioctl (fd, TIOCSETP, (void *) params);\n}",
    "swapoff": "swapoff (const char *path){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "swapon": "swapon (const char *path, int flags){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sync": "sync (void){\n  /* This is not actually synchronous; we don't wait.  */\n  error_t err = __USEPORT (CRDIR, __file_syncfs (port, 0, 1));\n  if (err)\n    (void) __hurd_fail (err);\n}",
    "syncfs": "syncfs (int fd){\n  error_t err = HURD_DPORT_USE (fd, __file_syncfs (port, 1, 0));\n  if (err)\n    return __hurd_dfail (fd, err);\n  return 0;\n}",
    "syscall": "syscall (long int syscall_number, long int arg1, long int arg2, long int arg3,\n\t long int arg4, long int arg5, long int arg6, long int arg7){\n  long int ret;\n\n  ret = INTERNAL_SYSCALL_NCS_CALL (syscall_number, arg1, arg2, arg3, arg4,\n\t\t\t\t   arg5, arg6, arg7);\n\n  if (INTERNAL_SYSCALL_ERROR_P (ret))\n    return __syscall_error (ret);\n\n  return ret;\n}",
    "__vsyslog_chk": "attribute_hidden\n__vsyslog_chk (int pri, int flag, const char *fmt, va_list ap){\n  __nldbl___vsyslog_chk (pri, flag, fmt, ap);\n}",
    "openlog": "openlog (const char *ident, int logstat, int logfac){\n  /* Protect against multiple users and cancellation.  */\n  __libc_cleanup_push (cancel_handler, NULL);\n  __libc_lock_lock (syslog_lock);\n\n  openlog_internal (ident, logstat, logfac);\n\n  __libc_cleanup_pop (1);\n}",
    "closelog": "closelog (void){\n  /* Protect against multiple users and cancellation.  */\n  __libc_cleanup_push (cancel_handler, NULL);\n  __libc_lock_lock (syslog_lock);\n\n  closelog_internal ();\n  LogTag = NULL;\n  LogType = SOCK_DGRAM; /* this is the default */\n\n  /* Free the lock.  */\n  __libc_cleanup_pop (1);\n}",
    "setlogmask": "setlogmask (int pmask){\n  int omask;\n\n  /* Protect against multiple users.  */\n  __libc_lock_lock (syslog_lock);\n\n  omask = LogMask;\n  if (pmask != 0)\n    LogMask = pmask;\n\n  __libc_lock_unlock (syslog_lock);\n\n  return (omask);\n}",
    "truncate64": "truncate64 (const char *path, off64_t length){\n  if ((off_t) length != length)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  return __truncate (path, (off_t) length);\n}",
    "__tsearch": "*\n__tsearch (const void *key, void **vrootp, __compar_fn_t compar){\n  node q, root;\n  node *parentp = NULL, *gparentp = NULL;\n  node *rootp = (node *) vrootp;\n  node *nextp;\n  int r = 0, p_r = 0, gp_r = 0; /* No they might not, Mr Compiler.  */\n\n#ifdef USE_MALLOC_LOW_BIT\n  static_assert (alignof (max_align_t) > 1, \"malloc must return aligned ptrs\");\n#endif\n\n  if (rootp == NULL)\n    return NULL;\n\n  /* This saves some additional tests below.  */\n  root = DEREFNODEPTR(rootp);\n  if (root != NULL)\n    SETBLACK(root);\n\n  CHECK_TREE (root);\n\n  nextp = rootp;\n  while (DEREFNODEPTR(nextp) != NULL)\n    {\n      root = DEREFNODEPTR(rootp);\n      r = (*compar) (key, root->key);\n      if (r == 0)\n\treturn root;\n\n      maybe_split_for_insert (rootp, parentp, gparentp, p_r, gp_r, 0);\n      /* If that did any rotations, parentp and gparentp are now garbage.\n\t That doesn't matter, because the values they contain are never\n\t used again in that case.  */\n\n      nextp = r < 0 ? LEFTPTR(root) : RIGHTPTR(root);\n      if (DEREFNODEPTR(nextp) == NULL)\n\tbreak;\n\n      gparentp = parentp;\n      parentp = rootp;\n      rootp = nextp;\n\n      gp_r = p_r;\n      p_r = r;\n    }\n\n  q = (struct node_t *) malloc (sizeof (struct node_t));\n  if (q != NULL)\n    {\n      /* Make sure the malloc implementation returns naturally aligned\n\t memory blocks when expected.  Or at least even pointers, so we\n\t can use the low bit as red/black flag.  Even though we have a\n\t static_assert to make sure alignof (max_align_t) > 1 there could\n\t be an interposed malloc implementation that might cause havoc by\n\t not obeying the malloc contract.  */\n#ifdef USE_MALLOC_LOW_BIT\n      assert (((uintptr_t) q & (uintptr_t) 0x1) == 0);\n#endif\n      SETNODEPTR(nextp,q);\t\t/* link new node to old */\n      q->key = key;\t\t\t/* initialize new node */\n      SETRED(q);\n      SETLEFT(q,NULL);\n      SETRIGHT(q,NULL);\n\n      if (nextp != rootp)\n\t/* There may be two red edges in a row now, which we must avoid by\n\t   rotating the tree.  */\n\tmaybe_split_for_insert (nextp, rootp, parentp, r, p_r, 1);\n    }\n\n  return q;\n}",
    "__tfind": "void *\n__tfind (const void *key, void *const *vrootp, __compar_fn_t compar){\n  node root;\n  node *rootp = (node *) vrootp;\n\n  if (rootp == NULL)\n    return NULL;\n\n  root = DEREFNODEPTR(rootp);\n  CHECK_TREE (root);\n\n  while (DEREFNODEPTR(rootp) != NULL)\n    {\n      root = DEREFNODEPTR(rootp);\n      int r;\n\n      r = (*compar) (key, root->key);\n      if (r == 0)\n\treturn root;\n\n      rootp = r < 0 ? LEFTPTR(root) : RIGHTPTR(root);\n    }\n  return NULL;\n}",
    "__tdelete": "void *\n__tdelete (const void *key, void **vrootp, __compar_fn_t compar){\n  node p, q, r, retval;\n  int cmp;\n  node *rootp = (node *) vrootp;\n  node root, unchained;\n  /* Stack of nodes so we remember the parents without recursion.  It's\n     _very_ unlikely that there are paths longer than 40 nodes.  The tree\n     would need to have around 250.000 nodes.  */\n  int stacksize = 40;\n  int sp = 0;\n  node **nodestack = alloca (sizeof (node *) * stacksize);\n\n  if (rootp == NULL)\n    return NULL;\n  p = DEREFNODEPTR(rootp);\n  if (p == NULL)\n    return NULL;\n\n  CHECK_TREE (p);\n\n  root = DEREFNODEPTR(rootp);\n  while ((cmp = (*compar) (key, root->key)) != 0)\n    {\n      if (sp == stacksize)\n\t{\n\t  node **newstack;\n\t  stacksize += 20;\n\t  newstack = alloca (sizeof (node *) * stacksize);\n\t  nodestack = memcpy (newstack, nodestack, sp * sizeof (node *));\n\t}\n\n      nodestack[sp++] = rootp;\n      p = DEREFNODEPTR(rootp);\n      if (cmp < 0)\n\t{\n\t  rootp = LEFTPTR(p);\n\t  root = LEFT(p);\n\t}\n      else\n\t{\n\t  rootp = RIGHTPTR(p);\n\t  root = RIGHT(p);\n\t}\n      if (root == NULL)\n\treturn NULL;\n    }\n\n  /* This is bogus if the node to be deleted is the root... this routine\n     really should return an integer with 0 for success, -1 for failure\n     and errno = ESRCH or something.  */\n  retval = p;\n\n  /* We don't unchain the node we want to delete. Instead, we overwrite\n     it with its successor and unchain the successor.  If there is no\n     successor, we really unchain the node to be deleted.  */\n\n  root = DEREFNODEPTR(rootp);\n\n  r = RIGHT(root);\n  q = LEFT(root);\n\n  if (q == NULL || r == NULL)\n    unchained = root;\n  else\n    {\n      node *parentp = rootp, *up = RIGHTPTR(root);\n      node upn;\n      for (;;)\n\t{\n\t  if (sp == stacksize)\n\t    {\n\t      node **newstack;\n\t      stacksize += 20;\n\t      newstack = alloca (sizeof (node *) * stacksize);\n\t      nodestack = memcpy (newstack, nodestack, sp * sizeof (node *));\n\t    }\n\t  nodestack[sp++] = parentp;\n\t  parentp = up;\n\t  upn = DEREFNODEPTR(up);\n\t  if (LEFT(upn) == NULL)\n\t    break;\n\t  up = LEFTPTR(upn);\n\t}\n      unchained = DEREFNODEPTR(up);\n    }\n\n  /* We know that either the left or right successor of UNCHAINED is NULL.\n     R becomes the other one, it is chained into the parent of UNCHAINED.  */\n  r = LEFT(unchained);\n  if (r == NULL)\n    r = RIGHT(unchained);\n  if (sp == 0)\n    SETNODEPTR(rootp,r);\n  else\n    {\n      q = DEREFNODEPTR(nodestack[sp-1]);\n      if (unchained == RIGHT(q))\n\tSETRIGHT(q,r);\n      else\n\tSETLEFT(q,r);\n    }\n\n  if (unchained != root)\n    root->key = unchained->key;\n  if (!RED(unchained))\n    {\n      /* Now we lost a black edge, which means that the number of black\n\t edges on every path is no longer constant.  We must balance the\n\t tree.  */\n      /* NODESTACK now contains all parents of R.  R is likely to be NULL\n\t in the first iteration.  */\n      /* NULL nodes are considered black throughout - this is necessary for\n\t correctness.  */\n      while (sp > 0 && (r == NULL || !RED(r)))\n\t{\n\t  node *pp = nodestack[sp - 1];\n\t  p = DEREFNODEPTR(pp);\n\t  /* Two symmetric cases.  */\n\t  if (r == LEFT(p))\n\t    {\n\t      /* Q is R's brother, P is R's parent.  The subtree with root\n\t\t R has one black edge less than the subtree with root Q.  */\n\t      q = RIGHT(p);\n\t      if (RED(q))\n\t\t{\n\t\t  /* If Q is red, we know that P is black. We rotate P left\n\t\t     so that Q becomes the top node in the tree, with P below\n\t\t     it.  P is colored red, Q is colored black.\n\t\t     This action does not change the black edge count for any\n\t\t     leaf in the tree, but we will be able to recognize one\n\t\t     of the following situations, which all require that Q\n\t\t     is black.  */\n\t\t  SETBLACK(q);\n\t\t  SETRED(p);\n\t\t  /* Left rotate p.  */\n\t\t  SETRIGHT(p,LEFT(q));\n\t\t  SETLEFT(q,p);\n\t\t  SETNODEPTR(pp,q);\n\t\t  /* Make sure pp is right if the case below tries to use\n\t\t     it.  */\n\t\t  nodestack[sp++] = pp = LEFTPTR(q);\n\t\t  q = RIGHT(p);\n\t\t}\n\t      /* We know that Q can't be NULL here.  We also know that Q is\n\t\t black.  */\n\t      if ((LEFT(q) == NULL || !RED(LEFT(q)))\n\t\t  && (RIGHT(q) == NULL || !RED(RIGHT(q))))\n\t\t{\n\t\t  /* Q has two black successors.  We can simply color Q red.\n\t\t     The whole subtree with root P is now missing one black\n\t\t     edge.  Note that this action can temporarily make the\n\t\t     tree invalid (if P is red).  But we will exit the loop\n\t\t     in that case and set P black, which both makes the tree\n\t\t     valid and also makes the black edge count come out\n\t\t     right.  If P is black, we are at least one step closer\n\t\t     to the root and we'll try again the next iteration.  */\n\t\t  SETRED(q);\n\t\t  r = p;\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Q is black, one of Q's successors is red.  We can\n\t\t     repair the tree with one operation and will exit the\n\t\t     loop afterwards.  */\n\t\t  if (RIGHT(q) == NULL || !RED(RIGHT(q)))\n\t\t    {\n\t\t      /* The left one is red.  We perform the same action as\n\t\t\t in maybe_split_for_insert where two red edges are\n\t\t\t adjacent but point in different directions:\n\t\t\t Q's left successor (let's call it Q2) becomes the\n\t\t\t top of the subtree we are looking at, its parent (Q)\n\t\t\t and grandparent (P) become its successors. The former\n\t\t\t successors of Q2 are placed below P and Q.\n\t\t\t P becomes black, and Q2 gets the color that P had.\n\t\t\t This changes the black edge count only for node R and\n\t\t\t its successors.  */\n\t\t      node q2 = LEFT(q);\n\t\t      if (RED(p))\n\t\t\tSETRED(q2);\n\t\t      else\n\t\t\tSETBLACK(q2);\n\t\t      SETRIGHT(p,LEFT(q2));\n\t\t      SETLEFT(q,RIGHT(q2));\n\t\t      SETRIGHT(q2,q);\n\t\t      SETLEFT(q2,p);\n\t\t      SETNODEPTR(pp,q2);\n\t\t      SETBLACK(p);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* It's the right one.  Rotate P left. P becomes black,\n\t\t\t and Q gets the color that P had.  Q's right successor\n\t\t\t also becomes black.  This changes the black edge\n\t\t\t count only for node R and its successors.  */\n\t\t      if (RED(p))\n\t\t\tSETRED(q);\n\t\t      else\n\t\t\tSETBLACK(q);\n\t\t      SETBLACK(p);\n\n\t\t      SETBLACK(RIGHT(q));\n\n\t\t      /* left rotate p */\n\t\t      SETRIGHT(p,LEFT(q));\n\t\t      SETLEFT(q,p);\n\t\t      SETNODEPTR(pp,q);\n\t\t    }\n\n\t\t  /* We're done.  */\n\t\t  sp = 1;\n\t\t  r = NULL;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      /* Comments: see above.  */\n\t      q = LEFT(p);\n\t      if (RED(q))\n\t\t{\n\t\t  SETBLACK(q);\n\t\t  SETRED(p);\n\t\t  SETLEFT(p,RIGHT(q));\n\t\t  SETRIGHT(q,p);\n\t\t  SETNODEPTR(pp,q);\n\t\t  nodestack[sp++] = pp = RIGHTPTR(q);\n\t\t  q = LEFT(p);\n\t\t}\n\t      if ((RIGHT(q) == NULL || !RED(RIGHT(q)))\n\t\t  && (LEFT(q) == NULL || !RED(LEFT(q))))\n\t\t{\n\t\t  SETRED(q);\n\t\t  r = p;\n\t\t}\n\t      else\n\t\t{\n\t\t  if (LEFT(q) == NULL || !RED(LEFT(q)))\n\t\t    {\n\t\t      node q2 = RIGHT(q);\n\t\t      if (RED(p))\n\t\t\tSETRED(q2);\n\t\t      else\n\t\t\tSETBLACK(q2);\n\t\t      SETLEFT(p,RIGHT(q2));\n\t\t      SETRIGHT(q,LEFT(q2));\n\t\t      SETLEFT(q2,q);\n\t\t      SETRIGHT(q2,p);\n\t\t      SETNODEPTR(pp,q2);\n\t\t      SETBLACK(p);\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if (RED(p))\n\t\t\tSETRED(q);\n\t\t      else\n\t\t\tSETBLACK(q);\n\t\t      SETBLACK(p);\n\t\t      SETBLACK(LEFT(q));\n\t\t      SETLEFT(p,RIGHT(q));\n\t\t      SETRIGHT(q,p);\n\t\t      SETNODEPTR(pp,q);\n\t\t    }\n\t\t  sp = 1;\n\t\t  r = NULL;\n\t\t}\n\t    }\n\t  --sp;\n\t}\n      if (r != NULL)\n\tSETBLACK(r);\n    }\n\n  free (unchained);\n  return retval;\n}",
    "__twalk": "__twalk (const void *vroot, __action_fn_t action){\n  const_node root = (const_node) vroot;\n\n  CHECK_TREE ((node) root);\n\n  if (root != NULL && action != NULL)\n    trecurse (root, action, 0);\n}",
    "__twalk_r": "__twalk_r (const void *vroot, void (*action) (const void *, VISIT, void *),\n\t   void *closure){\n  const_node root = (const_node) vroot;\n\n  CHECK_TREE ((node) root);\n\n  if (root != NULL && action != NULL)\n    trecurse_r (root, action, closure);\n}",
    "ttyslot": "ttyslot (void){\n\tstruct ttyent *ttyp;\n\tint slot;\n\tchar *p;\n\tint cnt;\n\tsize_t buflen = __sysconf (_SC_TTY_NAME_MAX) + 1;\n\tchar *name;\n\n\tif (buflen == 0)\n\t  /* This should be enough if no fixed value is given.  */\n\t  buflen = 32;\n\n\tname = __alloca (buflen);\n\n\t__setttyent();\n\tfor (cnt = 0; cnt < 3; ++cnt)\n\t\tif (__ttyname_r (cnt, name, buflen) == 0) {\n\t\t\tif ((p = strrchr (name, '/')))\n\t\t\t\t++p;\n\t\t\telse\n\t\t\t\tp = name;\n\t\t\tfor (slot = 1; (ttyp = __getttyent()); ++slot)\n\t\t\t\tif (!strcmp(ttyp->ty_name, p)) {\n\t\t\t\t\t__endttyent();\n\t\t\t\t\treturn(slot);\n\t\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t__endttyent();\n\treturn(0);\n}",
    "ualarm": "ualarm (useconds_t value, useconds_t interval){\n  struct itimerval timer, otimer;\n\n  timer.it_value.tv_sec = 0;\n  timer.it_value.tv_usec = value;\n  timer.it_interval.tv_sec = 0;\n  timer.it_interval.tv_usec = interval;\n\n  if (__setitimer (ITIMER_REAL, &timer, &otimer) < 0)\n    return -1;\n\n  return (otimer.it_value.tv_sec * 1000000) + otimer.it_value.tv_usec;\n}",
    "__libc_unwind_link_get": "*\n__libc_unwind_link_get (void){\n  /* Double-checked locking idiom.  Synchronizes with the release MO\n     store at the end of this function.  */\n  if (atomic_load_acquire (&global_libgcc_handle) != NULL)\n   return &global;\n\n  /* Initialize a copy of the data, so that we do not need about\n     unlocking in case the dynamic loader somehow triggers\n     unwinding.  */\n  void *local_libgcc_handle = __libc_dlopen (LIBGCC_S_SO);\n  if (local_libgcc_handle == NULL)\n    {\n      __libc_lock_unlock (lock);\n      return NULL;\n    }\n\n  struct unwind_link local;\n  local.ptr__Unwind_Backtrace\n    = __libc_dlsym (local_libgcc_handle, \"_Unwind_Backtrace\");\n  local.ptr__Unwind_ForcedUnwind\n    = __libc_dlsym (local_libgcc_handle, \"_Unwind_ForcedUnwind\");\n  local.ptr__Unwind_GetCFA\n    = __libc_dlsym (local_libgcc_handle, \"_Unwind_GetCFA\");\n#if UNWIND_LINK_GETIP\n  local.ptr__Unwind_GetIP\n    = __libc_dlsym (local_libgcc_handle, \"_Unwind_GetIP\");\n#endif\n  local.ptr__Unwind_Resume\n    = __libc_dlsym (local_libgcc_handle, \"_Unwind_Resume\");\n#if UNWIND_LINK_FRAME_STATE_FOR\n  local.ptr___frame_state_for\n    = __libc_dlsym (local_libgcc_handle, \"__frame_state_for\");\n#endif\n  local.ptr_personality\n    = __libc_dlsym (local_libgcc_handle, \"__gcc_personality_v0\");\n  UNWIND_LINK_EXTRA_INIT\n\n  /* If a symbol is missing, libgcc_s has somehow been corrupted.  */\n  assert (local.ptr__Unwind_Backtrace != NULL);\n  assert (local.ptr__Unwind_ForcedUnwind != NULL);\n  assert (local.ptr__Unwind_GetCFA != NULL);\n#if UNWIND_LINK_GETIP\n  assert (local.ptr__Unwind_GetIP != NULL);\n#endif\n  assert (local.ptr__Unwind_Resume != NULL);\n  assert (local.ptr_personality != NULL);\n\n  PTR_MANGLE (local.ptr__Unwind_Backtrace);\n  PTR_MANGLE (local.ptr__Unwind_ForcedUnwind);\n  PTR_MANGLE (local.ptr__Unwind_GetCFA);\n#if UNWIND_LINK_GETIP\n  PTR_MANGLE (local.ptr__Unwind_GetIP);\n#endif\n  PTR_MANGLE (local.ptr__Unwind_Resume);\n#if UNWIND_LINK_FRAME_STATE_FOR\n  PTR_MANGLE (local.ptr___frame_state_for);\n#endif\n  PTR_MANGLE (local.ptr_personality);\n\n  __libc_lock_lock (lock);\n  if (atomic_load_relaxed (&global_libgcc_handle) != NULL)\n    /* This thread lost the race.  Clean up.  */\n    __libc_dlclose (local_libgcc_handle);\n  else\n    {\n      global = local;\n\n      /* Completes the double-checked locking idiom.  */\n      atomic_store_release (&global_libgcc_handle, local_libgcc_handle);\n    }\n\n  __libc_lock_unlock (lock);\n  return &global;\n}",
    "usleep": "usleep (useconds_t useconds){\n  struct timespec ts = { .tv_sec = (long int) (useconds / 1000000),\n\t\t\t .tv_nsec = (long int) (useconds % 1000000) * 1000ul };\n\n  /* Note the usleep() is a cancellation point.  But since we call\n     nanosleep() which itself is a cancellation point we do not have\n     to do anything here.  */\n  return __nanosleep (&ts, NULL);\n}",
    "vhangup": "vhangup (void){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "_pthread_cleanup_push_defer": "attribute_compat_text_section\n_pthread_cleanup_push_defer (struct _pthread_cleanup_buffer *buffer,\n\t\t\t     void (*routine) (void *), void *arg){\n  buffer->__routine = routine;\n  buffer->__arg = arg;\n  __libc_cleanup_push_defer (buffer);\n}",
    "_pthread_cleanup_pop_restore": "attribute_compat_text_section\n_pthread_cleanup_pop_restore (struct _pthread_cleanup_buffer *buffer,\n\t\t\t      int execute){\n  __libc_cleanup_pop_restore (buffer);\n\n  /* If necessary call the cleanup routine after we removed the\n     current cleanup block from the list.  */\n  if (execute)\n    buffer->__routine (buffer->__arg);\n}",
    "__nptl_create_event": "__nptl_create_event (void){\n}",
    "__nptl_death_event": "__nptl_death_event (void){\n}",
    "__lll_lock_wait_private": "__lll_lock_wait_private (int *futex){\n  if (atomic_load_relaxed (futex) == 2)\n    goto futex;\n\n  while (atomic_exchange_acquire (futex, 2) != 0)\n    {\n    futex:\n      LIBC_PROBE (lll_lock_wait_private, 1, futex);\n      futex_wait ((unsigned int *) futex, 2, LLL_PRIVATE); /* Wait if *futex == 2.  */\n    }\n}",
    "__lll_lock_wake_private": "__lll_lock_wake_private (int *futex){\n  lll_futex_wake (futex, 1, LLL_PRIVATE);\n}",
    "__pthread_get_minstack": "__pthread_get_minstack (const pthread_attr_t *attr){\n  return (GLRO(dl_pagesize) + __nptl_tls_static_size_for_stack ()\n\t  + PTHREAD_STACK_MIN);\n}",
    "clock_getcpuclockid": "clock_getcpuclockid (pid_t pid, clockid_t *clock_id){\n  /* We don't allow any process ID but our own.  */\n  if (pid != 0 && pid != getpid ())\n    return EPERM;\n\n#ifdef CLOCK_PROCESS_CPUTIME_ID\n  /* Store the number.  */\n  *clock_id = CLOCK_PROCESS_CPUTIME_ID;\n\n  return 0;\n#else\n  /* We don't have a timer for that.  */\n  return ENOENT;\n#endif\n}",
    "clock_gettime": "clock_gettime (clockid_t clock_id, struct timespec *tp){\n  int retval = -1;\n\n  switch (clock_id)\n    {\n    case CLOCK_PROCESS_CPUTIME_ID:\n      {\n\n\tstatic hp_timing_t freq;\n\thp_timing_t tsc;\n\n\t/* Get the current counter.  */\n\tHP_TIMING_NOW (tsc);\n\n\tif (freq == 0)\n\t  {\n\t    freq = get_clockfreq ();\n\t    if (freq == 0)\n\t      return EINVAL;\n\t  }\n\n\t/* Compute the seconds.  */\n\ttp->tv_sec = tsc / freq;\n\n\t/* And the nanoseconds.  This computation should be stable until\n\t   we get machines with about 16GHz frequency.  */\n\ttp->tv_nsec = ((tsc % freq) * UINT64_C (1000000000)) / freq;\n\n\tretval = 0;\n      }\n    break;\n\n    default:\n      errno = EINVAL;\n      break;\n    }\n\n  return retval;\n}",
    "pthread_attr_setsigmask_np": "pthread_attr_setsigmask_np (pthread_attr_t *attr, const sigset_t *sigmask){\n  int ret = __pthread_attr_setsigmask_internal (attr, sigmask);\n  if (ret != 0)\n    return ret;\n\n  /* Filter out internal signals.  */\n  struct pthread_attr *iattr = (struct pthread_attr *) attr;\n  clear_internal_signals (&iattr->extension->sigmask);\n\n  return 0;\n}",
    "thrd_current": "thrd_current (void){\n  if (GL (dl_pthread_threads))\n    return (thrd_t) __pthread_self ();\n\n  return (thrd_t) 0;\n}",
    "thrd_yield": "thrd_yield (void){\n  (void) __swtch ();\n}",
    "__nss_passwd_lookup": "attribute_compat_text_section\n__nss_passwd_lookup (nss_action_list *ni, const char *fct_name, void **fctp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__nss_next": "attribute_compat_text_section\n__nss_next (nss_action_list *ni, const char *fct_name, void **fctp, int status,\n            int all_values){\n  return -1;\n}",
    "__nss_database_lookup": "attribute_compat_text_section\n__nss_database_lookup (const char *database, const char *alternate_name,\n                       const char *defconfig, nss_action_list *ni){\n  *ni = NULL;\n  return -1;\n}",
    "__nss_hostname_digits_dots": "__nss_hostname_digits_dots (const char *name, struct hostent *resbuf,\n\t\t\t    char **buffer, size_t *buffer_size,\n\t\t\t    size_t buflen, struct hostent **result,\n\t\t\t    enum nss_status *status, int af, int *h_errnop){\n  /* We have to test for the use of IPv6 which can only be done by\n     examining `_res'.  */\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      if (h_errnop)\n\t*h_errnop = NETDB_INTERNAL;\n      if (buffer_size == NULL)\n\t*status = NSS_STATUS_TRYAGAIN;\n      else\n\t*result = NULL;\n      return -1;\n    }\n  int ret = __nss_hostname_digits_dots_context\n    (ctx, name, resbuf, buffer, buffer_size, buflen,\n     result, status, af, h_errnop);\n  __resolv_context_put (ctx);\n  return ret;\n}",
    "ether_hostton": "ether_hostton (const char *hostname, struct ether_addr *addr){\n  nss_action_list nip;\n  union\n  {\n    lookup_function f;\n    void *ptr;\n  } fct;\n  int no_more;\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n  struct etherent etherent;\n\n  no_more = __nss_ethers_lookup2 (&nip, \"gethostton_r\", NULL, &fct.ptr);\n\n  while (no_more == 0)\n    {\n      char buffer[1024];\n\n      status = (*fct.f) (hostname, &etherent, buffer, sizeof buffer, &errno);\n\n      no_more = __nss_next2 (&nip, \"gethostton_r\", NULL, &fct.ptr, status, 0);\n    }\n\n  if (status == NSS_STATUS_SUCCESS)\n    memcpy (addr, etherent.e_addr.ether_addr_octet,\n\t    sizeof (struct ether_addr));\n\n  return status == NSS_STATUS_SUCCESS ? 0 : -1;\n}",
    "ether_ntohost": "ether_ntohost (char *hostname, const struct ether_addr *addr){\n  nss_action_list nip;\n  union\n  {\n    lookup_function f;\n    void *ptr;\n  } fct;\n  int no_more;\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n  struct etherent etherent;\n\n  no_more = __nss_ethers_lookup2 (&nip, \"getntohost_r\", NULL, &fct.ptr);\n\n  while (no_more == 0)\n    {\n      char buffer[1024];\n\n      status = (*fct.f) (addr, &etherent, buffer, sizeof buffer, &errno);\n\n      no_more = __nss_next2 (&nip, \"getntohost_r\", NULL, &fct.ptr, status, 0);\n    }\n\n  if (status == NSS_STATUS_SUCCESS)\n    /* XXX This is a potential cause of trouble because the size of\n       the HOSTNAME buffer is not known but the interface does not\n       provide this information.  */\n    strcpy (hostname, etherent.e_name);\n\n  return status == NSS_STATUS_SUCCESS ? 0 : -1;\n}",
    "fgetgrent": "*\nfgetgrent (FILE *stream){\n  static size_t buffer_size;\n  static struct group resbuf;\n  fpos_t pos;\n  struct group *result;\n  int save;\n\n  if (__builtin_expect (fgetpos (stream, &pos), 0) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = NSS_BUFLEN_GROUP;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetgrent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += NSS_BUFLEN_GROUP;\n      new_buf = realloc (buffer, buffer_size);\n      if (__glibc_unlikely (new_buf == NULL))\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "fgetpwent": "*\nfgetpwent (FILE *stream){\n  static size_t buffer_size;\n  static struct passwd resbuf;\n  fpos_t pos;\n  struct passwd *result;\n  int save;\n\n  if (fgetpos (stream, &pos) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = NSS_BUFLEN_PASSWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetpwent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += NSS_BUFLEN_PASSWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "fgetsgent": "*\nfgetsgent (FILE *stream){\n  static size_t buffer_size;\n  static struct sgrp resbuf;\n  fpos_t pos;\n  struct sgrp *result;\n  int save;\n\n  if (fgetpos (stream, &pos) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetsgent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "fgetspent": "*\nfgetspent (FILE *stream){\n  static size_t buffer_size;\n  static struct spwd resbuf;\n  fpos_t pos;\n  struct spwd *result;\n  int save;\n\n  if (fgetpos (stream, &pos) != 0)\n    return NULL;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__fgetspent_r (stream, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n\n      /* Reset the stream.  */\n      if (fsetpos (stream, &pos) != 0)\n\tbuffer = NULL;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "getaddrinfo": "getaddrinfo (const char *name, const char *service,\n\t     const struct addrinfo *hints, struct addrinfo **pai){\n  int i = 0, last_i = 0;\n  int nresults = 0;\n  struct addrinfo *p = NULL;\n  struct gaih_service gaih_service, *pservice;\n  struct addrinfo local_hints;\n\n  if (name != NULL && name[0] == '*' && name[1] == 0)\n    name = NULL;\n\n  if (service != NULL && service[0] == '*' && service[1] == 0)\n    service = NULL;\n\n  if (name == NULL && service == NULL)\n    return EAI_NONAME;\n\n  if (hints == NULL)\n    hints = &default_hints;\n\n  if (hints->ai_flags\n      & ~(AI_PASSIVE|AI_CANONNAME|AI_NUMERICHOST|AI_ADDRCONFIG|AI_V4MAPPED\n\t  |AI_IDN|AI_CANONIDN|DEPRECATED_AI_IDN\n\t  |AI_NUMERICSERV|AI_ALL))\n    return EAI_BADFLAGS;\n\n  if ((hints->ai_flags & AI_CANONNAME) && name == NULL)\n    return EAI_BADFLAGS;\n\n  if (hints->ai_family != AF_UNSPEC && hints->ai_family != AF_INET\n      && hints->ai_family != AF_INET6)\n    return EAI_FAMILY;\n\n  struct in6addrinfo *in6ai = NULL;\n  size_t in6ailen = 0;\n  bool seen_ipv4 = false;\n  bool seen_ipv6 = false;\n  bool check_pf_called = false;\n\n  if (hints->ai_flags & AI_ADDRCONFIG)\n    {\n      /* We might need information about what interfaces are available.\n\t Also determine whether we have IPv4 or IPv6 interfaces or both.  We\n\t cannot cache the results since new interfaces could be added at\n\t any time.  */\n      __check_pf (&seen_ipv4, &seen_ipv6, &in6ai, &in6ailen);\n      check_pf_called = true;\n\n      /* Now make a decision on what we return, if anything.  */\n      if (hints->ai_family == PF_UNSPEC && (seen_ipv4 || seen_ipv6))\n\t{\n\t  /* If we haven't seen both IPv4 and IPv6 interfaces we can\n\t     narrow down the search.  */\n\t  if (seen_ipv4 != seen_ipv6)\n\t    {\n\t      local_hints = *hints;\n\t      local_hints.ai_family = seen_ipv4 ? PF_INET : PF_INET6;\n\t      hints = &local_hints;\n\t    }\n\t}\n      else if ((hints->ai_family == PF_INET && ! seen_ipv4)\n\t       || (hints->ai_family == PF_INET6 && ! seen_ipv6))\n\t{\n\t  /* We cannot possibly return a valid answer.  */\n\t  __free_in6ai (in6ai);\n\t  return EAI_NONAME;\n\t}\n    }\n\n  if (service && service[0])\n    {\n      char *c;\n      gaih_service.name = service;\n      gaih_service.num = strtoul (gaih_service.name, &c, 10);\n      if (*c != '\\0')\n\t{\n\t  if (hints->ai_flags & AI_NUMERICSERV)\n\t    {\n\t      __free_in6ai (in6ai);\n\t      return EAI_NONAME;\n\t    }\n\n\t  gaih_service.num = -1;\n\t}\n\n      pservice = &gaih_service;\n    }\n  else\n    pservice = NULL;\n\n  struct addrinfo **end = &p;\n  unsigned int naddrs = 0;\n  struct scratch_buffer tmpbuf;\n\n  scratch_buffer_init (&tmpbuf);\n  last_i = gaih_inet (name, pservice, hints, end, &naddrs, &tmpbuf);\n  scratch_buffer_free (&tmpbuf);\n\n  if (last_i != 0)\n    {\n      freeaddrinfo (p);\n      __free_in6ai (in6ai);\n\n      return -last_i;\n    }\n\n  while (*end)\n    {\n      end = &((*end)->ai_next);\n      ++nresults;\n    }\n\n  if (naddrs > 1)\n    {\n      /* Read the config file.  */\n      __libc_once_define (static, once);\n      __typeof (once) old_once = once;\n      __libc_once (once, gaiconf_init);\n      /* Sort results according to RFC 3484.  */\n      struct sort_result *results;\n      size_t *order;\n      struct addrinfo *q;\n      struct addrinfo *last = NULL;\n      char *canonname = NULL;\n      struct scratch_buffer buf;\n      scratch_buffer_init (&buf);\n\n      if (!scratch_buffer_set_array_size (&buf, nresults,\n\t\t\t\t\t  sizeof (*results) + sizeof (size_t)))\n\t{\n\t  __free_in6ai (in6ai);\n\t  return EAI_MEMORY;\n\t}\n      results = buf.data;\n\n      order = (size_t *) (results + nresults);\n\n      /* Now we definitely need the interface information.  */\n      if (! check_pf_called)\n\t__check_pf (&seen_ipv4, &seen_ipv6, &in6ai, &in6ailen);\n\n      /* If we have information about deprecated and temporary addresses\n\t sort the array now.  */\n      if (in6ai != NULL)\n\tqsort (in6ai, in6ailen, sizeof (*in6ai), in6aicmp);\n\n      int fd = -1;\n      int af = AF_UNSPEC;\n\n      for (i = 0, q = p; q != NULL; ++i, last = q, q = q->ai_next)\n\t{\n\t  results[i].dest_addr = q;\n\t  results[i].native = -1;\n\t  order[i] = i;\n\n\t  /* If we just looked up the address for a different\n\t     protocol, reuse the result.  */\n\t  if (last != NULL && last->ai_addrlen == q->ai_addrlen\n\t      && memcmp (last->ai_addr, q->ai_addr, q->ai_addrlen) == 0)\n\t    {\n\t      memcpy (&results[i].source_addr, &results[i - 1].source_addr,\n\t\t      results[i - 1].source_addr_len);\n\t      results[i].source_addr_len = results[i - 1].source_addr_len;\n\t      results[i].got_source_addr = results[i - 1].got_source_addr;\n\t      results[i].source_addr_flags = results[i - 1].source_addr_flags;\n\t      results[i].prefixlen = results[i - 1].prefixlen;\n\t      results[i].index = results[i - 1].index;\n\t    }\n\t  else\n\t    {\n\t      results[i].got_source_addr = false;\n\t      results[i].source_addr_flags = 0;\n\t      results[i].prefixlen = 0;\n\t      results[i].index = 0xffffffffu;\n\n\t      /* We overwrite the type with SOCK_DGRAM since we do not\n\t\t want connect() to connect to the other side.  If we\n\t\t cannot determine the source address remember this\n\t\t fact.  */\n\t      if (fd == -1 || (af == AF_INET && q->ai_family == AF_INET6))\n\t\t{\n\t\t  if (fd != -1)\n\t\t    __close_nocancel_nostatus (fd);\n\t\t  af = q->ai_family;\n\t\t  fd = __socket (af, SOCK_DGRAM | SOCK_CLOEXEC, IPPROTO_IP);\n\t\t}\n\t      else\n\t\t{\n\t\t  /* Reset the connection.  */\n\t\t  struct sockaddr sa = { .sa_family = AF_UNSPEC };\n\t\t  __connect (fd, &sa, sizeof (sa));\n\t\t}\n\n\t      if (try_connect (&fd, &af, &results[i].source_addr, q->ai_addr,\n\t\t\t       q->ai_addrlen, q->ai_family))\n\t\t{\n\t\t  results[i].source_addr_len = sizeof (results[i].source_addr);\n\t\t  results[i].got_source_addr = true;\n\n\t\t  if (in6ai != NULL)\n\t\t    {\n\t\t      /* See whether the source address is on the list of\n\t\t\t deprecated or temporary addresses.  */\n\t\t      struct in6addrinfo tmp;\n\n\t\t      if (q->ai_family == AF_INET && af == AF_INET)\n\t\t\t{\n\t\t\t  struct sockaddr_in *sinp\n\t\t\t    = (struct sockaddr_in *) &results[i].source_addr;\n\t\t\t  tmp.addr[0] = 0;\n\t\t\t  tmp.addr[1] = 0;\n\t\t\t  tmp.addr[2] = htonl (0xffff);\n\t\t\t  /* Special case for lo interface, the source address\n\t\t\t     being possibly different than the interface\n\t\t\t     address. */\n\t\t\t  if ((ntohl(sinp->sin_addr.s_addr) & 0xff000000)\n\t\t\t      == 0x7f000000)\n\t\t\t    tmp.addr[3] = htonl(0x7f000001);\n\t\t\t  else\n\t\t\t    tmp.addr[3] = sinp->sin_addr.s_addr;\n\t\t\t}\n\t\t      else\n\t\t\t{\n\t\t\t  struct sockaddr_in6 *sin6p\n\t\t\t    = (struct sockaddr_in6 *) &results[i].source_addr;\n\t\t\t  memcpy (tmp.addr, &sin6p->sin6_addr, IN6ADDRSZ);\n\t\t\t}\n\n\t\t      struct in6addrinfo *found\n\t\t\t= bsearch (&tmp, in6ai, in6ailen, sizeof (*in6ai),\n\t\t\t\t   in6aicmp);\n\t\t      if (found != NULL)\n\t\t\t{\n\t\t\t  results[i].source_addr_flags = found->flags;\n\t\t\t  results[i].prefixlen = found->prefixlen;\n\t\t\t  results[i].index = found->index;\n\t\t\t}\n\t\t    }\n\n\t\t  if (q->ai_family == AF_INET && af == AF_INET6)\n\t\t    {\n\t\t      /* We have to convert the address.  The socket is\n\t\t\t IPv6 and the request is for IPv4.  */\n\t\t      struct sockaddr_in6 *sin6\n\t\t\t= (struct sockaddr_in6 *) &results[i].source_addr;\n\t\t      struct sockaddr_in *sin\n\t\t\t= (struct sockaddr_in *) &results[i].source_addr;\n\t\t      assert (IN6_IS_ADDR_V4MAPPED (sin6->sin6_addr.s6_addr32));\n\t\t      sin->sin_family = AF_INET;\n\t\t      /* We do not have to initialize sin_port since this\n\t\t\t fields has the same position and size in the IPv6\n\t\t\t structure.  */\n\t\t      assert (offsetof (struct sockaddr_in, sin_port)\n\t\t\t      == offsetof (struct sockaddr_in6, sin6_port));\n\t\t      assert (sizeof (sin->sin_port)\n\t\t\t      == sizeof (sin6->sin6_port));\n\t\t      memcpy (&sin->sin_addr,\n\t\t\t      &sin6->sin6_addr.s6_addr32[3], INADDRSZ);\n\t\t      results[i].source_addr_len = sizeof (struct sockaddr_in);\n\t\t    }\n\t\t}\n\t      else\n\t\t/* Just make sure that if we have to process the same\n\t\t   address again we do not copy any memory.  */\n\t\tresults[i].source_addr_len = 0;\n\t    }\n\n\t  /* Remember the canonical name.  */\n\t  if (q->ai_canonname != NULL)\n\t    {\n\t      assert (canonname == NULL);\n\t      canonname = q->ai_canonname;\n\t      q->ai_canonname = NULL;\n\t    }\n\t}\n\n      if (fd != -1)\n\t__close_nocancel_nostatus (fd);\n\n      /* We got all the source addresses we can get, now sort using\n\t the information.  */\n      struct sort_result_combo src\n\t= { .results = results, .nresults = nresults };\n      if (__glibc_unlikely (gaiconf_reload_flag_ever_set))\n\t{\n\t  __libc_lock_define_initialized (static, lock);\n\n\t  __libc_lock_lock (lock);\n\t  if (__libc_once_get (old_once) && gaiconf_reload_flag)\n\t    gaiconf_reload ();\n\t  __qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &src);\n\t  __libc_lock_unlock (lock);\n\t}\n      else\n\t__qsort_r (order, nresults, sizeof (order[0]), rfc3484_sort, &src);\n\n      /* Queue the results up as they come out of sorting.  */\n      q = p = results[order[0]].dest_addr;\n      for (i = 1; i < nresults; ++i)\n\tq = q->ai_next = results[order[i]].dest_addr;\n      q->ai_next = NULL;\n\n      /* Fill in the canonical name into the new first entry.  */\n      p->ai_canonname = canonname;\n\n      scratch_buffer_free (&buf);\n    }\n\n  __free_in6ai (in6ai);\n\n  if (p)\n    {\n      *pai = p;\n      return 0;\n    }\n\n  return last_i ? -last_i : EAI_NONAME;\n}",
    "freeaddrinfo": "void\nfreeaddrinfo (struct addrinfo *ai){\n  struct addrinfo *p;\n\n  while (ai != NULL)\n    {\n      p = ai;\n      ai = ai->ai_next;\n      free (p->ai_canonname);\n      free (p);\n    }\n}",
    "getnameinfo": "getnameinfo (const struct sockaddr *sa, socklen_t addrlen, char *host,\n\t     socklen_t hostlen, char *serv, socklen_t servlen,\n\t     int flags){\n  if (flags & ~(NI_NUMERICHOST|NI_NUMERICSERV|NI_NOFQDN|NI_NAMEREQD|NI_DGRAM\n\t\t|NI_IDN|DEPRECATED_NI_IDN))\n    return EAI_BADFLAGS;\n\n  if (sa == NULL || addrlen < sizeof (sa_family_t))\n    return EAI_FAMILY;\n\n  if ((flags & NI_NAMEREQD) && host == NULL && serv == NULL)\n    return EAI_NONAME;\n\n  switch (sa->sa_family)\n    {\n    case AF_LOCAL:\n      if (addrlen < (socklen_t) offsetof (struct sockaddr_un, sun_path))\n\treturn EAI_FAMILY;\n      break;\n    case AF_INET:\n      if (addrlen < sizeof (struct sockaddr_in))\n\treturn EAI_FAMILY;\n      break;\n    case AF_INET6:\n      if (addrlen < sizeof (struct sockaddr_in6))\n\treturn EAI_FAMILY;\n      break;\n    default:\n      return EAI_FAMILY;\n    }\n\n  struct scratch_buffer tmpbuf;\n  scratch_buffer_init (&tmpbuf);\n\n  if (host != NULL && hostlen > 0)\n    {\n      int result = gni_host (&tmpbuf, sa, addrlen, host, hostlen, flags);\n      if (result != 0)\n\t{\n\t  scratch_buffer_free (&tmpbuf);\n\t  return result;\n\t}\n    }\n\n  if (serv && (servlen > 0))\n    {\n      int result = gni_serv (&tmpbuf, sa, addrlen, serv, servlen, flags);\n      if (result != 0)\n\t{\n\t  scratch_buffer_free (&tmpbuf);\n\t  return result;\n\t}\n    }\n\n  scratch_buffer_free (&tmpbuf);\n  return 0;\n}",
    "getnetgrent": "getnetgrent (char **hostp, char **userp, char **domainp){\n  __libc_once_define (static, once);\n  __libc_once (once, allocate);\n\n  if (buffer == NULL)\n    {\n      __set_errno (ENOMEM);\n      return -1;\n    }\n\n  return __getnetgrent_r (hostp, userp, domainp, buffer, BUFSIZE);\n}",
    "__internal_setnetgrent": "__internal_setnetgrent (const char *group, struct __netgrent *datap){\n  /* Free list of all netgroup names from last run.  */\n  free_memory (datap);\n\n  return __internal_setnetgrent_reuse (group, datap, &errno);\n}",
    "setnetgrent": "setnetgrent (const char *group){\n  int result;\n\n  __libc_lock_lock (lock);\n\n  result = nscd_setnetgrent (group);\n  if (result < 0)\n    result = __internal_setnetgrent (group, &dataset);\n\n  __libc_lock_unlock (lock);\n\n  return result;\n}",
    "__internal_endnetgrent": "__internal_endnetgrent (struct __netgrent *datap){\n  endnetgrent_hook (datap);\n  /* Now free list of all netgroup names from last run.  */\n  free_memory (datap);\n}",
    "endnetgrent": "endnetgrent (void){\n  __libc_lock_lock (lock);\n\n  __internal_endnetgrent (&dataset);\n\n  __libc_lock_unlock (lock);\n}",
    "__internal_getnetgrent_r": "__internal_getnetgrent_r (char **hostp, char **userp, char **domainp,\n\t\t\t  struct __netgrent *datap,\n\t\t\t  char *buffer, size_t buflen, int *errnop){\n  enum nss_status (*fct) (struct __netgrent *, char *, size_t, int *);\n\n  /* Initialize status to return if no more functions are found.  */\n  enum nss_status status = NSS_STATUS_NOTFOUND;\n\n  /* Run through available functions, starting with the same function last\n     run.  We will repeat each function as long as it succeeds, and then go\n     on to the next service action.  */\n  int no_more = datap->nip == NULL;\n  if (! no_more)\n    {\n#ifdef USE_NSCD\n      /* This bogus function pointer is a special marker left by\n\t __nscd_setnetgrent to tell us to use the data it left\n\t before considering any modules.  */\n      if (datap->nip == (nss_action_list) -1l)\n\tfct = nscd_getnetgrent;\n      else\n#endif\n\t{\n\t  fct = __nss_lookup_function (datap->nip, \"getnetgrent_r\");\n\t  no_more = fct == NULL;\n\t}\n\n      while (! no_more)\n\t{\n\t  status = DL_CALL_FCT (*fct, (datap, buffer, buflen, &errno));\n\n\t  if (status == NSS_STATUS_RETURN\n\t      /* The service returned a NOTFOUND, but there are more groups that\n\t\t we need to resolve before we give up.  */\n\t      || (status == NSS_STATUS_NOTFOUND && datap->needed_groups != NULL))\n\t    {\n\t      /* This was the last one for this group.  Look at next group\n\t\t if available.  */\n\t      int found = 0;\n\t      while (datap->needed_groups != NULL && ! found)\n\t\t{\n\t\t  struct name_list *tmp = datap->needed_groups;\n\t\t  datap->needed_groups = datap->needed_groups->next;\n\t\t  tmp->next = datap->known_groups;\n\t\t  datap->known_groups = tmp;\n\n\t\t  found = __internal_setnetgrent_reuse (datap->known_groups->name,\n\t\t\t\t\t\t\tdatap, errnop);\n\t\t}\n\n\t      if (found && datap->nip != NULL)\n\t\t{\n\t\t  fct = __nss_lookup_function (datap->nip, \"getnetgrent_r\");\n\t\t  if (fct != NULL)\n\t\t    continue;\n\t\t}\n\t    }\n\t  else if (status == NSS_STATUS_SUCCESS && datap->type == group_val)\n\t    {\n\t      /* The last entry was a name of another netgroup.  */\n\t      struct name_list *namep;\n\n\t      /* Ignore if we've seen the name before.  */\n\t      for (namep = datap->known_groups; namep != NULL;\n\t\t   namep = namep->next)\n\t\tif (strcmp (datap->val.group, namep->name) == 0)\n\t\t  break;\n\t      if (namep == NULL)\n\t\tfor (namep = datap->needed_groups; namep != NULL;\n\t\t     namep = namep->next)\n\t\t  if (strcmp (datap->val.group, namep->name) == 0)\n\t\t    break;\n\t      if (namep != NULL)\n\t\t/* Really ignore.  */\n\t\tcontinue;\n\n\t      size_t group_len = strlen (datap->val.group) + 1;\n\t      namep = (struct name_list *) malloc (sizeof (struct name_list)\n\t\t\t\t\t\t  + group_len);\n\t      if (namep == NULL)\n\t\t/* We are out of memory.  */\n\t\tstatus = NSS_STATUS_RETURN;\n\t      else\n\t\t{\n\t\t  namep->next = datap->needed_groups;\n\t\t  memcpy (namep->name, datap->val.group, group_len);\n\t\t  datap->needed_groups = namep;\n\t\t  /* And get the next entry.  */\n\t\t  continue;\n\t\t}\n\t    }\n\t  break;\n\t}\n    }\n\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      *hostp = (char *) datap->val.triple.host;\n      *userp = (char *) datap->val.triple.user;\n      *domainp = (char *) datap->val.triple.domain;\n    }\n\n  return status == NSS_STATUS_SUCCESS ? 1 : 0;\n}",
    "innetgr": "innetgr (const char *netgroup, const char *host, const char *user,\n\t const char *domain){\n#ifdef USE_NSCD\n  if (__nss_not_use_nscd_netgroup > 0\n      && ++__nss_not_use_nscd_netgroup > NSS_NSCD_RETRY)\n    __nss_not_use_nscd_netgroup = 0;\n\n  if (!__nss_not_use_nscd_netgroup\n      && !__nss_database_custom[NSS_DBSIDX_netgroup])\n    {\n      int result = __nscd_innetgr (netgroup, host, user, domain);\n      if (result >= 0)\n\treturn result;\n    }\n#endif\n\n  union\n  {\n    enum nss_status (*f) (const char *, struct __netgrent *);\n    void *ptr;\n  } setfct;\n  void (*endfct) (struct __netgrent *);\n  int (*getfct) (struct __netgrent *, char *, size_t, int *);\n  struct __netgrent entry;\n  int result = 0;\n  const char *current_group = netgroup;\n\n  memset (&entry, '\\0', sizeof (entry));\n\n  /* Walk through the services until we found an answer or we shall\n     not work further.  We can do some optimization here.  Since all\n     services must provide the `setnetgrent' function we can do all\n     the work during one walk through the service list.  */\n  while (1)\n    {\n      int no_more = setup (&setfct.ptr, &entry.nip);\n      while (! no_more)\n\t{\n\t  assert (entry.data == NULL);\n\n\t  /* Open netgroup.  */\n\t  enum nss_status status = DL_CALL_FCT (*setfct.f,\n\t\t\t\t\t\t(current_group, &entry));\n\n\t  if (status == NSS_STATUS_SUCCESS\n\t      && (getfct = __nss_lookup_function (entry.nip, \"getnetgrent_r\"))\n\t\t != NULL)\n\t    {\n\t      char buffer[1024];\n\n\t      while (DL_CALL_FCT (*getfct,\n\t\t\t\t  (&entry, buffer, sizeof buffer, &errno))\n\t\t     == NSS_STATUS_SUCCESS)\n\t\t{\n\t\t  if (entry.type == group_val)\n\t\t    {\n\t\t      /* Make sure we haven't seen the name before.  */\n\t\t      struct name_list *namep;\n\n\t\t      for (namep = entry.known_groups; namep != NULL;\n\t\t\t   namep = namep->next)\n\t\t\tif (strcmp (entry.val.group, namep->name) == 0)\n\t\t\t  break;\n\t\t      if (namep == NULL)\n\t\t\tfor (namep = entry.needed_groups; namep != NULL;\n\t\t\t     namep = namep->next)\n\t\t\t  if (strcmp (entry.val.group, namep->name) == 0)\n\t\t\t    break;\n\t\t      if (namep == NULL\n\t\t\t  && strcmp (netgroup, entry.val.group) != 0)\n\t\t\t{\n\t\t\t  size_t group_len = strlen (entry.val.group) + 1;\n\t\t\t  namep =\n\t\t\t    (struct name_list *) malloc (sizeof (*namep)\n\t\t\t\t\t\t\t + group_len);\n\t\t\t  if (namep == NULL)\n\t\t\t    {\n\t\t\t      /* Out of memory, simply return.  */\n\t\t\t      result = -1;\n\t\t\t      break;\n\t\t\t    }\n\n\t\t\t  namep->next = entry.needed_groups;\n\t\t\t  memcpy (namep->name, entry.val.group, group_len);\n\t\t\t  entry.needed_groups = namep;\n\t\t\t}\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      if ((entry.val.triple.host == NULL || host == NULL\n\t\t\t   || __strcasecmp (entry.val.triple.host, host) == 0)\n\t\t\t  && (entry.val.triple.user == NULL || user == NULL\n\t\t\t      || strcmp (entry.val.triple.user, user) == 0)\n\t\t\t  && (entry.val.triple.domain == NULL || domain == NULL\n\t\t\t      || __strcasecmp (entry.val.triple.domain,\n\t\t\t\t\t       domain) == 0))\n\t\t\t{\n\t\t\t  result = 1;\n\t\t\t  break;\n\t\t\t}\n\t\t    }\n\t\t}\n\n\t      /* If we found one service which does know the given\n\t\t netgroup we don't try further.  */\n\t      status = NSS_STATUS_RETURN;\n\t    }\n\n\t  /* Free all resources of the service.  */\n\t  endfct = __nss_lookup_function (entry.nip, \"endnetgrent\");\n\t  if (endfct != NULL)\n\t    DL_CALL_FCT (*endfct, (&entry));\n\n\t  if (result != 0)\n\t    break;\n\n\t  /* Look for the next service.  */\n\t  no_more = __nss_next2 (&entry.nip, \"setnetgrent\", NULL,\n\t\t\t\t &setfct.ptr, status, 0);\n\t}\n\n      if (result == 0 && entry.needed_groups != NULL)\n\t{\n\t  struct name_list *tmp = entry.needed_groups;\n\t  entry.needed_groups = tmp->next;\n\t  tmp->next = entry.known_groups;\n\t  entry.known_groups = tmp;\n\t  current_group = tmp->name;\n\t  continue;\n\t}\n\n      /* No way out.  */\n      break;\n    }\n\n  /* Free the memory.  */\n  free_memory (&entry);\n\n  return result == 1;\n}",
    "__copy_grp": "__copy_grp (const struct group srcgrp, const size_t buflen,\n\t    struct group *destgrp, char *destbuf, char **endptr){\n  size_t i;\n  size_t c = 0;\n  size_t len;\n  size_t memcount;\n  char **members = NULL;\n\n  /* Copy the GID.  */\n  destgrp->gr_gid = srcgrp.gr_gid;\n\n  /* Copy the name.  */\n  len = strlen (srcgrp.gr_name) + 1;\n  BUFCHECK (len);\n  memcpy (&destbuf[c], srcgrp.gr_name, len);\n  destgrp->gr_name = &destbuf[c];\n  c += len;\n\n  /* Copy the password.  */\n  len = strlen (srcgrp.gr_passwd) + 1;\n  BUFCHECK (len);\n  memcpy (&destbuf[c], srcgrp.gr_passwd, len);\n  destgrp->gr_passwd = &destbuf[c];\n  c += len;\n\n  /* Count all of the members.  */\n  for (memcount = 0; srcgrp.gr_mem[memcount]; memcount++)\n    ;\n\n  /* Allocate a temporary holding area for the pointers to the member\n     contents, including space for a NULL-terminator.  */\n  members = malloc (sizeof (char *) * (memcount + 1));\n  if (members == NULL)\n    return ENOMEM;\n\n  /* Copy all of the group members to destbuf and add a pointer to each of\n     them into the 'members' array.  */\n  for (i = 0; srcgrp.gr_mem[i]; i++)\n    {\n      len = strlen (srcgrp.gr_mem[i]) + 1;\n      BUFCHECK (len);\n      memcpy (&destbuf[c], srcgrp.gr_mem[i], len);\n      members[i] = &destbuf[c];\n      c += len;\n    }\n  members[i] = NULL;\n\n  /* Align for pointers.  We can't simply align C because we need to\n     align destbuf[c].  */\n  if ((((uintptr_t)destbuf + c) & (__alignof__(char **) - 1)) != 0)\n    {\n      uintptr_t mis_align = ((uintptr_t)destbuf + c) & (__alignof__(char **) - 1);\n      c += __alignof__(char **) - mis_align;\n    }\n\n  /* Copy the pointers from the members array into the buffer and assign them\n     to the gr_mem member of destgrp.  */\n  destgrp->gr_mem = (char **) &destbuf[c];\n  len = sizeof (char *) * (memcount + 1);\n  BUFCHECK (len);\n  memcpy (&destbuf[c], members, len);\n  c += len;\n  free (members);\n  members = NULL;\n\n  /* Save the count of members at the end.  */\n  BUFCHECK (sizeof (size_t));\n  memcpy (&destbuf[c], &memcount, sizeof (size_t));\n  c += sizeof (size_t);\n\n  if (endptr)\n    *endptr = destbuf + c;\n  return 0;\n}",
    "__merge_grp": "__merge_grp (struct group *savedgrp, char *savedbuf, char *savedend,\n\t     size_t buflen, struct group *mergegrp, char *mergebuf){\n  size_t c, i, len;\n  size_t savedmemcount;\n  size_t memcount;\n  size_t membersize;\n  char **members = NULL;\n\n  /* We only support merging members of groups with identical names and\n     GID values. If we hit this case, we need to overwrite the current\n     buffer with the saved one (which is functionally equivalent to\n     treating the new lookup as NSS_STATUS_NOTFOUND).  */\n  if (mergegrp->gr_gid != savedgrp->gr_gid\n      || strcmp (mergegrp->gr_name, savedgrp->gr_name))\n    return __copy_grp (*savedgrp, buflen, mergegrp, mergebuf, NULL);\n\n  /* Get the count of group members from the last sizeof (size_t) bytes in the\n     mergegrp buffer.  */\n  savedmemcount = *(size_t *) (savedend - sizeof (size_t));\n\n  /* Get the count of new members to add.  */\n  for (memcount = 0; mergegrp->gr_mem[memcount]; memcount++)\n    ;\n\n  /* Create a temporary array to hold the pointers to the member values from\n     both the saved and merge groups.  */\n  membersize = savedmemcount + memcount + 1;\n  members = malloc (sizeof (char *) * membersize);\n  if (members == NULL)\n    return ENOMEM;\n\n  /* Copy in the existing member pointers from the saved group\n     Note: this is not NULL-terminated yet.  */\n  memcpy (members, savedgrp->gr_mem, sizeof (char *) * savedmemcount);\n\n  /* Back up into the savedbuf until we get back to the NULL-terminator of the\n     group member list. (This means walking back savedmemcount + 1 (char *) pointers\n     and the member count value.\n     The value of c is going to be the used length of the buffer backed up by\n     the member count and further backed up by the size of the pointers.  */\n  c = savedend - savedbuf\n      - sizeof (size_t)\n      - sizeof (char *) * (savedmemcount + 1);\n\n  /* Add all the new group members, overwriting the old NULL-terminator while\n     adding the new pointers to the temporary array.  */\n  for (i = 0; mergegrp->gr_mem[i]; i++)\n    {\n      len = strlen (mergegrp->gr_mem[i]) + 1;\n      BUFCHECK (len);\n      memcpy (&savedbuf[c], mergegrp->gr_mem[i], len);\n      members[savedmemcount + i] = &savedbuf[c];\n      c += len;\n    }\n  /* Add the NULL-terminator.  */\n  members[savedmemcount + memcount] = NULL;\n\n  /* Align for pointers.  We can't simply align C because we need to\n     align savedbuf[c].  */\n  if ((((uintptr_t)savedbuf + c) & (__alignof__(char **) - 1)) != 0)\n    {\n      uintptr_t mis_align = ((uintptr_t)savedbuf + c) & (__alignof__(char **) - 1);\n      c += __alignof__(char **) - mis_align;\n    }\n\n  /* Copy the member array back into the buffer after the member list and free\n     the member array.  */\n  savedgrp->gr_mem = (char **) &savedbuf[c];\n  len = sizeof (char *) * membersize;\n  BUFCHECK (len);\n  memcpy (&savedbuf[c], members, len);\n  c += len;\n\n  free (members);\n  members = NULL;\n\n  /* Finally, copy the results back into mergebuf, since that's the buffer\n     that we were provided by the caller.  */\n  return __copy_grp (*savedgrp, buflen, mergegrp, mergebuf, NULL);\n}",
    "getgrouplist": "getgrouplist (const char *user, gid_t group, gid_t *groups, int *ngroups){\n  long int size = MAX (1, *ngroups);\n\n  gid_t *newgroups = (gid_t *) malloc (size * sizeof (gid_t));\n  if (__glibc_unlikely (newgroups == NULL))\n    /* No more memory.  */\n    // XXX This is wrong.  The user provided memory, we have to use\n    // XXX it.  The internal functions must be called with the user\n    // XXX provided buffer and not try to increase the size if it is\n    // XXX too small.  For initgroups a flag could say: increase size.\n    return -1;\n\n  int total = internal_getgrouplist (user, group, &size, &newgroups, -1);\n\n  memcpy (groups, newgroups, MIN (*ngroups, total) * sizeof (gid_t));\n\n  free (newgroups);\n\n  int retval = total > *ngroups ? -1 : total;\n  *ngroups = total;\n\n  return retval;\n}",
    "initgroups": "initgroups (const char *user, gid_t group){\n#if defined NGROUPS_MAX && NGROUPS_MAX == 0\n\n  /* No extra groups allowed.  */\n  return 0;\n\n#else\n\n  long int size;\n  gid_t *groups;\n  int ngroups;\n  int result;\n\n /* We always use sysconf even if NGROUPS_MAX is defined.  That way, the\n     limit can be raised in the kernel configuration without having to\n     recompile libc.  */\n  long int limit = __sysconf (_SC_NGROUPS_MAX);\n\n  if (limit > 0)\n    /* We limit the size of the initially allocated array.  */\n    size = MIN (limit, 64);\n  else\n    /* No fixed limit on groups.  Pick a starting buffer size.  */\n    size = 16;\n\n  groups = (gid_t *) malloc (size * sizeof (gid_t));\n  if (__glibc_unlikely (groups == NULL))\n    /* No more memory.  */\n    return -1;\n\n  ngroups = internal_getgrouplist (user, group, &size, &groups, limit);\n\n  /* Try to set the maximum number of groups the kernel can handle.  */\n  do\n    result = setgroups (ngroups, groups);\n  while (result == -1 && errno == EINVAL && --ngroups > 0);\n\n  free (groups);\n\n  return result;\n#endif\n}",
    "__nss_configure_lookup": "__nss_configure_lookup (const char *dbname, const char *service_line){\n  int db;\n  nss_action_list result;\n  struct nss_database_state *local;\n\n  /* Convert named database to index.  */\n  db = name_to_database_index (dbname);\n  if (db < 0)\n    /* Not our database (e.g., sudoers).  */\n    return -1;\n\n  /* Force any load/cache/read whatever to happen, so we can override\n     it.  */\n  __nss_database_get (db, &result);\n\n  local = nss_database_state_get ();\n\n  result = __nss_action_parse (service_line);\n  if (result == NULL)\n    return -1;\n\n  atomic_store_release (&local->data.reload_disabled, 1);\n  local->data.services[db] = result;\n\n#ifdef USE_NSCD\n  __nss_database_custom[db] = true;\n#endif\n\n  return 0;\n}",
    "__nss_database_get": "__nss_database_get (enum nss_database db, nss_action_list *actions){\n  struct nss_database_state *local = nss_database_state_get ();\n  return nss_database_check_reload_and_get (local, actions, db);\n}",
    "__nss_files_data_open": "__nss_files_data_open (struct nss_files_per_file_data **pdata,\n                       enum nss_files_file file, const char *path,\n                       int *errnop, int *herrnop){\n  enum nss_status status = __nss_files_data_get (pdata, file, errnop, herrnop);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  /* Be prepared that the set*ent function was not called before.  */\n  if ((*pdata)->stream == NULL)\n    {\n      int saved_errno = errno;\n      status = __nss_files_data_internal_open (*pdata, path);\n      __set_errno (saved_errno);\n      if (status != NSS_STATUS_SUCCESS)\n        __nss_files_data_put (*pdata);\n    }\n\n  return status;\n}",
    "__nss_files_data_put": "__nss_files_data_put (struct nss_files_per_file_data *data){\n  __libc_lock_unlock (data->lock);\n}",
    "__nss_files_data_setent": "__nss_files_data_setent (enum nss_files_file file, const char *path){\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_get (&data, file, NULL, NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  if (data->stream == NULL)\n    status = __nss_files_data_internal_open (data, path);\n  else\n    rewind (data->stream);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "__nss_files_data_endent": "__nss_files_data_endent (enum nss_files_file file){\n  /* No cleanup is necessary if not initialized.  */\n  struct nss_files_data *data = atomic_load_acquire (&nss_files_global);\n  if (data == NULL)\n    return NSS_STATUS_SUCCESS;\n\n  struct nss_files_per_file_data *fdata = &data->files[file];\n  __libc_lock_lock (fdata->lock);\n  if (fdata->stream != NULL)\n    {\n      fclose (fdata->stream);\n      fdata->stream = NULL;\n    }\n  __libc_lock_unlock (fdata->lock);\n\n  return NSS_STATUS_SUCCESS;\n}",
    "__nss_files_fopen": "*\n__nss_files_fopen (const char *path){\n  FILE *fp = fopen (path, \"rce\");\n  if (fp == NULL)\n    return NULL;\n\n  /* The stream is not shared across threads.  */\n  __fsetlocking (fp, FSETLOCKING_BYCALLER);\n\n  /* This tells libio that the file is seekable, and that fp->_offset\n     is correct, ensuring that __ftello64 is efficient (bug 26257).  */\n  if (__fseeko64 (fp, 0, SEEK_SET) < 0)\n    {\n      /* nss_files requires seekable files, to deal with repeated\n         reads of the same line after reporting ERANGE.  */\n      fclose (fp);\n      __set_errno (ESPIPE);\n      return NULL;\n    }\n\n  return fp;\n}",
    "__nss_hash": "__nss_hash (const void *keyarg, size_t len){\n  enum\n  {\n    HASH_CONST_P0 = 1,\t       /* (uint32_t)(65599 ^ 0).  */\n    HASH_CONST_P1 = 65599,     /* (uint32_t)(65599 ^ 1).  */\n    HASH_CONST_P2 = 8261505,   /* (uint32_t)(65599 ^ 2).  */\n    HASH_CONST_P3 = 780587199, /* (uint32_t)(65599 ^ 3).  */\n    HASH_CONST_P4 = 1139564289 /* (uint32_t)(65599 ^ 4).  */\n  };\n\n  const unsigned char *key;\n  uint32_t h;\n\n#define HASHC\th = *key++ + HASH_CONST_P1 * h\n\n  h = 0;\n  key = keyarg;\n  if (len > 0)\n    {\n      switch ((len & (4 - 1)))\n\t{\n\tcase 0:\n\t  /* h starts out as zero so no need to include the multiply. */\n\t  h = *key++;\n\t  /* FALLTHROUGH */\n\tcase 3:\n\t  HASHC;\n\t  /* FALLTHROUGH */\n\tcase 2:\n\t  HASHC;\n\t  /* FALLTHROUGH */\n\tcase 1:\n\t  HASHC;\n\t  /* FALLTHROUGH */\n\t}\n\n      uint32_t c0, c1, c2, c3;\n      for (--len; len >= 4; len -= 4)\n\t{\n\t  c0 = (unsigned char) *(key + 0);\n\t  c1 = (unsigned char) *(key + 1);\n\t  c2 = (unsigned char) *(key + 2);\n\t  c3 = (unsigned char) *(key + 3);\n\t  h = HASH_CONST_P4 * h + HASH_CONST_P3 * c0 + HASH_CONST_P2 * c1\n\t      + HASH_CONST_P1 * c2 + HASH_CONST_P0 * c3;\n\n\t  key += 4;\n\t}\n    }\n  return h;\n}",
    "__nss_disable_nscd": "__nss_disable_nscd (void (*cb) (size_t, struct traced_file *)){\n  void (*cb1) (size_t, struct traced_file *);\n  cb1 = cb;\n  PTR_MANGLE (cb);\n  nscd_init_cb = cb;\n  is_nscd = true;\n\n  /* Find all the relevant modules so that the init functions are called.  */\n  nss_load_all_libraries (nss_database_passwd);\n  nss_load_all_libraries (nss_database_group);\n  nss_load_all_libraries (nss_database_hosts);\n  nss_load_all_libraries (nss_database_services);\n\n  /* Make sure NSCD purges its cache if nsswitch.conf changes.  */\n  init_traced_file (&pwd_traced_file.file, _PATH_NSSWITCH_CONF, 0);\n  cb1 (pwddb, &pwd_traced_file.file);\n  init_traced_file (&grp_traced_file.file, _PATH_NSSWITCH_CONF, 0);\n  cb1 (grpdb, &grp_traced_file.file);\n  init_traced_file (&hst_traced_file.file, _PATH_NSSWITCH_CONF, 0);\n  cb1 (hstdb, &hst_traced_file.file);\n  init_traced_file (&serv_traced_file.file, _PATH_NSSWITCH_CONF, 0);\n  cb1 (servdb, &serv_traced_file.file);\n  init_traced_file (&netgr_traced_file.file, _PATH_NSSWITCH_CONF, 0);\n  cb1 (netgrdb, &netgr_traced_file.file);\n\n  /* Disable all uses of NSCD.  */\n  __nss_not_use_nscd_passwd = -1;\n  __nss_not_use_nscd_group = -1;\n  __nss_not_use_nscd_hosts = -1;\n  __nss_not_use_nscd_services = -1;\n  __nss_not_use_nscd_netgroup = -1;\n}",
    "__nss_parse_line_result": "__nss_parse_line_result (FILE *fp, off64_t offset, int parse_line_result){\n  assert (parse_line_result >= -1 && parse_line_result <= 1);\n\n  switch (__builtin_expect (parse_line_result, 1))\n    {\n    case 1:\n      /* Success.  */\n      return 0;\n    case 0:\n      /* Parse error.  */\n      __set_errno (EINVAL);\n      return EINVAL;\n    case -1:\n      /* Out of buffer space.  */\n      return __nss_readline_seek (fp, offset);\n\n      default:\n        __builtin_unreachable ();\n    }\n}",
    "__nss_readline": "__nss_readline (FILE *fp, char *buf, size_t len, off64_t *poffset){\n  /* We need space for at least one character, the line terminator,\n     and the NUL byte.  */\n  if (len < 3)\n    {\n      *poffset = -1;\n      __set_errno (ERANGE);\n      return ERANGE;\n    }\n\n  while (true)\n    {\n      /* Keep original offset for retries.  */\n      *poffset = __ftello64 (fp);\n\n      buf[len - 1] = '\\xff';        /* Marker to recognize truncation.  */\n      if (__fgets_unlocked (buf, len, fp) == NULL)\n        {\n          if (__feof_unlocked (fp))\n            {\n              __set_errno (ENOENT);\n              return ENOENT;\n            }\n          else\n            {\n              /* Any other error.  Do not return ERANGE in this case\n                 because the caller would retry.  */\n              if (errno == ERANGE)\n                __set_errno (EINVAL);\n              return errno;\n            }\n        }\n      else if (buf[len - 1] != '\\xff')\n        /* The buffer is too small.  Arrange for re-reading the same\n           line on the next call.  */\n        return __nss_readline_seek (fp, *poffset);\n\n      /* __fgets_unlocked succeeded.  */\n\n      /* Remove leading whitespace.  */\n      char *p = buf;\n      while (isspace (*p))\n        ++p;\n      if (*p == '\\0' || *p == '#')\n        /* Skip empty lines and comments.  */\n        continue;\n      if (p != buf)\n        memmove (buf, p, strlen (p));\n\n      /* Return line to the caller.  */\n      return 0;\n    }\n}",
    "__nss_lookup": "__nss_lookup (nss_action_list *ni, const char *fct_name, const char *fct2_name,\n\t      void **fctp){\n  *fctp = __nss_lookup_function (*ni, fct_name);\n  if (*fctp == NULL && fct2_name != NULL)\n    *fctp = __nss_lookup_function (*ni, fct2_name);\n\n  while (*fctp == NULL\n\t && nss_next_action (*ni, NSS_STATUS_UNAVAIL) == NSS_ACTION_CONTINUE\n\t && (*ni)[1].module != NULL)\n    {\n      ++(*ni);\n\n      *fctp = __nss_lookup_function (*ni, fct_name);\n      if (*fctp == NULL && fct2_name != NULL)\n\t*fctp = __nss_lookup_function (*ni, fct2_name);\n    }\n\n  return *fctp != NULL ? 0 : (*ni)[1].module == NULL ? 1 : -1;\n}",
    "__nss_next2": "__nss_next2 (nss_action_list *ni, const char *fct_name, const char *fct2_name,\n\t     void **fctp, int status, int all_values){\n  if (all_values)\n    {\n      if (nss_next_action (*ni, NSS_STATUS_TRYAGAIN) == NSS_ACTION_RETURN\n\t  && nss_next_action (*ni, NSS_STATUS_UNAVAIL) == NSS_ACTION_RETURN\n\t  && nss_next_action (*ni, NSS_STATUS_NOTFOUND) == NSS_ACTION_RETURN\n\t  && nss_next_action (*ni, NSS_STATUS_SUCCESS) == NSS_ACTION_RETURN)\n\treturn 1;\n    }\n  else\n    {\n      /* This is really only for debugging.  */\n      if (__builtin_expect (NSS_STATUS_TRYAGAIN > status\n\t\t\t    || status > NSS_STATUS_RETURN, 0))\n\t __libc_fatal (\"Illegal status in __nss_next.\\n\");\n\n       if (nss_next_action (*ni, status) == NSS_ACTION_RETURN)\n\t return 1;\n    }\n\n  if ((*ni)[1].module == NULL)\n    return -1;\n\n  do\n    {\n      ++(*ni);\n\n      *fctp = __nss_lookup_function (*ni, fct_name);\n      if (*fctp == NULL && fct2_name != NULL)\n\t*fctp = __nss_lookup_function (*ni, fct2_name);\n    }\n  while (*fctp == NULL\n\t && nss_next_action (*ni, NSS_STATUS_UNAVAIL) == NSS_ACTION_CONTINUE\n\t && (*ni)[1].module != NULL);\n\n  return *fctp != NULL ? 0 : -1;\n}",
    "__nss_lookup_function": "*\n__nss_lookup_function (nss_action_list ni, const char *fct_name){\n  if (ni->module == NULL)\n    return NULL;\n  return __nss_module_get_function (ni->module, fct_name);\n}",
    "putgrent": "putgrent (const struct group *gr, FILE *stream){\n  int retval;\n\n  if (__glibc_unlikely (gr == NULL) || __glibc_unlikely (stream == NULL)\n      || gr->gr_name == NULL || !__nss_valid_field (gr->gr_name)\n      || !__nss_valid_field (gr->gr_passwd)\n      || !__nss_valid_list_field (gr->gr_mem))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  flockfile (stream);\n\n  if (gr->gr_name[0] == '+' || gr->gr_name[0] == '-')\n    retval = fprintf (stream, \"%s:%s::\",\n\t\t      gr->gr_name, _S (gr->gr_passwd));\n  else\n    retval = fprintf (stream, \"%s:%s:%lu:\",\n\t\t      gr->gr_name, _S (gr->gr_passwd),\n\t\t      (unsigned long int) gr->gr_gid);\n  if (__builtin_expect (retval, 0) < 0)\n    {\n      funlockfile (stream);\n      return -1;\n    }\n\n  if (gr->gr_mem != NULL)\n    {\n      for (size_t i = 0; gr->gr_mem[i] != NULL; i++)\n\tif (fprintf (stream, i == 0 ? \"%s\" : \",%s\", gr->gr_mem[i]) < 0)\n\t  {\n\t    /* What else can we do?  */\n\t    funlockfile (stream);\n\t    return -1;\n\t  }\n    }\n\n  retval = fputc_unlocked ('\\n', stream);\n\n  funlockfile (stream);\n\n  return retval < 0 ? -1 : 0;\n}",
    "putpwent": "putpwent (const struct passwd *p, FILE *stream){\n  if (p == NULL || stream == NULL\n      || p->pw_name == NULL || !__nss_valid_field (p->pw_name)\n      || !__nss_valid_field (p->pw_passwd)\n      || !__nss_valid_field (p->pw_dir)\n      || !__nss_valid_field (p->pw_shell))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  int ret;\n  char *gecos_alloc;\n  const char *gecos = __nss_rewrite_field (p->pw_gecos, &gecos_alloc);\n\n  if (gecos == NULL)\n    return -1;\n\n  if (p->pw_name[0] == '+' || p->pw_name[0] == '-')\n      ret = fprintf (stream, \"%s:%s:::%s:%s:%s\\n\",\n\t\t     p->pw_name, _S (p->pw_passwd),\n\t\t     gecos, _S (p->pw_dir), _S (p->pw_shell));\n  else\n      ret = fprintf (stream, \"%s:%s:%lu:%lu:%s:%s:%s\\n\",\n\t\t     p->pw_name, _S (p->pw_passwd),\n\t\t     (unsigned long int) p->pw_uid,\n\t\t     (unsigned long int) p->pw_gid,\n\t\t     gecos, _S (p->pw_dir), _S (p->pw_shell));\n\n  free (gecos_alloc);\n  if (ret >= 0)\n    ret = 0;\n  return ret;\n}",
    "putsgent": "putsgent (const struct sgrp *g, FILE *stream){\n  int errors = 0;\n\n  if (g->sg_namp == NULL || !__nss_valid_field (g->sg_namp)\n      || !__nss_valid_field (g->sg_passwd)\n      || !__nss_valid_list_field (g->sg_adm)\n      || !__nss_valid_list_field (g->sg_mem))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  _IO_flockfile (stream);\n\n  if (fprintf (stream, \"%s:%s:\", g->sg_namp, _S (g->sg_passwd)) < 0)\n    ++errors;\n\n  bool first = true;\n  char **sp = g->sg_adm;\n  if (sp != NULL)\n    while (*sp != NULL)\n      {\n\tif (fprintf (stream, \"%s%s\", first ? \"\" : \",\", *sp++) < 0)\n\t  {\n\t    ++errors;\n\t    break;\n\t  }\n\tfirst = false;\n      }\n  if (putc_unlocked (':', stream) == EOF)\n    ++errors;\n\n  first = true;\n  sp = g->sg_mem;\n  if (sp != NULL)\n    while (*sp != NULL)\n      {\n\tif (fprintf (stream, \"%s%s\", first ? \"\" : \",\", *sp++) < 0)\n\t  {\n\t    ++errors;\n\t    break;\n\t  }\n\tfirst = false;\n      }\n  if (putc_unlocked ('\\n', stream) == EOF)\n    ++errors;\n\n  _IO_funlockfile (stream);\n\n  return errors ? -1 : 0;\n}",
    "putspent": "putspent (const struct spwd *p, FILE *stream){\n  int errors = 0;\n\n  if (p->sp_namp == NULL || !__nss_valid_field (p->sp_namp)\n      || !__nss_valid_field (p->sp_pwdp))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  flockfile (stream);\n\n  if (fprintf (stream, \"%s:%s:\", p->sp_namp, _S (p->sp_pwdp)) < 0)\n    ++errors;\n\n  if ((p->sp_lstchg != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_lstchg) < 0)\n      || (p->sp_lstchg == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_min != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_min) < 0)\n      || (p->sp_min == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_max != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_max) < 0)\n      || (p->sp_max == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_warn != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_warn) < 0)\n      || (p->sp_warn == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_inact != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_inact) < 0)\n      || (p->sp_inact == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if ((p->sp_expire != (long int) -1\n       && fprintf (stream, \"%ld:\", p->sp_expire) < 0)\n      || (p->sp_expire == (long int) -1\n\t  && putc_unlocked (':', stream) == EOF))\n    ++errors;\n\n  if (p->sp_flag != ~0ul\n      && fprintf (stream, \"%ld\", p->sp_flag) < 0)\n    ++errors;\n\n  if (putc_unlocked ('\\n', stream) == EOF)\n    ++errors;\n\n  funlockfile (stream);\n\n  return errors ? -1 : 0;\n}",
    "sgetsgent": "*\nsgetsgent (const char *string){\n  static char *buffer;\n  static size_t buffer_size;\n  static struct sgrp resbuf;\n  struct sgrp *result;\n  int save;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && __sgetsgent_r (string, &resbuf, buffer, buffer_size, &result) != 0\n\t && errno == ERANGE)\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "sgetspent": "*\nsgetspent (const char *string){\n  static char *buffer;\n  static size_t buffer_size;\n  static struct spwd resbuf;\n  struct spwd *result;\n  int save;\n\n  /* Get lock.  */\n  __libc_lock_lock (lock);\n\n  /* Allocate buffer if not yet available.  */\n  if (buffer == NULL)\n    {\n      buffer_size = BUFLEN_SPWD;\n      buffer = malloc (buffer_size);\n    }\n\n  while (buffer != NULL\n\t && (__sgetspent_r (string, &resbuf, buffer, buffer_size, &result)\n\t     == ERANGE))\n    {\n      char *new_buf;\n      buffer_size += BUFLEN_SPWD;\n      new_buf = realloc (buffer, buffer_size);\n      if (new_buf == NULL)\n\t{\n\t  /* We are out of memory.  Free the current buffer so that the\n\t     process gets a chance for a normal termination.  */\n\t  save = errno;\n\t  free (buffer);\n\t  __set_errno (save);\n\t}\n      buffer = new_buf;\n    }\n\n  if (buffer == NULL)\n    result = NULL;\n\n  /* Release lock.  Preserve error value.  */\n  save = errno;\n  __libc_lock_unlock (lock);\n  __set_errno (save);\n\n  return result;\n}",
    "_nss_files_setaliasent": "_nss_files_setaliasent (void){\n  return __nss_files_data_setent (nss_file_aliasent, \"/etc/aliases\");\n}",
    "_nss_files_endaliasent": "_nss_files_endaliasent (void){\n  return __nss_files_data_endent (nss_file_aliasent);\n}",
    "_nss_files_getaliasent_r": "_nss_files_getaliasent_r (struct aliasent *result, char *buffer, size_t buflen,\n\t\t\t  int *errnop){\n  /* Return next entry in host file.  */\n\n  struct nss_files_per_file_data *data;\n  enum nss_status status = __nss_files_data_open (&data, nss_file_aliasent,\n\t\t\t\t\t\t  \"/etc/aliases\", errnop, NULL);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  result->alias_local = 1;\n\n  /* Read lines until we get a definite result.  */\n  do\n    status = get_next_alias (data->stream, NULL, result, buffer, buflen,\n\t\t\t     errnop);\n  while (status == NSS_STATUS_RETURN);\n\n  __nss_files_data_put (data);\n  return status;\n}",
    "_nss_files_getaliasbyname_r": "_nss_files_getaliasbyname_r (const char *name, struct aliasent *result,\n\t\t\t     char *buffer, size_t buflen, int *errnop){\n  /* Return next entry in host file.  */\n  enum nss_status status = NSS_STATUS_SUCCESS;\n  FILE *stream = NULL;\n\n  if (name == NULL)\n    {\n      __set_errno (EINVAL);\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  /* Open the stream.  */\n  status = internal_setent (&stream);\n\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      result->alias_local = 1;\n\n      /* Read lines until we get a definite result.  */\n      do\n\tstatus = get_next_alias (stream, name, result, buffer, buflen, errnop);\n      while (status == NSS_STATUS_RETURN);\n\n      fclose (stream);\n    }\n\n  return status;\n}",
    "_nss_files_gethostbyname3_r": "_nss_files_gethostbyname3_r (const char *name, int af, struct hostent *result,\n\t\t\t     char *buffer, size_t buflen, int *errnop,\n\t\t\t     int *herrnop, int32_t *ttlp, char **canonp){\n  FILE *stream = NULL;\n  uintptr_t pad = -(uintptr_t) buffer % __alignof__ (struct hostent_data);\n  buffer += pad;\n  buflen = buflen > pad ? buflen - pad : 0;\n\n  /* Open file.  */\n  enum nss_status status = internal_setent (&stream);\n\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      while ((status = internal_getent (stream, result, buffer, buflen, errnop,\n\t\t\t\t\therrnop, af, 0))\n\t     == NSS_STATUS_SUCCESS)\n\t{\n\t  LOOKUP_NAME_CASE (h_name, h_aliases)\n\t}\n\n      if (status == NSS_STATUS_SUCCESS\n\t  && _res_hconf.flags & HCONF_FLAG_MULTI)\n\tstatus = gethostbyname3_multi\n\t  (stream, name, af, result, buffer, buflen, errnop, herrnop);\n\n      fclose (stream);\n    }\n\n  if (canonp && status == NSS_STATUS_SUCCESS)\n    *canonp = result->h_name;\n\n  return status;\n}",
    "_nss_files_gethostbyname_r": "_nss_files_gethostbyname_r (const char *name, struct hostent *result,\n\t\t\t    char *buffer, size_t buflen, int *errnop,\n\t\t\t    int *herrnop){\n  return _nss_files_gethostbyname3_r (name, AF_INET, result, buffer, buflen,\n\t\t\t\t      errnop, herrnop, NULL, NULL);\n}",
    "_nss_files_gethostbyname2_r": "_nss_files_gethostbyname2_r (const char *name, int af, struct hostent *result,\n\t\t\t     char *buffer, size_t buflen, int *errnop,\n\t\t\t     int *herrnop){\n  return _nss_files_gethostbyname3_r (name, af, result, buffer, buflen,\n\t\t\t\t      errnop, herrnop, NULL, NULL);\n}",
    "_nss_files_gethostbyname4_r": "_nss_files_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,\n\t\t\t     char *buffer, size_t buflen, int *errnop,\n\t\t\t     int *herrnop, int32_t *ttlp){\n  FILE *stream = NULL;\n\n  /* Open file.  */\n  enum nss_status status = internal_setent (&stream);\n\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      bool any = false;\n      bool got_canon = false;\n      while (1)\n\t{\n\t  /* Align the buffer for the next record.  */\n\t  uintptr_t pad = (-(uintptr_t) buffer\n\t\t\t   % __alignof__ (struct hostent_data));\n\t  buffer += pad;\n\t  buflen = buflen > pad ? buflen - pad : 0;\n\n\t  struct hostent result;\n\t  status = internal_getent (stream, &result, buffer, buflen, errnop,\n\t\t\t\t    herrnop, AF_UNSPEC, 0);\n\t  if (status != NSS_STATUS_SUCCESS)\n\t    break;\n\n\t  int naliases = 0;\n\t  if (__strcasecmp (name, result.h_name) != 0)\n\t    {\n\t      for (; result.h_aliases[naliases] != NULL; ++naliases)\n\t\tif (! __strcasecmp (name, result.h_aliases[naliases]))\n\t\t  break;\n\t      if (result.h_aliases[naliases] == NULL)\n\t\tcontinue;\n\n\t      /* We know this alias exist.  Count it.  */\n\t      ++naliases;\n\t    }\n\n\t  /* Determine how much memory has been used so far.  */\n\t  // XXX It is not necessary to preserve the aliases array\n\t  while (result.h_aliases[naliases] != NULL)\n\t    ++naliases;\n\t  char *bufferend = (char *) &result.h_aliases[naliases + 1];\n\t  assert (buflen >= bufferend - buffer);\n\t  buflen -= bufferend - buffer;\n\t  buffer = bufferend;\n\n\t  /* We found something.  */\n\t  any = true;\n\n\t  /* Create the record the caller expects.  There is only one\n\t     address.  */\n\t  assert (result.h_addr_list[1] == NULL);\n\t  if (*pat == NULL)\n\t    {\n\t      uintptr_t pad = (-(uintptr_t) buffer\n\t\t\t       % __alignof__ (struct gaih_addrtuple));\n\t      buffer += pad;\n\t      buflen = buflen > pad ? buflen - pad : 0;\n\n\t      if (__builtin_expect (buflen < sizeof (struct gaih_addrtuple),\n\t\t\t\t    0))\n\t\t{\n\t\t  *errnop = ERANGE;\n\t\t  *herrnop = NETDB_INTERNAL;\n\t\t  status = NSS_STATUS_TRYAGAIN;\n\t\t  break;\n\t\t}\n\n\t      *pat = (struct gaih_addrtuple *) buffer;\n\t      buffer += sizeof (struct gaih_addrtuple);\n\t      buflen -= sizeof (struct gaih_addrtuple);\n\t    }\n\n\t  (*pat)->next = NULL;\n\t  (*pat)->name = got_canon ? NULL : result.h_name;\n\t  got_canon = true;\n\t  (*pat)->family = result.h_addrtype;\n\t  memcpy ((*pat)->addr, result.h_addr_list[0], result.h_length);\n\t  (*pat)->scopeid = 0;\n\n\t  pat = &((*pat)->next);\n\n\t  /* If we only look for the first matching entry we are done.  */\n\t  if ((_res_hconf.flags & HCONF_FLAG_MULTI) == 0)\n\t    break;\n\t}\n\n      /* If we have to look for multiple records and found one, this\n\t is a success.  */\n      if (status == NSS_STATUS_NOTFOUND && any)\n\t{\n\t  assert ((_res_hconf.flags & HCONF_FLAG_MULTI) != 0);\n\t  status = NSS_STATUS_SUCCESS;\n\t}\n\n      fclose (stream);\n    }\n  else if (status == NSS_STATUS_TRYAGAIN)\n    {\n      *errnop = errno;\n      *herrnop = TRY_AGAIN;\n    }\n  else\n    {\n      *errnop = errno;\n      *herrnop = NO_DATA;\n    }\n\n  return status;\n}",
    "_nss_files_init": "_nss_files_init (void (*cb) (size_t, struct traced_file *)){\n  register_file (cb, pwddb, \"/etc/passwd\", 0);\n  register_file (cb, grpdb, \"/etc/group\", 0);\n  register_file (cb, hstdb, \"/etc/hosts\", 0);\n  register_file (cb, hstdb, \"/etc/resolv.conf\", 1);\n  register_file (cb, servdb, \"/etc/services\", 0);\n  register_file (cb, netgrdb, \"/etc/netgroup\", 0);\n}",
    "_nss_files_initgroups_dyn": "_nss_files_initgroups_dyn (const char *user, gid_t group, long int *start,\n\t\t\t   long int *size, gid_t **groupsp, long int limit,\n\t\t\t   int *errnop){\n  FILE *stream = __nss_files_fopen (\"/etc/group\");\n  if (stream == NULL)\n    {\n      *errnop = errno;\n      return *errnop == ENOMEM ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;\n    }\n\n  char *line = NULL;\n  size_t linelen = 0;\n  enum nss_status status = NSS_STATUS_SUCCESS;\n  bool any = false;\n\n  struct scratch_buffer tmpbuf;\n  scratch_buffer_init (&tmpbuf);\n\n  gid_t *groups = *groupsp;\n\n  /* We have to iterate over the entire file.  */\n  while (1)\n    {\n      fpos_t pos;\n      fgetpos (stream, &pos);\n      ssize_t n = __getline (&line, &linelen, stream);\n      if (n < 0)\n\t{\n\t  if (! __feof_unlocked (stream))\n\t    status = ((*errnop = errno) == ENOMEM\n\t\t      ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL);\n\t  break;\n\t}\n\n      struct group grp;\n      int res = _nss_files_parse_grent (line, &grp,\n\t\t\t\t\ttmpbuf.data, tmpbuf.length, errnop);\n      if (res == -1)\n\t{\n\t  if (!scratch_buffer_grow (&tmpbuf))\n\t    {\n\t      *errnop = ENOMEM;\n\t      status = NSS_STATUS_TRYAGAIN;\n\t      goto out;\n\t    }\n\t  /* Reread current line, the parser has clobbered it.  */\n\t  fsetpos (stream, &pos);\n\t  continue;\n\t}\n\n      if (res > 0 && grp.gr_gid != group)\n\tfor (char **m = grp.gr_mem; *m != NULL; ++m)\n\t  if (strcmp (*m, user) == 0)\n\t    {\n\t      /* Matches user.  Insert this group.  */\n\t      if (*start == *size)\n\t\t{\n\t\t  /* Need a bigger buffer.  */\n\t\t  if (limit > 0 && *size == limit)\n\t\t    /* We reached the maximum.  */\n\t\t    goto out;\n\n\t\t  long int newsize;\n\t\t  if (limit <= 0)\n\t\t    newsize = 2 * *size;\n\t\t  else\n\t\t    newsize = MIN (limit, 2 * *size);\n\n\t\t  gid_t *newgroups = realloc (groups,\n\t\t\t\t\t      newsize * sizeof (*groups));\n\t\t  if (newgroups == NULL)\n\t\t    {\n\t\t      *errnop = ENOMEM;\n\t\t      status = NSS_STATUS_TRYAGAIN;\n\t\t      goto out;\n\t\t    }\n\t\t  *groupsp = groups = newgroups;\n\t\t  *size = newsize;\n\t\t}\n\n\t      groups[*start] = grp.gr_gid;\n\t      *start += 1;\n\t      any = true;\n\n\t      break;\n\t    }\n    }\n\n out:\n  /* Free memory.  */\n  scratch_buffer_free (&tmpbuf);\n  free (line);\n\n  fclose (stream);\n\n  return status == NSS_STATUS_SUCCESS && !any ? NSS_STATUS_NOTFOUND : status;\n}",
    "_nss_files_setnetgrent": "_nss_files_setnetgrent (const char *group, struct __netgrent *result){\n  FILE *fp;\n  enum nss_status status;\n\n  if (group[0] == '\\0')\n    return NSS_STATUS_UNAVAIL;\n\n  /* Find the netgroups file and open it.  */\n  fp = __nss_files_fopen (DATAFILE);\n  if (fp == NULL)\n    status = errno == EAGAIN ? NSS_STATUS_TRYAGAIN : NSS_STATUS_UNAVAIL;\n  else\n    {\n      /* Read the file line by line and try to find the description\n\t GROUP.  We must take care for long lines.  */\n      char *line = NULL;\n      size_t line_len = 0;\n      const ssize_t group_len = strlen (group);\n\n      status = NSS_STATUS_NOTFOUND;\n      result->cursor = result->data;\n\n      while (!__feof_unlocked (fp))\n\t{\n\t  ssize_t curlen = __getline (&line, &line_len, fp);\n\t  int found;\n\n\t  if (curlen < 0)\n\t    {\n\t      status = NSS_STATUS_NOTFOUND;\n\t      break;\n\t    }\n\n\t  found = (curlen > group_len && strncmp (line, group, group_len) == 0\n\t\t   && isspace (line[group_len]));\n\n\t  /* Read the whole line (including continuation) and store it\n\t     if FOUND in nonzero.  Otherwise we don't need it.  */\n\t  if (found)\n\t    {\n\t      /* Store the data from the first line.  */\n\t      EXPAND (curlen - group_len);\n\t      memcpy (result->cursor, &line[group_len + 1],\n\t\t      curlen - group_len);\n\t      result->cursor += (curlen - group_len) - 1;\n\t    }\n\n\t  while (curlen > 1 && line[curlen - 1] == '\\n'\n\t\t && line[curlen - 2] == '\\\\')\n\t    {\n\t      /* Yes, we have a continuation line.  */\n\t      if (found)\n\t\t/* Remove these characters from the stored line.  */\n\t\tresult->cursor -= 2;\n\n\t      /* Get next line.  */\n\t      curlen = __getline (&line, &line_len, fp);\n\t      if (curlen <= 0)\n\t\tbreak;\n\n\t      if (found)\n\t\t{\n\t\t  /* Make sure we have enough room.  */\n\t\t  EXPAND (1 + curlen + 1);\n\n\t\t  /* Add separator in case next line starts immediately.  */\n\t\t  *result->cursor++ = ' ';\n\n\t\t  /* Copy new line.  */\n\t\t  memcpy (result->cursor, line, curlen + 1);\n\t\t  result->cursor += curlen;\n\t\t}\n\t    }\n\n\t  if (found)\n\t    {\n\t      /* Now we have read the line.  */\n\t      status = NSS_STATUS_SUCCESS;\n\t      result->cursor = result->data;\n\t      result->first = 1;\n\t      break;\n\t    }\n\t}\n\n    the_end:\n      /* We don't need the file and the line buffer anymore.  */\n      free (line);\n      fclose (fp);\n\n      if (status != NSS_STATUS_SUCCESS)\n\t_nss_files_endnetgrent (result);\n    }\n\n  return status;\n}",
    "_nss_files_endnetgrent": "_nss_files_endnetgrent (struct __netgrent *result){\n  /* Free allocated memory for data if some is present.  */\n  free (result->data);\n  result->data = NULL;\n  result->data_size = 0;\n  result->cursor = NULL;\n  return NSS_STATUS_SUCCESS;\n}",
    "_nss_netgroup_parseline": "_nss_netgroup_parseline (char **cursor, struct __netgrent *result,\n\t\t\t char *buffer, size_t buflen, int *errnop){\n  enum nss_status status;\n  const char *host, *user, *domain;\n  char *cp = *cursor;\n\n  /* Some sanity checks.  */\n  if (cp == NULL)\n    return NSS_STATUS_NOTFOUND;\n\n  /* First skip leading spaces.  */\n  while (isspace (*cp))\n    ++cp;\n\n  if (*cp != '(')\n    {\n      /* We have a list of other netgroups.  */\n      char *name = cp;\n\n      while (*cp != '\\0' && ! isspace (*cp))\n\t++cp;\n\n      if (name != cp)\n\t{\n\t  /* It is another netgroup name.  */\n\t  int last = *cp == '\\0';\n\n\t  result->type = group_val;\n\t  result->val.group = name;\n\t  *cp = '\\0';\n\t  if (! last)\n\t    ++cp;\n\t  *cursor = cp;\n\t  result->first = 0;\n\n\t  return NSS_STATUS_SUCCESS;\n\t}\n\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n    }\n\n  /* Match host name.  */\n  host = ++cp;\n  while (*cp != ',')\n    if (*cp++ == '\\0')\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n\n  /* Match user name.  */\n  user = ++cp;\n  while (*cp != ',')\n    if (*cp++ == '\\0')\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n\n  /* Match domain name.  */\n  domain = ++cp;\n  while (*cp != ')')\n    if (*cp++ == '\\0')\n      return result->first ? NSS_STATUS_NOTFOUND : NSS_STATUS_RETURN;\n  ++cp;\n\n\n  /* When we got here we have found an entry.  Before we can copy it\n     to the private buffer we have to make sure it is big enough.  */\n  if (cp - host > buflen)\n    {\n      *errnop = ERANGE;\n      status = NSS_STATUS_TRYAGAIN;\n    }\n  else\n    {\n      memcpy (buffer, host, cp - host);\n      result->type = triple_val;\n\n      buffer[(user - host) - 1] = '\\0';\t/* Replace ',' with '\\0'.  */\n      result->val.triple.host = strip_whitespace (buffer);\n\n      buffer[(domain - host) - 1] = '\\0'; /* Replace ',' with '\\0'.  */\n      result->val.triple.user = strip_whitespace (buffer + (user - host));\n\n      buffer[(cp - host) - 1] = '\\0'; /* Replace ')' with '\\0'.  */\n      result->val.triple.domain = strip_whitespace (buffer + (domain - host));\n\n      status = NSS_STATUS_SUCCESS;\n\n      /* Remember where we stopped reading.  */\n      *cursor = cp;\n\n      result->first = 0;\n    }\n\n  return status;\n}",
    "_nss_files_getnetgrent_r": "_nss_files_getnetgrent_r (struct __netgrent *result, char *buffer,\n\t\t\t  size_t buflen, int *errnop){\n  enum nss_status status;\n\n  status = _nss_netgroup_parseline (&result->cursor, result, buffer, buflen,\n\t\t\t\t    errnop);\n\n  return status;\n}",
    "_Fork": "_Fork (void){\n  pid_t pid = arch_fork (&THREAD_SELF->tid);\n  if (pid == 0)\n    {\n      struct pthread *self = THREAD_SELF;\n\n      /* Initialize the robust mutex list setting in the kernel which has\n\t been reset during the fork.  We do not check for errors because if\n\t it fails here, it must have failed at process startup as well and\n\t nobody could have used robust mutexes.\n\t Before we do that, we have to clear the list of robust mutexes\n\t because we do not inherit ownership of mutexes from the parent.\n\t We do not have to set self->robust_head.futex_offset since we do\n\t inherit the correct value from the parent.  We do not need to clear\n\t the pending operation because it must have been zero when fork was\n\t called.  */\n#if __PTHREAD_MUTEX_HAVE_PREV\n      self->robust_prev = &self->robust_head;\n#endif\n      self->robust_head.list = &self->robust_head;\n      INTERNAL_SYSCALL_CALL (set_robust_list, &self->robust_head,\n\t\t\t     sizeof (struct robust_list_head));\n    }\n  return pid;\n}",
    "_exit": "_exit (int status){\n  while (1)\n    {\n      INLINE_SYSCALL (exit_group, 1, status);\n\n#ifdef ABORT_INSTRUCTION\n      ABORT_INSTRUCTION;\n#endif\n    }\n}",
    "alarm": "alarm (unsigned int seconds){\n  struct itimerval old, new;\n  unsigned int retval;\n\n  new.it_interval.tv_usec = 0;\n  new.it_interval.tv_sec = 0;\n  new.it_value.tv_usec = 0;\n  new.it_value.tv_sec = (long int) seconds;\n  if (__setitimer (ITIMER_REAL, &new, &old) < 0)\n    return 0;\n\n  retval = old.it_value.tv_sec;\n  /* Round to the nearest second, but never report zero seconds when\n     the alarm is still set.  */\n  if (old.it_value.tv_usec >= 500000\n      || (retval == 0 && old.it_value.tv_usec > 0))\n    ++retval;\n  return retval;\n}",
    "__bsd_getpgrp": "__bsd_getpgrp (pid_t pid){\n  return __getpgid (pid);\n}",
    "execl": "execl (const char *path, const char *arg, ...){\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n\n  /* Avoid dynamic memory allocation due two main issues:\n     1. The function should be async-signal-safe and a running on a signal\n        handler with a fail outcome might lead to malloc bad state.\n     2. It might be used in a vfork/clone(VFORK) scenario where using\n        malloc also might lead to internal bad state.  */\n  ptrdiff_t i;\n  char *argv[argc + 1];\n  va_start (ap, arg);\n  argv[0] = (char *) arg;\n  for (i = 1; i <= argc; i++)\n    argv[i] = va_arg (ap, char *);\n  va_end (ap);\n\n  return __execve (path, argv, __environ);\n}",
    "execle": "execle (const char *path, const char *arg, ...){\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n\n  /* Avoid dynamic memory allocation due two main issues:\n     1. The function should be async-signal-safe and a running on a signal\n        handler with a fail outcome might lead to malloc bad state.\n     2. It might be used in a vfork/clone(VFORK) scenario where using\n        malloc also might lead to internal bad state.  */\n  ptrdiff_t i;\n  char *argv[argc + 1];\n  char **envp;\n  va_start (ap, arg);\n  argv[0] = (char *) arg;\n  for (i = 1; i <= argc; i++)\n    argv[i] = va_arg (ap, char *);\n  envp = va_arg (ap, char **);\n  va_end (ap);\n\n  return __execve (path, argv, envp);\n}",
    "execlp": "execlp (const char *file, const char *arg, ...){\n  ptrdiff_t argc;\n  va_list ap;\n  va_start (ap, arg);\n  for (argc = 1; va_arg (ap, const char *); argc++)\n    {\n      if (argc == INT_MAX)\n\t{\n\t  va_end (ap);\n\t  errno = E2BIG;\n\t  return -1;\n\t}\n    }\n  va_end (ap);\n\n  /* Although posix does not state execlp as an async-safe function\n     it can not use malloc to allocate the arguments since it might\n     be used in a vfork scenario and it may lead to malloc internal\n     bad state.  */\n  ptrdiff_t i;\n  char *argv[argc + 1];\n  va_start (ap, arg);\n  argv[0] = (char *) arg;\n  for (i = 1; i <= argc; i++)\n    argv[i] = va_arg (ap, char *);\n  va_end (ap);\n\n  return __execvpe (file, argv, __environ);\n}",
    "execv": "execv (const char *path, char *const argv[]){\n  return __execve (path, argv, __environ);\n}",
    "execvp": "execvp (const char *file, char *const argv[]){\n  return __execvpe (file, argv, __environ);\n}",
    "fexecve": "fexecve (int fd, char *const argv[], char *const envp[]){\n  if (fd < 0 || argv == NULL || envp == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n#ifdef __NR_execveat\n  /* Avoid implicit array coercion in syscall macros.  */\n  INLINE_SYSCALL (execveat, 5, fd, \"\", &argv[0], &envp[0], AT_EMPTY_PATH);\n# ifndef __ASSUME_EXECVEAT\n  if (errno != ENOSYS)\n    return -1;\n# endif\n#endif\n\n#ifndef __ASSUME_EXECVEAT\n  /* We use the /proc filesystem to get the information.  If it is not\n     mounted we fail.  We do not need the return value.  */\n  struct fd_to_filename filename;\n  __execve (__fd_to_filename (fd, &filename), argv, envp);\n\n  int save = errno;\n\n  /* We come here only if the 'execve' call fails.  Determine whether\n     /proc is mounted.  If not we return ENOSYS.  */\n  struct __stat64_t64 st;\n  if (__stat64_time64 (\"/proc/self/fd\", &st) != 0 && errno == ENOENT)\n    save = ENOSYS;\n\n  __set_errno (save);\n#endif\n\n  return -1;\n}",
    "fnmatch": "fnmatch (const char *pattern, const char *string, int flags){\n  if (__glibc_unlikely (MB_CUR_MAX != 1))\n    {\n      size_t n;\n      struct scratch_buffer wpattern;\n      scratch_buffer_init (&wpattern);\n      struct scratch_buffer wstring;\n      scratch_buffer_init (&wstring);\n      int r;\n\n      /* Convert the strings into wide characters.  Any conversion issue\n         fallback to the ascii version.  */\n      r = fnmatch_convert_to_wide (pattern, &wpattern, &n);\n      if (r == 0)\n        {\n          r = fnmatch_convert_to_wide (string, &wstring, &n);\n          if (r == 0)\n            r = internal_fnwmatch (wpattern.data, wstring.data,\n                                   (wchar_t *) wstring.data + n,\n                                   flags & FNM_PERIOD, flags, NULL);\n        }\n\n      scratch_buffer_free (&wstring);\n      scratch_buffer_free (&wpattern);\n\n      if (r == -2 || r == 0)\n        return r;\n    }\n\n  return internal_fnmatch (pattern, string, string + strlen (string),\n                           flags & FNM_PERIOD, flags, NULL);\n}",
    "__libc_fork": "__libc_fork (void){\n  /* Determine if we are running multiple threads.  We skip some fork\n     handlers in the single-thread case, to make fork safer to use in\n     signal handlers.  Although POSIX has dropped async-signal-safe\n     requirement for fork (Austin Group tracker issue #62) this is\n     best effort to make is async-signal-safe at least for single-thread\n     case.  */\n  bool multiple_threads = !SINGLE_THREAD_P;\n  uint64_t lastrun;\n\n  lastrun = __run_prefork_handlers (multiple_threads);\n\n  struct nss_database_data nss_database_data;\n\n  /* If we are not running multiple threads, we do not have to\n     preserve lock state.  If fork runs from a signal handler, only\n     async-signal-safe functions can be used in the child.  These data\n     structures are only used by unsafe functions, so their state does\n     not matter if fork was called from a signal handler.  */\n  if (multiple_threads)\n    {\n      call_function_static_weak (__nss_database_fork_prepare_parent,\n\t\t\t\t &nss_database_data);\n\n      _IO_list_lock ();\n\n      /* Acquire malloc locks.  This needs to come last because fork\n\t handlers may use malloc, and the libio list lock has an\n\t indirect malloc dependency as well (via the getdelim\n\t function).  */\n      call_function_static_weak (__malloc_fork_lock_parent);\n    }\n\n  pid_t pid = _Fork ();\n\n  if (pid == 0)\n    {\n      fork_system_setup ();\n\n      /* Reset the lock state in the multi-threaded case.  */\n      if (multiple_threads)\n\t{\n\t  __libc_unwind_link_after_fork ();\n\n\t  fork_system_setup_after_fork ();\n\n\t  /* Release malloc locks.  */\n\t  call_function_static_weak (__malloc_fork_unlock_child);\n\n\t  /* Reset the file list.  These are recursive mutexes.  */\n\t  fresetlockfiles ();\n\n\t  /* Reset locks in the I/O code.  */\n\t  _IO_list_resetlock ();\n\n\t  call_function_static_weak (__nss_database_fork_subprocess,\n\t\t\t\t     &nss_database_data);\n\t}\n\n      /* Reset the lock the dynamic loader uses to protect its data.  */\n      __rtld_lock_initialize (GL(dl_load_lock));\n\n      /* Reset the lock protecting dynamic TLS related data.  */\n      __rtld_lock_initialize (GL(dl_load_tls_lock));\n\n      reclaim_stacks ();\n\n      /* Run the handlers registered for the child.  */\n      __run_postfork_handlers (atfork_run_child, multiple_threads, lastrun);\n    }\n  else\n    {\n      /* If _Fork failed, preserve its errno value.  */\n      int save_errno = errno;\n\n      /* Release acquired locks in the multi-threaded case.  */\n      if (multiple_threads)\n\t{\n\t  /* Release malloc locks, parent process variant.  */\n\t  call_function_static_weak (__malloc_fork_unlock_parent);\n\n\t  /* We execute this even if the 'fork' call failed.  */\n\t  _IO_list_unlock ();\n\t}\n\n      /* Run the handlers registered for the parent.  */\n      __run_postfork_handlers (atfork_run_parent, multiple_threads, lastrun);\n\n      if (pid < 0)\n\t__set_errno (save_errno);\n    }\n\n  return pid;\n}",
    "gai_strerror": "*\ngai_strerror (int code){\n  const char *result = \"Unknown error\";\n  for (size_t i = 0; i < sizeof (msgidx) / sizeof (msgidx[0]); ++i)\n    if (msgidx[i].code == code)\n      {\n\tresult = msgstr.str + msgidx[i].idx;\n\tbreak;\n      }\n\n  return _(result);\n}",
    "getopt_long": "getopt_long (int argc, char *__getopt_argv_const *argv, const char *options,\n\t     const struct option *long_options, int *opt_index){\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 0, 0);\n}",
    "getopt_long_only": "getopt_long_only (int argc, char *__getopt_argv_const *argv,\n\t\t  const char *options,\n\t\t  const struct option *long_options, int *opt_index){\n  return _getopt_internal (argc, (char **) argv, options, long_options,\n\t\t\t   opt_index, 1, 0);\n}",
    "__getpgid": "__getpgid (pid_t pid){\n  error_t err;\n  pid_t pgrp;\n\n  if (pid == 0)\n    {\n      /* Assume atomic word fetch and store, so don't lock _hurd_pid_lock.  */\n      pgrp = _hurd_pgrp;\n      err = 0;\n    }\n  else\n    err = __USEPORT (PROC, __proc_getpgrp (port, pid, &pgrp));\n\n  return err ? __hurd_fail (err) : pgrp;\n}",
    "getpgrp": "getpgrp (void){\n  return __getpgid (0);\n}",
    "__getpid": "__getpid (void){\n  /* Assumes atomic word fetch and store, so doesn't lock _hurd_pid_lock.  */\n  return _hurd_pid;\n}",
    "getsid": "getsid (pid_t pid){\n  error_t err;\n  pid_t sid;\n\n  if (pid == 0)\n    pid = _hurd_pid;\n\n  err = __USEPORT (PROC, __proc_getsid (port, pid, &sid));\n  if (err)\n    return (pid_t) __hurd_fail (err);\n  return sid;\n}",
    "glob64": "GLOB_ATTRIBUTE\nglob64 (const char *pattern, int flags,\n\tint (*errfunc) (const char *, int), glob64_t *pglob){\n  if (pattern == NULL || pglob == NULL || (flags & ~__GLOB_FLAGS) != 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return GLOB_NOSYS;\n}",
    "globfree": "globfree (glob_t *pglob){\n  if (pglob->gl_pathv != NULL)\n    {\n      size_t i;\n      for (i = 0; i < pglob->gl_pathc; ++i)\n        free (pglob->gl_pathv[pglob->gl_offs + i]);\n      free (pglob->gl_pathv);\n      pglob->gl_pathv = NULL;\n    }\n}",
    "globfree64": "globfree64 (glob64_t *pglob){\n}",
    "__nanosleep": "__nanosleep (const struct timespec *req, struct timespec *rem){\n  struct __timespec64 treq64, trem64;\n\n  treq64 = valid_timespec_to_timespec64 (*req);\n  int ret = __nanosleep64 (&treq64, rem != NULL ? &trem64 : NULL);\n\n  if (ret != 0 && errno == EINTR && rem != NULL)\n    *rem = valid_timespec64_to_timespec (trem64);\n  return ret;\n}",
    "pause": "pause (void){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "posix_madvise": "posix_madvise (void *addr, size_t len, int advice){\n  /* We have one problem: the kernel's MADV_DONTNEED does not\n     correspond to POSIX's POSIX_MADV_DONTNEED.  The former simply\n     discards changes made to the memory without writing it back to\n     disk, if this would be necessary.  The POSIX behavior does not\n     allow this.  There is no functionality mapping the POSIX behavior\n     so far so we ignore that advice for now.  */\n  if (advice == POSIX_MADV_DONTNEED)\n    return 0;\n\n  int result = INTERNAL_SYSCALL_CALL (madvise, addr, len, advice);\n  return INTERNAL_SYSCALL_ERRNO (result);\n}",
    "__libc_pread": "__libc_pread (int fd, void *buf, size_t count, off_t offset){\n  return SYSCALL_CANCEL (pread64, fd, buf, count, SYSCALL_LL_PRW (offset));\n}",
    "__libc_pwrite": "__libc_pwrite (int fd, const void *buf, size_t count, off_t offset){\n  return SYSCALL_CANCEL (pwrite64, fd, buf, count, SYSCALL_LL_PRW (offset));\n}",
    "re_compile_pattern": "*\nre_compile_pattern (const char *pattern, size_t length,\n\t\t    struct re_pattern_buffer *bufp){\n  reg_errcode_t ret;\n\n  /* And GNU code determines whether or not to get register information\n     by passing null for the REGS argument to re_match, etc., not by\n     setting no_sub, unless RE_NO_SUB is set.  */\n  bufp->no_sub = !!(re_syntax_options & RE_NO_SUB);\n\n  /* Match anchors at newline.  */\n  bufp->newline_anchor = 1;\n\n  ret = re_compile_internal (bufp, pattern, length, re_syntax_options);\n\n  if (!ret)\n    return NULL;\n  return gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
    "re_set_syntax": "re_set_syntax (reg_syntax_t syntax){\n  reg_syntax_t ret = re_syntax_options;\n\n  re_syntax_options = syntax;\n  return ret;\n}",
    "re_compile_fastmap": "re_compile_fastmap (struct re_pattern_buffer *bufp){\n  re_dfa_t *dfa = bufp->buffer;\n  char *fastmap = bufp->fastmap;\n\n  memset (fastmap, '\\0', sizeof (char) * SBC_MAX);\n  re_compile_fastmap_iter (bufp, dfa->init_state, fastmap);\n  if (dfa->init_state != dfa->init_state_word)\n    re_compile_fastmap_iter (bufp, dfa->init_state_word, fastmap);\n  if (dfa->init_state != dfa->init_state_nl)\n    re_compile_fastmap_iter (bufp, dfa->init_state_nl, fastmap);\n  if (dfa->init_state != dfa->init_state_begbuf)\n    re_compile_fastmap_iter (bufp, dfa->init_state_begbuf, fastmap);\n  bufp->fastmap_accurate = 1;\n  return 0;\n}",
    "regcomp": "regcomp (regex_t *__restrict preg, const char *__restrict pattern, int cflags){\n  reg_errcode_t ret;\n  reg_syntax_t syntax = ((cflags & REG_EXTENDED) ? RE_SYNTAX_POSIX_EXTENDED\n\t\t\t : RE_SYNTAX_POSIX_BASIC);\n\n  preg->buffer = NULL;\n  preg->allocated = 0;\n  preg->used = 0;\n\n  /* Try to allocate space for the fastmap.  */\n  preg->fastmap = re_malloc (char, SBC_MAX);\n  if (__glibc_unlikely (preg->fastmap == NULL))\n    return REG_ESPACE;\n\n  syntax |= (cflags & REG_ICASE) ? RE_ICASE : 0;\n\n  /* If REG_NEWLINE is set, newlines are treated differently.  */\n  if (cflags & REG_NEWLINE)\n    { /* REG_NEWLINE implies neither . nor [^...] match newline.  */\n      syntax &= ~RE_DOT_NEWLINE;\n      syntax |= RE_HAT_LISTS_NOT_NEWLINE;\n      /* It also changes the matching behavior.  */\n      preg->newline_anchor = 1;\n    }\n  else\n    preg->newline_anchor = 0;\n  preg->no_sub = !!(cflags & REG_NOSUB);\n  preg->translate = NULL;\n\n  ret = re_compile_internal (preg, pattern, strlen (pattern), syntax);\n\n  /* POSIX doesn't distinguish between an unmatched open-group and an\n     unmatched close-group: both are REG_EPAREN.  */\n  if (ret == REG_ERPAREN)\n    ret = REG_EPAREN;\n\n  /* We have already checked preg->fastmap != NULL.  */\n  if (__glibc_likely (ret == REG_NOERROR))\n    /* Compute the fastmap now, since regexec cannot modify the pattern\n       buffer.  This function never fails in this implementation.  */\n    (void) re_compile_fastmap (preg);\n  else\n    {\n      /* Some error occurred while compiling the expression.  */\n      re_free (preg->fastmap);\n      preg->fastmap = NULL;\n    }\n\n  return (int) ret;\n}",
    "regerror": "size_t\nregerror (int errcode, const regex_t *__restrict preg, char *__restrict errbuf,\n\t  size_t errbuf_size){\n  const char *msg;\n  size_t msg_size;\n  int nerrcodes = sizeof __re_error_msgid_idx / sizeof __re_error_msgid_idx[0];\n\n  if (__glibc_unlikely (errcode < 0 || errcode >= nerrcodes))\n    /* Only error codes returned by the rest of the code should be passed\n       to this routine.  If we are given anything else, or if other regex\n       code generates an invalid error code, then the program has a bug.\n       Dump core so we can fix it.  */\n    abort ();\n\n  msg = gettext (__re_error_msgid + __re_error_msgid_idx[errcode]);\n\n  msg_size = strlen (msg) + 1; /* Includes the null.  */\n\n  if (__glibc_likely (errbuf_size != 0))\n    {\n      size_t cpy_size = msg_size;\n      if (__glibc_unlikely (msg_size > errbuf_size))\n\t{\n\t  cpy_size = errbuf_size - 1;\n\t  errbuf[cpy_size] = '\\0';\n\t}\n      memcpy (errbuf, msg, cpy_size);\n    }\n\n  return msg_size;\n}",
    "regfree": "regfree (regex_t *preg){\n  re_dfa_t *dfa = preg->buffer;\n  if (__glibc_likely (dfa != NULL))\n    {\n      lock_fini (dfa->lock);\n      free_dfa_content (dfa);\n    }\n  preg->buffer = NULL;\n  preg->allocated = 0;\n\n  re_free (preg->fastmap);\n  preg->fastmap = NULL;\n\n  re_free (preg->translate);\n  preg->translate = NULL;\n}",
    "re_comp": "re_comp (const char *s){\n  reg_errcode_t ret;\n  char *fastmap;\n\n  if (!s)\n    {\n      if (!re_comp_buf.buffer)\n\treturn gettext (\"No previous regular expression\");\n      return 0;\n    }\n\n  if (re_comp_buf.buffer)\n    {\n      fastmap = re_comp_buf.fastmap;\n      re_comp_buf.fastmap = NULL;\n      __regfree (&re_comp_buf);\n      memset (&re_comp_buf, '\\0', sizeof (re_comp_buf));\n      re_comp_buf.fastmap = fastmap;\n    }\n\n  if (re_comp_buf.fastmap == NULL)\n    {\n      re_comp_buf.fastmap = re_malloc (char, SBC_MAX);\n      if (re_comp_buf.fastmap == NULL)\n\treturn (char *) gettext (__re_error_msgid\n\t\t\t\t + __re_error_msgid_idx[(int) REG_ESPACE]);\n    }\n\n  /* Since 're_exec' always passes NULL for the 'regs' argument, we\n     don't need to initialize the pattern buffer fields which affect it.  */\n\n  /* Match anchors at newlines.  */\n  re_comp_buf.newline_anchor = 1;\n\n  ret = re_compile_internal (&re_comp_buf, s, strlen (s), re_syntax_options);\n\n  if (!ret)\n    return NULL;\n\n  /* Yes, we're discarding 'const' here if !HAVE_LIBINTL.  */\n  return (char *) gettext (__re_error_msgid + __re_error_msgid_idx[(int) ret]);\n}",
    "regexec": "regexec (const regex_t *__restrict preg, const char *__restrict string,\n\t size_t nmatch, regmatch_t pmatch[_REGEX_NELTS (nmatch)], int eflags){\n  reg_errcode_t err;\n  Idx start, length;\n  re_dfa_t *dfa = preg->buffer;\n\n  if (eflags & ~(REG_NOTBOL | REG_NOTEOL | REG_STARTEND))\n    return REG_BADPAT;\n\n  if (eflags & REG_STARTEND)\n    {\n      start = pmatch[0].rm_so;\n      length = pmatch[0].rm_eo;\n    }\n  else\n    {\n      start = 0;\n      length = strlen (string);\n    }\n\n  lock_lock (dfa->lock);\n  if (preg->no_sub)\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, 0, NULL, eflags);\n  else\n    err = re_search_internal (preg, string, length, start, length,\n\t\t\t      length, nmatch, pmatch, eflags);\n  lock_unlock (dfa->lock);\n  return err != REG_NOERROR;\n}",
    "re_match": "re_match (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t  Idx start, struct re_registers *regs){\n  return re_search_stub (bufp, string, length, start, 0, length, regs, true);\n}",
    "re_search": "re_search (struct re_pattern_buffer *bufp, const char *string, Idx length,\n\t   Idx start, regoff_t range, struct re_registers *regs){\n  return re_search_stub (bufp, string, length, start, range, length, regs,\n\t\t\t false);\n}",
    "re_match_2": "re_match_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t    const char *string2, Idx length2, Idx start,\n\t    struct re_registers *regs, Idx stop){\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, 0, regs, stop, true);\n}",
    "re_search_2": "re_search_2 (struct re_pattern_buffer *bufp, const char *string1, Idx length1,\n\t     const char *string2, Idx length2, Idx start, regoff_t range,\n\t     struct re_registers *regs, Idx stop){\n  return re_search_2_stub (bufp, string1, length1, string2, length2,\n\t\t\t   start, range, regs, stop, false);\n}",
    "re_set_registers": "re_set_registers (struct re_pattern_buffer *bufp, struct re_registers *regs,\n\t\t  __re_size_t num_regs, regoff_t *starts, regoff_t *ends){\n  if (num_regs)\n    {\n      bufp->regs_allocated = REGS_REALLOCATE;\n      regs->num_regs = num_regs;\n      regs->start = starts;\n      regs->end = ends;\n    }\n  else\n    {\n      bufp->regs_allocated = REGS_UNALLOCATED;\n      regs->num_regs = 0;\n      regs->start = regs->end = NULL;\n    }\n}",
    "re_exec": "re_exec (const char *s){\n  return 0 == regexec (&re_comp_buf, s, 0, NULL, 0);\n}",
    "__register_atfork": "__register_atfork (void (*prepare) (void), void (*parent) (void),\n\t\t   void (*child) (void), void *dso_handle){\n  lll_lock (atfork_lock, LLL_PRIVATE);\n\n  if (fork_handler_counter == 0)\n    fork_handler_list_init (&fork_handlers);\n\n  struct fork_handler *newp = fork_handler_list_emplace (&fork_handlers);\n  if (newp != NULL)\n    {\n      newp->prepare_handler = prepare;\n      newp->parent_handler = parent;\n      newp->child_handler = child;\n      newp->dso_handle = dso_handle;\n\n      /* IDs assigned to handlers start at 1 and increment with handler\n         registration.  Un-registering a handlers discards the corresponding\n         ID.  It is not reused in future registrations.  */\n      if (INT_ADD_OVERFLOW (fork_handler_counter, 1))\n        __libc_fatal (\"fork handler counter overflow\");\n      newp->id = ++fork_handler_counter;\n    }\n\n  /* Release the lock.  */\n  lll_unlock (atfork_lock, LLL_PRIVATE);\n\n  return newp == NULL ? ENOMEM : 0;\n}",
    "__sched_cpualloc": "*\n__sched_cpualloc (size_t count){\n  return malloc (CPU_ALLOC_SIZE (count));\n}",
    "__sched_cpucount": "__sched_cpucount (size_t setsize, const cpu_set_t *setp){\n  int s = 0;\n  for (int i = 0; i < setsize / sizeof (__cpu_mask); i++)\n    s += countbits (setp->__bits[i]);\n  return s;\n}",
    "__sched_cpufree": "__sched_cpufree (cpu_set_t *set){\n  free (set);\n}",
    "sched_getaffinity": "sched_getaffinity (pid_t pid, size_t cpusetsize, cpu_set_t *cpuset){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_getparam": "__sched_getparam (pid_t pid, struct sched_param *param){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_getscheduler": "__sched_getscheduler (pid_t pid){\n  return SCHED_OTHER;\n}",
    "__sched_get_priority_max": "__sched_get_priority_max (int algorithm){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_get_priority_min": "__sched_get_priority_min (int algorithm){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sched_setaffinity": "sched_setaffinity (pid_t pid, size_t cpusetsize, const cpu_set_t *cpuset){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sched_setscheduler": "__sched_setscheduler (pid_t pid, int policy, const struct sched_param *param){\n  switch (policy)\n    {\n    case SCHED_OTHER:\n      if (param->sched_priority != 0)\n\treturn __hurd_fail (EINVAL);\n      break;\n\n    case SCHED_FIFO:\n    case SCHED_RR:\n      return __hurd_fail (ENOTSUP);\n\n    default:\n      return EINVAL;\n    }\n  return 0;\n}",
    "__sched_yield": "__sched_yield (void){\n  (void) __swtch ();\n  return 0;\n}",
    "setgroups": "setgroups (size_t n, const gid_t *groups){\n#ifdef __NR_setgroups32\n  return INLINE_SETXID_SYSCALL (setgroups32, 2, n, groups);\n#else\n  return INLINE_SETXID_SYSCALL (setgroups, 2, n, groups);\n#endif\n}",
    "__setpgid": "__setpgid (pid_t pid, pid_t pgid){\n  error_t err;\n  unsigned int stamp;\n\n  stamp = _hurd_pids_changed_stamp; /* Atomic fetch.  */\n\n  if (err = __USEPORT (PROC, __proc_setpgrp (port, pid, pgid)))\n    return __hurd_fail (err);\n\n  if (pid == 0 || pid == _hurd_pid)\n    /* Synchronize with the signal thread to make sure we have\n       received and processed proc_newids before returning to the user.  */\n    while (_hurd_pids_changed_stamp == stamp)\n      lll_wait (_hurd_pids_changed_stamp, stamp, 0);\n\n  return 0;\n\n}",
    "setpgrp": "setpgrp (void){\n  return __setpgid (0, 0);\n}",
    "__shm_get_name": "__shm_get_name (struct shmdir_name *result, const char *name, bool sem_prefix){\n  struct alloc_buffer buffer;\n  size_t namelen;\n\n  buffer = alloc_buffer_create (result->name, sizeof (result->name));\n  alloc_buffer_copy_bytes (&buffer, SHMDIR, strlen (SHMDIR));\n\n#if defined (SHM_ANON) && defined (O_TMPFILE)\n  if (name == SHM_ANON)\n    {\n      /* For SHM_ANON, we want shm_open () to pass O_TMPFILE to open (),\n         with SHMDIR itself as the path.  So, leave it at that.  */\n      alloc_buffer_add_byte (&buffer, 0);\n      if (alloc_buffer_has_failed (&buffer))\n        return -1;\n      return 0;\n    }\n#endif\n\n  while (name[0] == '/')\n    ++name;\n  namelen = strlen (name);\n\n  if (sem_prefix)\n    alloc_buffer_copy_bytes (&buffer, \"sem.\", strlen (\"sem.\"));\n  alloc_buffer_copy_bytes (&buffer, name, namelen + 1);\n  if (namelen == 0 || memchr (name, '/', namelen) != NULL)\n    return EINVAL;\n  if (alloc_buffer_has_failed (&buffer))\n    {\n      if (namelen > NAME_MAX)\n        return ENAMETOOLONG;\n      return EINVAL;\n    }\n  return 0;\n}",
    "posix_spawn_file_actions_addchdir_np": "posix_spawn_file_actions_addchdir_np (posix_spawn_file_actions_t *file_actions,\n                                      const char *path){\n  struct __spawn_action *rec;\n\n  char *path_copy = __strdup (path);\n  if (path_copy == NULL)\n    return ENOMEM;\n\n  /* Allocate more memory if needed.  */\n  if (file_actions->__used == file_actions->__allocated\n      && __posix_spawn_file_actions_realloc (file_actions) != 0)\n    {\n      /* This can only mean we ran out of memory.  */\n      free (path_copy);\n      return ENOMEM;\n    }\n\n  /* Add the new value.  */\n  rec = &file_actions->__actions[file_actions->__used];\n  rec->tag = spawn_do_chdir;\n  rec->action.chdir_action.path = path_copy;\n\n  /* Account for the new entry.  */\n  ++file_actions->__used;\n\n  return 0;\n}",
    "posix_spawn_file_actions_addfchdir_np": "posix_spawn_file_actions_addfchdir_np (posix_spawn_file_actions_t *actions,\n                                       int fd){\n  struct __spawn_action *rec;\n\n  /* Allocate more memory if needed.  */\n  if (actions->__used == actions->__allocated\n      && __posix_spawn_file_actions_realloc (actions) != 0)\n    /* This can only mean we ran out of memory.  */\n    return ENOMEM;\n\n  /* Add the new value.  */\n  rec = &actions->__actions[actions->__used];\n  rec->tag = spawn_do_fchdir;\n  rec->action.fchdir_action.fd = fd;\n\n  /* Account for the new entry.  */\n  ++actions->__used;\n\n  return 0;\n}",
    "posix_spawnattr_getsigdefault": "posix_spawnattr_getsigdefault (const posix_spawnattr_t *attr,\n\t\t\t       sigset_t *sigdefault){\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (sigdefault, &attr->__sd, sizeof (sigset_t));\n\n  return 0;\n}",
    "posix_spawnattr_getflags": "posix_spawnattr_getflags (const posix_spawnattr_t *attr, short int *flags){\n  /* Copy the flag word.  */\n  *flags = attr->__flags;\n\n  return 0;\n}",
    "posix_spawnattr_getpgroup": "posix_spawnattr_getpgroup (const posix_spawnattr_t *attr, pid_t *pgroup){\n  /* Copy the process group ID.  */\n  *pgroup = attr->__pgrp;\n\n  return 0;\n}",
    "posix_spawnattr_getschedparam": "posix_spawnattr_getschedparam (const posix_spawnattr_t *attr,\n\t\t\t       struct sched_param *schedparam){\n  /* Copy the scheduling parameters.  */\n  memcpy (schedparam, &attr->__sp, sizeof (attr->__sp));\n\n  return 0;\n}",
    "posix_spawnattr_getschedpolicy": "posix_spawnattr_getschedpolicy (const posix_spawnattr_t *attr,\n\t\t\t\tint *schedpolicy){\n  /* Copy the scheduling policy.  */\n  *schedpolicy = attr->__policy;\n\n  return 0;\n}",
    "posix_spawnattr_getsigmask": "posix_spawnattr_getsigmask (const posix_spawnattr_t *attr,\n\t\t\t    sigset_t *sigmask){\n  /* Copy the sigset_t data to the user buffer.  */\n  memcpy (sigmask, &attr->__ss, sizeof (sigset_t));\n\n  return 0;\n}",
    "posix_spawnattr_setpgroup": "posix_spawnattr_setpgroup (posix_spawnattr_t *attr, pid_t pgroup){\n  /* Store the process group ID.  */\n  attr->__pgrp = pgroup;\n\n  return 0;\n}",
    "posix_spawnattr_setschedparam": "posix_spawnattr_setschedparam (posix_spawnattr_t *attr,\n\t\t\t       const struct sched_param *schedparam){\n  /* Store the scheduling parameters.  */\n  attr->__sp = *schedparam;\n\n  return 0;\n}",
    "posix_spawnattr_setschedpolicy": "posix_spawnattr_setschedpolicy (posix_spawnattr_t *attr, int schedpolicy){\n  if (schedpolicy != SCHED_OTHER && schedpolicy != SCHED_FIFO\n      && schedpolicy != SCHED_RR)\n    return EINVAL;\n\n  /* Store the policy.  */\n  attr->__policy = schedpolicy;\n\n  return 0;\n}",
    "fattach": "attribute_compat_text_section\nfattach (int fildes, const char *path){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "fdetach": "attribute_compat_text_section\nfdetach (const char *path){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getmsg": "attribute_compat_text_section\ngetmsg (int fildes, struct strbuf *ctlptr, struct strbuf *dataptr, int *flagsp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getpmsg": "attribute_compat_text_section\ngetpmsg (int fildes, struct strbuf *ctlptr, struct strbuf *dataptr, int *bandp,\n\t int *flagsp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "isastream": "attribute_compat_text_section\nisastream (int fildes){\n  /* In general we do not have a STREAMS implementation and therefore\n     return 0.  But for invalid file descriptors we have to return an\n     error.  */\n  if (__fcntl (fildes, F_GETFD) < 0)\n    return -1;\n\n  /* No STREAM.  */\n  return 0;\n}",
    "putmsg": "attribute_compat_text_section\nputmsg (int fildes, const struct strbuf *ctlptr, const struct strbuf *dataptr,\n\tint flags){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "putpmsg": "attribute_compat_text_section\nputpmsg (int fildes, const struct strbuf *ctlptr, const struct strbuf *dataptr,\n\t int band, int flags){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__sysconf": "__sysconf (int name){\n  if (name >= _SC_LEVEL1_ICACHE_SIZE && name <= _SC_LEVEL4_CACHE_LINESIZE)\n    return __cache_sysconf (name);\n\n  return linux_sysconf (name);\n}",
    "__vfork": "__vfork (void){\n  return __fork ();\n}",
    "__wait": "__wait (int *stat_loc){\n  return __waitpid (WAIT_ANY, stat_loc, 0);\n}",
    "__waitpid": "__waitpid (pid_t pid, int *stat_loc, int options){\n  return __wait4 (pid, stat_loc, options, NULL);\n}",
    "wordfree": "wordfree (wordexp_t *pwordexp){\n\n  /* wordexp can set pwordexp to NULL */\n  if (pwordexp && pwordexp->we_wordv)\n    {\n      char **wordv = pwordexp->we_wordv;\n\n      for (wordv += pwordexp->we_offs; *wordv; ++wordv)\n\tfree (*wordv);\n\n      free (pwordexp->we_wordv);\n      pwordexp->we_wordv = NULL;\n    }\n}",
    "wordexp": "wordexp (const char *words, wordexp_t *pwordexp, int flags){\n  size_t words_offset;\n  size_t word_length;\n  size_t max_length;\n  char *word = w_newword (&word_length, &max_length);\n  int error;\n  char *ifs;\n  char ifs_white[4];\n  wordexp_t old_word = *pwordexp;\n\n  if (flags & WRDE_REUSE)\n    {\n      /* Minimal implementation of WRDE_REUSE for now */\n      wordfree (pwordexp);\n      old_word.we_wordv = NULL;\n    }\n\n  if ((flags & WRDE_APPEND) == 0)\n    {\n      pwordexp->we_wordc = 0;\n\n      if (flags & WRDE_DOOFFS)\n\t{\n\t  pwordexp->we_wordv = calloc (1 + pwordexp->we_offs, sizeof (char *));\n\t  if (pwordexp->we_wordv == NULL)\n\t    {\n\t      error = WRDE_NOSPACE;\n\t      goto do_error;\n\t    }\n\t}\n      else\n\t{\n\t  pwordexp->we_wordv = calloc (1, sizeof (char *));\n\t  if (pwordexp->we_wordv == NULL)\n\t    {\n\t      error = WRDE_NOSPACE;\n\t      goto do_error;\n\t    }\n\n\t  pwordexp->we_offs = 0;\n\t}\n    }\n\n  /* Find out what the field separators are.\n   * There are two types: whitespace and non-whitespace.\n   */\n  ifs = getenv (\"IFS\");\n\n  if (ifs == NULL)\n    /* IFS unset - use <space><tab><newline>. */\n    ifs = strcpy (ifs_white, \" \\t\\n\");\n  else\n    {\n      char *ifsch = ifs;\n      char *whch = ifs_white;\n\n      while (*ifsch != '\\0')\n\t{\n\t  if (*ifsch == ' ' || *ifsch == '\\t' || *ifsch == '\\n')\n\t    {\n\t      /* Whitespace IFS.  See first whether it is already in our\n\t\t collection.  */\n\t      char *runp = ifs_white;\n\n\t      while (runp < whch && *runp != *ifsch)\n\t\t++runp;\n\n\t      if (runp == whch)\n\t\t*whch++ = *ifsch;\n\t    }\n\n\t  ++ifsch;\n\t}\n      *whch = '\\0';\n    }\n\n  for (words_offset = 0 ; words[words_offset] ; ++words_offset)\n    switch (words[words_offset])\n      {\n      case '\\\\':\n\terror = parse_backslash (&word, &word_length, &max_length, words,\n\t\t\t\t &words_offset);\n\n\tif (error)\n\t  goto do_error;\n\n\tbreak;\n\n      case '$':\n\terror = parse_dollars (&word, &word_length, &max_length, words,\n\t\t\t       &words_offset, flags, pwordexp, ifs, ifs_white,\n\t\t\t       0);\n\n\tif (error)\n\t  goto do_error;\n\n\tbreak;\n\n      case '`':\n\t++words_offset;\n\terror = parse_backtick (&word, &word_length, &max_length, words,\n\t\t\t\t&words_offset, flags, pwordexp, ifs,\n\t\t\t\tifs_white);\n\n\tif (error)\n\t  goto do_error;\n\n\tbreak;\n\n      case '\"':\n\t++words_offset;\n\terror = parse_dquote (&word, &word_length, &max_length, words,\n\t\t\t      &words_offset, flags, pwordexp, ifs, ifs_white);\n\n\tif (error)\n\t  goto do_error;\n\n\tif (!word_length)\n\t  {\n\t    error = w_addword (pwordexp, NULL);\n\n\t    if (error)\n\t      return error;\n\t  }\n\n\tbreak;\n\n      case '\\'':\n\t++words_offset;\n\terror = parse_squote (&word, &word_length, &max_length, words,\n\t\t\t      &words_offset);\n\n\tif (error)\n\t  goto do_error;\n\n\tif (!word_length)\n\t  {\n\t    error = w_addword (pwordexp, NULL);\n\n\t    if (error)\n\t      return error;\n\t  }\n\n\tbreak;\n\n      case '~':\n\terror = parse_tilde (&word, &word_length, &max_length, words,\n\t\t\t     &words_offset, pwordexp->we_wordc);\n\n\tif (error)\n\t  goto do_error;\n\n\tbreak;\n\n      case '*':\n      case '[':\n      case '?':\n\terror = parse_glob (&word, &word_length, &max_length, words,\n\t\t\t    &words_offset, flags, pwordexp, ifs, ifs_white);\n\n\tif (error)\n\t  goto do_error;\n\n\tbreak;\n\n      default:\n\t/* Is it a word separator? */\n\tif (strchr (\" \\t\", words[words_offset]) == NULL)\n\t  {\n\t    char ch = words[words_offset];\n\n\t    /* Not a word separator -- but is it a valid word char? */\n\t    if (strchr (\"\\n|&;<>(){}\", ch))\n\t      {\n\t\t/* Fail */\n\t\terror = WRDE_BADCHAR;\n\t\tgoto do_error;\n\t      }\n\n\t    /* \"Ordinary\" character -- add it to word */\n\t    word = w_addchar (word, &word_length, &max_length,\n\t\t\t      ch);\n\t    if (word == NULL)\n\t      {\n\t\terror = WRDE_NOSPACE;\n\t\tgoto do_error;\n\t      }\n\n\t    break;\n\t  }\n\n\t/* If a word has been delimited, add it to the list. */\n\tif (word != NULL)\n\t  {\n\t    error = w_addword (pwordexp, word);\n\t    if (error)\n\t      goto do_error;\n\t  }\n\n\tword = w_newword (&word_length, &max_length);\n      }\n\n  /* End of string */\n\n  /* There was a word separator at the end */\n  if (word == NULL) /* i.e. w_newword */\n    return 0;\n\n  /* There was no field separator at the end */\n  return w_addword (pwordexp, word);\n\ndo_error:\n  /* Error:\n   *\tfree memory used (unless error is WRDE_NOSPACE), and\n   *\tset pwordexp members back to what they were.\n   */\n\n  free (word);\n\n  if (error == WRDE_NOSPACE)\n    return WRDE_NOSPACE;\n\n  if ((flags & WRDE_APPEND) == 0)\n    wordfree (pwordexp);\n\n  *pwordexp = old_word;\n  return error;\n}",
    "herror": "herror(const char *s){\n\tstruct iovec iov[4], *v = iov;\n\n\tif (s != NULL && *s != '\\0') {\n\t\tv->iov_base = (/*noconst*/ char *)s;\n\t\tv->iov_len = strlen(s);\n\t\tv++;\n\t\tv->iov_base = (char *) \": \";\n\t\tv->iov_len = 2;\n\t\tv++;\n\t}\n\tv->iov_base = (char *)hstrerror(h_errno);\n\tv->iov_len = strlen(v->iov_base);\n\tv++;\n\tv->iov_base = (char *) \"\\n\";\n\tv->iov_len = 1;\n\t__writev_nocancel_nostatus(STDERR_FILENO, iov, (v - iov) + 1);\n}",
    "hstrerror": "*\nhstrerror(int err){\n\tif (err < 0)\n\t\treturn _(\"Resolver internal error\");\n\telse if (err < h_nerr)\n\t\treturn _(h_errlist[err]);\n\treturn _(\"Unknown resolver error\");\n}",
    "__inet_aton_exact": "__inet_aton_exact (const char *cp, struct in_addr *addr){\n  struct in_addr val;\n  const char *endp;\n  /* Check that inet_aton_end parsed the entire string.  */\n  if (inet_aton_end (cp, &val, &endp) != 0 && *endp == 0)\n    {\n      *addr = val;\n      return 1;\n    }\n  else\n    return 0;\n}",
    "inet_ntop": "*\ninet_ntop (int af, const void *src, char *dst, socklen_t size){\n\tswitch (af) {\n\tcase AF_INET:\n\t\treturn (inet_ntop4(src, dst, size));\n\tcase AF_INET6:\n\t\treturn (inet_ntop6(src, dst, size));\n\tdefault:\n\t\t__set_errno (EAFNOSUPPORT);\n\t\treturn (NULL);\n\t}\n\t/* NOTREACHED */\n}",
    "__inet_pton_length": "__inet_pton_length (int af, const char *src, size_t srclen, void *dst){\n  switch (af)\n    {\n    case AF_INET:\n      return inet_pton4 (src, src + srclen, dst);\n    case AF_INET6:\n      return inet_pton6 (src, src + srclen, dst);\n    default:\n      __set_errno (EAFNOSUPPORT);\n      return -1;\n    }\n}",
    "__libc_ns_makecanon": "__libc_ns_makecanon (const char *src, char *dst, size_t dstsize){\n  size_t n = strlen (src);\n\n  if (n + sizeof \".\" > dstsize) /* sizeof == 2.  */\n    {\n      __set_errno (EMSGSIZE);\n      return -1;\n    }\n  strcpy (dst, src);\n  while (n >= 1U && dst[n - 1] == '.')   /* Ends in \".\".  */\n    if (n >= 2U && dst[n - 2] == '\\\\' && /* Ends in \"\\.\".  */\n        (n < 3U || dst[n - 3] != '\\\\'))  /* But not \"\\\\.\".  */\n      break;\n    else\n      dst[--n] = '\\0';\n  dst[n++] = '.';\n  dst[n] = '\\0';\n  return 0;\n}",
    "__libc_ns_samename": "__libc_ns_samename (const char *a, const char *b){\n  char ta[NS_MAXDNAME], tb[NS_MAXDNAME];\n\n  if (__libc_ns_makecanon (a, ta, sizeof ta) < 0 ||\n      __libc_ns_makecanon (b, tb, sizeof tb) < 0)\n    return -1;\n  if (__strcasecmp (ta, tb) == 0)\n    return 1;\n  else\n    return 0;\n}",
    "inet_nsap_addr": "inet_nsap_addr(const char *ascii, u_char *binary, int maxlen){\n\tu_char c, nib;\n\tu_int len = 0;\n\n\twhile ((c = *ascii++) != '\\0' && len < (u_int)maxlen) {\n\t\tif (c == '.' || c == '+' || c == '/')\n\t\t\tcontinue;\n\t\tif (!isascii(c))\n\t\t\treturn (0);\n\t\tc = toupper(c);\n\t\tif (isxdigit(c)) {\n\t\t\tnib = xtob(c);\n\t\t\tc = *ascii++;\n\t\t\tif (c != '\\0') {\n\t\t\t\tc = toupper(c);\n\t\t\t\tif (isxdigit(c)) {\n\t\t\t\t\t*binary++ = (nib << 4) | xtob(c);\n\t\t\t\t\tlen++;\n\t\t\t\t} else\n\t\t\t\t\treturn (0);\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn (0);\n\t\t}\n\t\telse\n\t\t\treturn (0);\n\t}\n\treturn (len);\n}",
    "inet_nsap_ntoa": "*\ninet_nsap_ntoa(int binlen, const u_char *binary, char *ascii){\n\tint nib;\n\tint i;\n\tstatic char tmpbuf[255*2 + 128];\n\tchar *start;\n\n\tif (ascii)\n\t\tstart = ascii;\n\telse {\n\t\tascii = tmpbuf;\n\t\tstart = tmpbuf;\n\t}\n\n\tif (binlen > 255)\n\t\tbinlen = 255;\n\n\tfor (i = 0; i < binlen; i++) {\n\t\tnib = *binary >> 4;\n\t\t*ascii++ = nib + (nib < 10 ? '0' : '7');\n\t\tnib = *binary++ & 0x0f;\n\t\t*ascii++ = nib + (nib < 10 ? '0' : '7');\n\t\tif (((i % 2) == 0 && (i + 1) < binlen))\n\t\t\t*ascii++ = '.';\n\t}\n\t*ascii = '\\0';\n\treturn (start);\n}",
    "__res_iclose": "__res_iclose (res_state statp, bool free_addr){\n  if (statp->_vcsock >= 0)\n    {\n      __close_nocancel_nostatus (statp->_vcsock);\n      statp->_vcsock = -1;\n      statp->_flags &= ~(RES_F_VC | RES_F_CONN);\n    }\n  for (int ns = 0; ns < statp->nscount; ns++)\n    if (statp->_u._ext.nsaddrs[ns] != NULL)\n      {\n        if (statp->_u._ext.nssocks[ns] != -1)\n          {\n            __close_nocancel_nostatus (statp->_u._ext.nssocks[ns]);\n            statp->_u._ext.nssocks[ns] = -1;\n          }\n        if (free_addr)\n          {\n            free (statp->_u._ext.nsaddrs[ns]);\n            statp->_u._ext.nsaddrs[ns] = NULL;\n          }\n      }\n  if (free_addr)\n    __resolv_conf_detach (statp);\n}",
    "__res_state": "*\n__res_state (void){\n  return __resp;\n}",
    "__res_context_hostalias": "*\n__res_context_hostalias (struct resolv_context *ctx,\n                         const char *name, char *dst, size_t siz){\n  char *file, *cp1, *cp2;\n  char buf[BUFSIZ];\n  FILE *fp;\n\n  if (ctx->resp->options & RES_NOALIASES)\n    return NULL;\n  file = getenv (\"HOSTALIASES\");\n  if (file == NULL || (fp = fopen (file, \"rce\")) == NULL)\n    return NULL;\n  buf[sizeof (buf) - 1] = '\\0';\n  while (__fgets_unlocked (buf, sizeof (buf), fp))\n    {\n      for (cp1 = buf; *cp1 && !isspace (*cp1); ++cp1)\n        ;\n      if (!*cp1)\n        break;\n      *cp1 = '\\0';\n      if (__libc_ns_samename (buf, name) == 1)\n        {\n          while (isspace (*++cp1))\n            ;\n          if (!*cp1)\n            break;\n          for (cp2 = cp1 + 1; *cp2 && !isspace (*cp2); ++cp2)\n            ;\n          *cp2 = '\\0';\n          strncpy (dst, cp1, siz - 1);\n          dst[siz - 1] = '\\0';\n          fclose (fp);\n          return dst;\n        }\n    }\n  fclose (fp);\n  return NULL;\n}",
    "__res_get_nsaddr": "*\n__res_get_nsaddr (res_state statp, unsigned int n){\n  assert (n < statp->nscount);\n\n  if (statp->nsaddr_list[n].sin_family == 0\n      && statp->_u._ext.nsaddrs[n] != NULL)\n    /* statp->_u._ext.nsaddrs[n] holds an address that is larger than\n       struct sockaddr, and user code did not update\n       statp->nsaddr_list[n].  */\n    return (struct sockaddr *) statp->_u._ext.nsaddrs[n];\n  else\n    /* User code updated statp->nsaddr_list[n], or statp->nsaddr_list[n]\n       has the same content as statp->_u._ext.nsaddrs[n].  */\n    return (struct sockaddr *) (void *) &statp->nsaddr_list[n];\n}",
    "__res_context_mkquery": "__res_context_mkquery (struct resolv_context *ctx, int op, const char *dname,\n                       int class, int type, const unsigned char *data,\n                       unsigned char *buf, int buflen){\n  UHEADER *hp;\n  unsigned char *cp;\n  int n;\n  unsigned char *dnptrs[20], **dpp, **lastdnptr;\n\n  if (class < 0 || class > 65535 || type < 0 || type > 65535)\n    return -1;\n\n  /* Initialize header fields.  */\n  if ((buf == NULL) || (buflen < HFIXEDSZ))\n    return -1;\n  memset (buf, 0, HFIXEDSZ);\n  hp = (UHEADER *) buf;\n  /* We randomize the IDs every time.  The old code just incremented\n     by one after the initial randomization which still predictable if\n     the application does multiple requests.  */\n  hp->id = random_bits ();\n  hp->opcode = op;\n  if (ctx->resp->options & RES_TRUSTAD)\n    hp->ad = 1;\n  hp->rd = (ctx->resp->options & RES_RECURSE) != 0;\n  hp->rcode = NOERROR;\n  cp = buf + HFIXEDSZ;\n  buflen -= HFIXEDSZ;\n  dpp = dnptrs;\n  *dpp++ = buf;\n  *dpp++ = NULL;\n  lastdnptr = dnptrs + sizeof dnptrs / sizeof dnptrs[0];\n\n  /* Perform opcode specific processing.  */\n  switch (op)\n    {\n    case NS_NOTIFY_OP:\n      if ((buflen -= QFIXEDSZ + (data == NULL ? 0 : RRFIXEDSZ)) < 0)\n        return -1;\n      goto compose;\n\n    case QUERY:\n      if ((buflen -= QFIXEDSZ) < 0)\n        return -1;\n    compose:\n      n = __ns_name_compress (dname, cp, buflen,\n                              (const unsigned char **) dnptrs,\n                              (const unsigned char **) lastdnptr);\n      if (n < 0)\n        return -1;\n      cp += n;\n      buflen -= n;\n      NS_PUT16 (type, cp);\n      NS_PUT16 (class, cp);\n      hp->qdcount = htons (1);\n      if (op == QUERY || data == NULL)\n        break;\n\n      /* Make an additional record for completion domain.  */\n      n = __ns_name_compress ((char *)data, cp, buflen,\n                              (const unsigned char **) dnptrs,\n                              (const unsigned char **) lastdnptr);\n      if (__glibc_unlikely (n < 0))\n        return -1;\n      cp += n;\n      buflen -= n;\n      NS_PUT16 (T_NULL, cp);\n      NS_PUT16 (class, cp);\n      NS_PUT32 (0, cp);\n      NS_PUT16 (0, cp);\n      hp->arcount = htons (1);\n      break;\n\n    default:\n      return -1;\n    }\n  return cp - buf;\n}",
    "__res_nopt": "__res_nopt (struct resolv_context *ctx,\n            int n0, unsigned char *buf, int buflen, int anslen){\n  uint16_t flags = 0;\n  UHEADER *hp = (UHEADER *) buf;\n  unsigned char *cp = buf + n0;\n  unsigned char *ep = buf + buflen;\n\n  if ((ep - cp) < 1 + RRFIXEDSZ)\n    return -1;\n\n  /* Add the root label.  */\n  *cp++ = 0;\n\n  NS_PUT16 (T_OPT, cp);         /* Record type.  */\n\n  /* Lowering the advertised buffer size based on the actual\n     answer buffer size is desirable because the server will\n     minimize the reply to fit into the UDP packet (and A\n     non-minimal response might not fit the buffer).\n\n     The RESOLV_EDNS_BUFFER_SIZE limit could still result in TCP\n     fallback and a non-minimal response which has to be\n     hard-truncated in the stub resolver, but this is price to\n     pay for avoiding fragmentation.  (This issue does not\n     affect the nss_dns functions because they use the stub\n     resolver in such a way that it allocates a properly sized\n     response buffer.)  */\n  {\n    uint16_t buffer_size;\n    if (anslen < 512)\n      buffer_size = 512;\n    else if (anslen > RESOLV_EDNS_BUFFER_SIZE)\n      buffer_size = RESOLV_EDNS_BUFFER_SIZE;\n    else\n      buffer_size = anslen;\n    NS_PUT16 (buffer_size, cp);\n  }\n\n  *cp++ = NOERROR;              /* Extended RCODE.  */\n  *cp++ = 0;                    /* EDNS version.  */\n\n  if (ctx->resp->options & RES_USE_DNSSEC)\n    flags |= NS_OPT_DNSSEC_OK;\n\n  NS_PUT16 (flags, cp);\n  NS_PUT16 (0, cp);       /* RDATA length (no options are preent).  */\n  hp->arcount = htons (ntohs (hp->arcount) + 1);\n\n  return cp - buf;\n}",
    "__libc_res_nameinquery": "__libc_res_nameinquery (const char *name, int type, int class,\n                        const unsigned char *buf, const unsigned char *eom){\n  const unsigned char *cp = buf + HFIXEDSZ;\n  int qdcount = ntohs (((UHEADER *) buf)->qdcount);\n\n  while (qdcount-- > 0)\n    {\n      char tname[MAXDNAME+1];\n      int n, ttype, tclass;\n\n      n = __libc_dn_expand (buf, eom, cp, tname, sizeof tname);\n      if (n < 0)\n        return -1;\n      cp += n;\n      if (cp + 2 * INT16SZ > eom)\n        return -1;\n      NS_GET16 (ttype, cp);\n      NS_GET16 (tclass, cp);\n      if (ttype == type && tclass == class\n          && __libc_ns_samename (tname, name) == 1)\n        return 1;\n    }\n  return 0;\n}",
    "__libc_res_queriesmatch": "__libc_res_queriesmatch (const unsigned char *buf1, const unsigned char *eom1,\n                         const unsigned char *buf2, const unsigned char *eom2){\n  if (eom1 - buf1 < HFIXEDSZ || eom2 - buf2 < HFIXEDSZ)\n    return -1;\n\n  /* Only header section present in replies to dynamic update\n     packets.  */\n  if ((((UHEADER *) buf1)->opcode == ns_o_update) &&\n      (((UHEADER *) buf2)->opcode == ns_o_update))\n    return 1;\n\n  /* Note that we initially do not convert QDCOUNT to the host byte\n     order.  We can compare it with the second buffer's QDCOUNT\n     value without doing this.  */\n  int qdcount = ((UHEADER *) buf1)->qdcount;\n  if (qdcount != ((UHEADER *) buf2)->qdcount)\n    return 0;\n\n  qdcount = htons (qdcount);\n  const unsigned char *cp = buf1 + HFIXEDSZ;\n\n  while (qdcount-- > 0)\n    {\n      char tname[MAXDNAME+1];\n      int n, ttype, tclass;\n\n      n = __libc_dn_expand (buf1, eom1, cp, tname, sizeof tname);\n      if (n < 0)\n        return -1;\n      cp += n;\n      if (eom1 - cp < 4)\n        return -1;\n      NS_GET16 (ttype, cp);\n      NS_GET16 (tclass, cp);\n      if (!__libc_res_nameinquery (tname, ttype, tclass, buf2, eom2))\n        return 0;\n    }\n  return 1;\n}",
    "__res_context_query": "__res_context_query (struct resolv_context *ctx, const char *name,\n\t\t     int class, int type,\n\t\t     unsigned char *answer, int anslen,\n\t\t     unsigned char **answerp, unsigned char **answerp2,\n\t\t     int *nanswerp2, int *resplen2, int *answerp2_malloced){\n\tstruct __res_state *statp = ctx->resp;\n\tUHEADER *hp = (UHEADER *) answer;\n\tUHEADER *hp2;\n\tint n;\n\tbool retried = false;\n\n\t/* It requires 2 times QUERYSIZE for type == T_QUERY_A_AND_AAAA.  */\n\tstruct scratch_buffer buf;\n\tscratch_buffer_init (&buf);\n\t_Static_assert (2 * QUERYSIZE <= sizeof (buf.__space.__c),\n\t\t\t\"scratch_buffer too small\");\n\tu_char *query1 = buf.data;\n\tint nquery1 = -1;\n\tu_char *query2 = NULL;\n\tint nquery2 = 0;\n\n again:\n\thp->rcode = NOERROR;\t/* default */\n\n\tif (type == T_QUERY_A_AND_AAAA)\n\t  {\n\t    n = __res_context_mkquery (ctx, QUERY, name, class, T_A, NULL,\n\t\t\t\t       query1, buf.length);\n\t    if (n > 0)\n\t      {\n\t\tif ((statp->options & (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0)\n\t\t  {\n\t\t    /* Use RESOLV_EDNS_BUFFER_SIZE because the receive\n\t\t       buffer can be reallocated.  */\n\t\t    n = __res_nopt (ctx, n, query1, buf.length,\n\t\t\t\t    RESOLV_EDNS_BUFFER_SIZE);\n\t\t    if (n < 0)\n\t\t      goto unspec_nomem;\n\t\t  }\n\n\t\tnquery1 = n;\n\t\tquery2 = buf.data + n;\n\t\tn = __res_context_mkquery (ctx, QUERY, name, class, T_AAAA,\n\t\t\t\t\t   NULL, query2, buf.length - n);\n\t\tif (n > 0\n\t\t    && (statp->options & (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0)\n\t\t  /* Use RESOLV_EDNS_BUFFER_SIZE because the receive\n\t\t     buffer can be reallocated.  */\n\t\t  n = __res_nopt (ctx, n, query2, buf.length,\n\t\t\t\t  RESOLV_EDNS_BUFFER_SIZE);\n\t\tnquery2 = n;\n\t      }\n\n\t  unspec_nomem:;\n\t  }\n\telse\n\t  {\n\t    n = __res_context_mkquery (ctx, QUERY, name, class, type, NULL,\n\t\t\t\t       query1, buf.length);\n\n\t    if (n > 0\n\t\t&& (statp->options & (RES_USE_EDNS0|RES_USE_DNSSEC)) != 0)\n\t      {\n\t\t/* Use RESOLV_EDNS_BUFFER_SIZE if the receive buffer\n\t\t   can be reallocated.  */\n\t\tsize_t advertise;\n\t\tif (answerp == NULL)\n\t\t  advertise = anslen;\n\t\telse\n\t\t  advertise = RESOLV_EDNS_BUFFER_SIZE;\n\t\tn = __res_nopt (ctx, n, query1, buf.length, advertise);\n\t      }\n\n\t    nquery1 = n;\n\t  }\n\n\tif (__glibc_unlikely (n <= 0) && !retried) {\n\t\t/* Retry just in case res_nmkquery failed because of too\n\t\t   short buffer.  Shouldn't happen.  */\n\t\tif (scratch_buffer_set_array_size (&buf,\n\t\t\t\t\t\t   (type == T_QUERY_A_AND_AAAA)\n\t\t\t\t\t\t   ? 2 : 1,\n\t\t\t\t\t\t   MAXPACKET)) {\n\t\t\tquery1 = buf.data;\n\t\t\tretried = true;\n\t\t\tgoto again;\n\t\t}\n\t}\n\tif (__glibc_unlikely (n <= 0))       {\n\t\tRES_SET_H_ERRNO(statp, NO_RECOVERY);\n\t\tscratch_buffer_free (&buf);\n\t\treturn (n);\n\t}\n\n\t/* Suppress AAAA lookups if required.  __res_handle_no_aaaa\n\t   checks RES_NOAAAA first, so avoids parsing the\n\t   just-generated query packet in most cases.  nss_dns avoids\n\t   using T_QUERY_A_AND_AAAA in RES_NOAAAA mode, so there is no\n\t   need to handle it here.  */\n\tif (type == T_AAAA && __res_handle_no_aaaa (ctx, query1, nquery1,\n\t\t\t\t\t\t    answer, anslen, &n))\n\t  /* There must be no second query for AAAA queries.  The code\n\t     below is still needed to translate NODATA responses.  */\n\t  assert (query2 == NULL);\n\telse\n\t  {\n\t    assert (answerp == NULL || (void *) *answerp == (void *) answer);\n\t    n = __res_context_send (ctx, query1, nquery1, query2, nquery2,\n\t\t\t\t    answer, anslen,\n\t\t\t\t    answerp, answerp2, nanswerp2, resplen2,\n\t\t\t\t    answerp2_malloced);\n\t  }\n\n\tscratch_buffer_free (&buf);\n\tif (n < 0) {\n\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\t\treturn (n);\n\t}\n\n\tif (answerp != NULL)\n\t  /* __res_context_send might have reallocated the buffer.  */\n\t  hp = (UHEADER *) *answerp;\n\n\t/* We simplify the following tests by assigning HP to HP2 or\n\t   vice versa.  It is easy to verify that this is the same as\n\t   ignoring all tests of HP or HP2.  */\n\tif (answerp2 == NULL || *resplen2 < (int) sizeof (HEADER))\n\t  {\n\t    hp2 = hp;\n\t  }\n\telse\n\t  {\n\t    hp2 = (UHEADER *) *answerp2;\n\t    if (n < (int) sizeof (HEADER))\n\t      {\n\t        hp = hp2;\n\t      }\n\t  }\n\n\t/* Make sure both hp and hp2 are defined */\n\tassert((hp != NULL) && (hp2 != NULL));\n\n\tif ((hp->rcode != NOERROR || ntohs(hp->ancount) == 0)\n\t    && (hp2->rcode != NOERROR || ntohs(hp2->ancount) == 0)) {\n\t\tswitch (hp->rcode == NOERROR ? hp2->rcode : hp->rcode) {\n\t\tcase NXDOMAIN:\n\t\t\tif ((hp->rcode == NOERROR && ntohs (hp->ancount) != 0)\n\t\t\t    || (hp2->rcode == NOERROR\n\t\t\t\t&& ntohs (hp2->ancount) != 0))\n\t\t\t\tgoto success;\n\t\t\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND);\n\t\t\tbreak;\n\t\tcase SERVFAIL:\n\t\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\t\t\tbreak;\n\t\tcase NOERROR:\n\t\t\tif (ntohs (hp->ancount) != 0\n\t\t\t    || ntohs (hp2->ancount) != 0)\n\t\t\t\tgoto success;\n\t\t\tRES_SET_H_ERRNO(statp, NO_DATA);\n\t\t\tbreak;\n\t\tcase FORMERR:\n\t\tcase NOTIMP:\n\t\t\t/* Servers must not reply to AAAA queries with\n\t\t\t   NOTIMP etc but some of them do.  */\n\t\t\tif ((hp->rcode == NOERROR && ntohs (hp->ancount) != 0)\n\t\t\t    || (hp2->rcode == NOERROR\n\t\t\t\t&& ntohs (hp2->ancount) != 0))\n\t\t\t\tgoto success;\n\t\t\t/* FALLTHROUGH */\n\t\tcase REFUSED:\n\t\tdefault:\n\t\t\tRES_SET_H_ERRNO(statp, NO_RECOVERY);\n\t\t\tbreak;\n\t\t}\n\t\treturn (-1);\n\t}\n success:\n\treturn (n);\n}",
    "__res_context_search": "__res_context_search (struct resolv_context *ctx,\n\t\t      const char *name, int class, int type,\n\t\t      unsigned char *answer, int anslen,\n\t\t      unsigned char **answerp, unsigned char **answerp2,\n\t\t      int *nanswerp2, int *resplen2, int *answerp2_malloced){\n\tstruct __res_state *statp = ctx->resp;\n\tconst char *cp;\n\tUHEADER *hp = (UHEADER *) answer;\n\tchar tmp[NS_MAXDNAME];\n\tu_int dots;\n\tint trailing_dot, ret, saved_herrno;\n\tint got_nodata = 0, got_servfail = 0, root_on_list = 0;\n\tint tried_as_is = 0;\n\tint searched = 0;\n\n\t__set_errno (0);\n\tRES_SET_H_ERRNO(statp, HOST_NOT_FOUND);  /* True if we never query. */\n\n\tdots = 0;\n\tfor (cp = name; *cp != '\\0'; cp++)\n\t\tdots += (*cp == '.');\n\ttrailing_dot = 0;\n\tif (cp > name && *--cp == '.')\n\t\ttrailing_dot++;\n\n\t/* If there aren't any dots, it could be a user-level alias. */\n\tif (!dots && (cp = __res_context_hostalias\n\t\t      (ctx, name, tmp, sizeof tmp))!= NULL)\n\t  return __res_context_query (ctx, cp, class, type, answer,\n\t\t\t\t      anslen, answerp, answerp2,\n\t\t\t\t      nanswerp2, resplen2, answerp2_malloced);\n\n\t/*\n\t * If there are enough dots in the name, let's just give it a\n\t * try 'as is'. The threshold can be set with the \"ndots\" option.\n\t * Also, query 'as is', if there is a trailing dot in the name.\n\t */\n\tsaved_herrno = -1;\n\tif (dots >= statp->ndots || trailing_dot) {\n\t\tret = __res_context_querydomain (ctx, name, NULL, class, type,\n\t\t\t\t\t\t answer, anslen, answerp,\n\t\t\t\t\t\t answerp2, nanswerp2, resplen2,\n\t\t\t\t\t\t answerp2_malloced);\n\t\tif (ret > 0 || trailing_dot\n\t\t    /* If the second response is valid then we use that.  */\n\t\t    || (ret == 0 && resplen2 != NULL && *resplen2 > 0))\n\t\t\treturn (ret);\n\t\tsaved_herrno = h_errno;\n\t\ttried_as_is++;\n\t\tif (answerp && *answerp != answer) {\n\t\t\tanswer = *answerp;\n\t\t\tanslen = MAXPACKET;\n\t\t}\n\t\tif (answerp2 && *answerp2_malloced)\n\t\t  {\n\t\t    free (*answerp2);\n\t\t    *answerp2 = NULL;\n\t\t    *nanswerp2 = 0;\n\t\t    *answerp2_malloced = 0;\n\t\t  }\n\t}\n\n\t/*\n\t * We do at least one level of search if\n\t *\t- there is no dot and RES_DEFNAME is set, or\n\t *\t- there is at least one dot, there is no trailing dot,\n\t *\t  and RES_DNSRCH is set.\n\t */\n\tif ((!dots && (statp->options & RES_DEFNAMES) != 0) ||\n\t    (dots && !trailing_dot && (statp->options & RES_DNSRCH) != 0)) {\n\t\tint done = 0;\n\n\t\tfor (size_t domain_index = 0; !done; ++domain_index) {\n\t\t\tconst char *dname = __resolv_context_search_list\n\t\t\t  (ctx, domain_index);\n\t\t\tif (dname == NULL)\n\t\t\t  break;\n\t\t\tsearched = 1;\n\n\t\t\t/* __res_context_querydoman concatenates name\n\t\t\t   with dname with a \".\" in between.  If we\n\t\t\t   pass it in dname the \".\" we got from the\n\t\t\t   configured default search path, we'll end\n\t\t\t   up with \"name..\", which won't resolve.\n\t\t\t   OTOH, passing it \"\" will result in \"name.\",\n\t\t\t   which has the intended effect for both\n\t\t\t   possible representations of the root\n\t\t\t   domain.  */\n\t\t\tif (dname[0] == '.')\n\t\t\t\tdname++;\n\t\t\tif (dname[0] == '\\0')\n\t\t\t\troot_on_list++;\n\n\t\t\tret = __res_context_querydomain\n\t\t\t  (ctx, name, dname, class, type,\n\t\t\t   answer, anslen, answerp, answerp2, nanswerp2,\n\t\t\t   resplen2, answerp2_malloced);\n\t\t\tif (ret > 0 || (ret == 0 && resplen2 != NULL\n\t\t\t\t\t&& *resplen2 > 0))\n\t\t\t\treturn (ret);\n\n\t\t\tif (answerp && *answerp != answer) {\n\t\t\t\tanswer = *answerp;\n\t\t\t\tanslen = MAXPACKET;\n\t\t\t}\n\t\t\tif (answerp2 && *answerp2_malloced)\n\t\t\t  {\n\t\t\t    free (*answerp2);\n\t\t\t    *answerp2 = NULL;\n\t\t\t    *nanswerp2 = 0;\n\t\t\t    *answerp2_malloced = 0;\n\t\t\t  }\n\n\t\t\t/*\n\t\t\t * If no server present, give up.\n\t\t\t * If name isn't found in this domain,\n\t\t\t * keep trying higher domains in the search list\n\t\t\t * (if that's enabled).\n\t\t\t * On a NO_DATA error, keep trying, otherwise\n\t\t\t * a wildcard entry of another type could keep us\n\t\t\t * from finding this entry higher in the domain.\n\t\t\t * If we get some other error (negative answer or\n\t\t\t * server failure), then stop searching up,\n\t\t\t * but try the input name below in case it's\n\t\t\t * fully-qualified.\n\t\t\t */\n\t\t\tif (errno == ECONNREFUSED) {\n\t\t\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\t\t\t\treturn (-1);\n\t\t\t}\n\n\t\t\tswitch (statp->res_h_errno) {\n\t\t\tcase NO_DATA:\n\t\t\t\tgot_nodata++;\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tcase HOST_NOT_FOUND:\n\t\t\t\t/* keep trying */\n\t\t\t\tbreak;\n\t\t\tcase TRY_AGAIN:\n\t\t\t\tif (hp->rcode == SERVFAIL) {\n\t\t\t\t\t/* try next search element, if any */\n\t\t\t\t\tgot_servfail++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/* FALLTHROUGH */\n\t\t\tdefault:\n\t\t\t\t/* anything else implies that we're done */\n\t\t\t\tdone++;\n\t\t\t}\n\n\t\t\t/* if we got here for some reason other than DNSRCH,\n\t\t\t * we only wanted one iteration of the loop, so stop.\n\t\t\t */\n\t\t\tif ((statp->options & RES_DNSRCH) == 0)\n\t\t\t\tdone++;\n\t\t}\n\t}\n\n\t/*\n\t * If the query has not already been tried as is then try it\n\t * unless RES_NOTLDQUERY is set and there were no dots.\n\t */\n\tif ((dots || !searched || (statp->options & RES_NOTLDQUERY) == 0)\n\t    && !(tried_as_is || root_on_list)) {\n\t\tret = __res_context_querydomain\n\t\t  (ctx, name, NULL, class, type,\n\t\t   answer, anslen, answerp, answerp2, nanswerp2,\n\t\t   resplen2, answerp2_malloced);\n\t\tif (ret > 0 || (ret == 0 && resplen2 != NULL\n\t\t\t\t&& *resplen2 > 0))\n\t\t\treturn (ret);\n\t}\n\n\t/* if we got here, we didn't satisfy the search.\n\t * if we did an initial full query, return that query's H_ERRNO\n\t * (note that we wouldn't be here if that query had succeeded).\n\t * else if we ever got a nodata, send that back as the reason.\n\t * else send back meaningless H_ERRNO, that being the one from\n\t * the last DNSRCH we did.\n\t */\n\tif (answerp2 && *answerp2_malloced)\n\t  {\n\t    free (*answerp2);\n\t    *answerp2 = NULL;\n\t    *nanswerp2 = 0;\n\t    *answerp2_malloced = 0;\n\t  }\n\tif (saved_herrno != -1)\n\t\tRES_SET_H_ERRNO(statp, saved_herrno);\n\telse if (got_nodata)\n\t\tRES_SET_H_ERRNO(statp, NO_DATA);\n\telse if (got_servfail)\n\t\tRES_SET_H_ERRNO(statp, TRY_AGAIN);\n\treturn (-1);\n}",
    "__res_context_send": "__res_context_send (struct resolv_context *ctx,\n\t\t    const unsigned char *buf, int buflen,\n\t\t    const unsigned char *buf2, int buflen2,\n\t\t    unsigned char *ans, int anssiz,\n\t\t    unsigned char **ansp, unsigned char **ansp2,\n\t\t    int *nansp2, int *resplen2, int *ansp2_malloced){\n\tstruct __res_state *statp = ctx->resp;\n\tint gotsomewhere, terrno, try, v_circuit, resplen;\n\t/* On some architectures send_vc is inlined and the compiler might emit\n\t   a warning indicating 'resplen' may be used uninitialized.  Note that\n\t   the warning belongs to resplen in send_vc which is used as return\n\t   value!  There the maybe-uninitialized warning is already ignored as\n\t   it is a false-positive - see comment in send_vc.\n\t   Here the variable n is set to the return value of send_vc.\n\t   See below.  */\n\tDIAG_PUSH_NEEDS_COMMENT;\n\tDIAG_IGNORE_NEEDS_COMMENT (9, \"-Wmaybe-uninitialized\");\n\tint n;\n\tDIAG_POP_NEEDS_COMMENT;\n\n\tif (statp->nscount == 0) {\n\t\t__set_errno (ESRCH);\n\t\treturn (-1);\n\t}\n\n\tif (anssiz < (buf2 == NULL ? 1 : 2) * HFIXEDSZ) {\n\t\t__set_errno (EINVAL);\n\t\treturn (-1);\n\t}\n\n\tv_circuit = ((statp->options & RES_USEVC)\n\t\t     || buflen > PACKETSZ\n\t\t     || buflen2 > PACKETSZ);\n\tgotsomewhere = 0;\n\tterrno = ETIMEDOUT;\n\n\t/*\n\t * If the ns_addr_list in the resolver context has changed, then\n\t * invalidate our cached copy and the associated timing data.\n\t */\n\tif (EXT(statp).nscount != 0) {\n\t\tint needclose = 0;\n\n\t\tif (EXT(statp).nscount != statp->nscount)\n\t\t\tneedclose++;\n\t\telse\n\t\t\tfor (unsigned int ns = 0; ns < statp->nscount; ns++) {\n\t\t\t\tif (statp->nsaddr_list[ns].sin_family != 0\n\t\t\t\t    && !sock_eq((struct sockaddr_in6 *)\n\t\t\t\t\t\t&statp->nsaddr_list[ns],\n\t\t\t\t\t\tEXT(statp).nsaddrs[ns]))\n\t\t\t\t{\n\t\t\t\t\tneedclose++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\tif (needclose) {\n\t\t\t__res_iclose(statp, false);\n\t\t\tEXT(statp).nscount = 0;\n\t\t}\n\t}\n\n\t/*\n\t * Maybe initialize our private copy of the ns_addr_list.\n\t */\n\tif (EXT(statp).nscount == 0) {\n\t\tfor (unsigned int ns = 0; ns < statp->nscount; ns++) {\n\t\t\tEXT(statp).nssocks[ns] = -1;\n\t\t\tif (statp->nsaddr_list[ns].sin_family == 0)\n\t\t\t\tcontinue;\n\t\t\tif (EXT(statp).nsaddrs[ns] == NULL)\n\t\t\t\tEXT(statp).nsaddrs[ns] =\n\t\t\t\t    malloc(sizeof (struct sockaddr_in6));\n\t\t\tif (EXT(statp).nsaddrs[ns] != NULL)\n\t\t\t\tmemset (mempcpy(EXT(statp).nsaddrs[ns],\n\t\t\t\t\t\t&statp->nsaddr_list[ns],\n\t\t\t\t\t\tsizeof (struct sockaddr_in)),\n\t\t\t\t\t'\\0',\n\t\t\t\t\tsizeof (struct sockaddr_in6)\n\t\t\t\t\t- sizeof (struct sockaddr_in));\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\t\tEXT(statp).nscount = statp->nscount;\n\t}\n\n\t/* Name server index offset.  Used to implement\n\t   RES_ROTATE.  */\n\tunsigned int ns_offset = nameserver_offset (statp);\n\n\t/*\n\t * Send request, RETRY times, or until successful.\n\t */\n\tfor (try = 0; try < statp->retry; try++) {\n\t    for (unsigned ns_shift = 0; ns_shift < statp->nscount; ns_shift++)\n\t    {\n\t\t/* The actual name server index.  This implements\n\t\t   RES_ROTATE.  */\n\t\tunsigned int ns = ns_shift + ns_offset;\n\t\tif (ns >= statp->nscount)\n\t\t\tns -= statp->nscount;\n\n\t    same_ns:\n\t\tif (__glibc_unlikely (v_circuit))       {\n\t\t\t/* Use VC; at most one attempt per server. */\n\t\t\ttry = statp->retry;\n\t\t\tn = send_vc(statp, buf, buflen, buf2, buflen2,\n\t\t\t\t    &ans, &anssiz, &terrno,\n\t\t\t\t    ns, ansp, ansp2, nansp2, resplen2,\n\t\t\t\t    ansp2_malloced);\n\t\t\tif (n < 0)\n\t\t\t\treturn (-1);\n\t\t\t/* See comment at the declaration of n.  */\n\t\t\tDIAG_PUSH_NEEDS_COMMENT;\n\t\t\tDIAG_IGNORE_NEEDS_COMMENT (9, \"-Wmaybe-uninitialized\");\n\t\t\tif (n == 0 && (buf2 == NULL || *resplen2 == 0))\n\t\t\t\tgoto next_ns;\n\t\t\tDIAG_POP_NEEDS_COMMENT;\n\t\t} else {\n\t\t\t/* Use datagrams. */\n\t\t\tn = send_dg(statp, buf, buflen, buf2, buflen2,\n\t\t\t\t    &ans, &anssiz, &terrno,\n\t\t\t\t    ns, &v_circuit, &gotsomewhere, ansp,\n\t\t\t\t    ansp2, nansp2, resplen2, ansp2_malloced);\n\t\t\tif (n < 0)\n\t\t\t\treturn (-1);\n\t\t\tif (n == 0 && (buf2 == NULL || *resplen2 == 0))\n\t\t\t\tgoto next_ns;\n\t\t\tif (v_circuit)\n\t\t\t  // XXX Check whether both requests failed or\n\t\t\t  // XXX whether one has been answered successfully\n\t\t\t\tgoto same_ns;\n\t\t}\n\n\t\tresplen = n;\n\n\t\t/* See comment at the declaration of n.  Note: resplen = n;  */\n\t\tDIAG_PUSH_NEEDS_COMMENT;\n\t\tDIAG_IGNORE_NEEDS_COMMENT (9, \"-Wmaybe-uninitialized\");\n\t\t/* Mask the AD bit in both responses unless it is\n\t\t   marked trusted.  */\n\t\tif (resplen > HFIXEDSZ)\n\t\t  {\n\t\t    if (ansp != NULL)\n\t\t      mask_ad_bit (ctx, *ansp);\n\t\t    else\n\t\t      mask_ad_bit (ctx, ans);\n\t\t  }\n\t\tDIAG_POP_NEEDS_COMMENT;\n\t\tif (resplen2 != NULL && *resplen2 > HFIXEDSZ)\n\t\t  mask_ad_bit (ctx, *ansp2);\n\n\t\t/*\n\t\t * If we have temporarily opened a virtual circuit,\n\t\t * or if we haven't been asked to keep a socket open,\n\t\t * close the socket.\n\t\t */\n\t\tif ((v_circuit && (statp->options & RES_USEVC) == 0) ||\n\t\t    (statp->options & RES_STAYOPEN) == 0) {\n\t\t\t__res_iclose(statp, false);\n\t\t}\n\t\treturn (resplen);\n next_ns: ;\n\t   } /*foreach ns*/\n\t} /*foreach retry*/\n\t__res_iclose(statp, false);\n\tif (!v_circuit) {\n\t\tif (!gotsomewhere)\n\t\t\t__set_errno (ECONNREFUSED);\t/* no nameservers found */\n\t\telse\n\t\t\t__set_errno (ETIMEDOUT);\t/* no answer obtained */\n\t} else\n\t\t__set_errno (terrno);\n\treturn (-1);\n}",
    "__resolv_context_get": "*\n__resolv_context_get (void){\n  return context_get (false);\n}",
    "__resolv_context_get_preinit": "*\n__resolv_context_get_preinit (void){\n  return context_get (true);\n}",
    "__resolv_context_get_override": "*\n__resolv_context_get_override (struct __res_state *resp){\n  /* NB: As explained asbove, context_alloc will put the context on\n     the current list.  */\n  struct resolv_context *ctx = context_alloc (resp);\n  if (ctx == NULL)\n    return NULL;\n\n  ctx->__from_res = false;\n  return ctx;\n}",
    "__resolv_context_put": "__resolv_context_put (struct resolv_context *ctx){\n  if (ctx == NULL)\n    return;\n\n  /* NB: Callers assume that this function preserves errno and\n     h_errno.  */\n\n  assert (current == ctx);\n  assert (ctx->__refcount > 0);\n\n  if (ctx->__from_res && --ctx->__refcount > 0)\n    /* Do not pop this context yet.  */\n    return;\n\n  context_free (ctx);\n}",
    "_nss_dns_getcanonname_r": "_nss_dns_getcanonname_r (const char *name, char *buffer, size_t buflen,\n\t\t\t char **result,int *errnop, int *h_errnop){\n  /* Just an alibi buffer, res_nquery will allocate a real buffer for\n     us.  */\n  unsigned char buf[20];\n  union\n  {\n    querybuf *buf;\n    unsigned char *ptr;\n  } ansp = { .ptr = buf };\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  for (int i = 0; i < nqtypes; ++i)\n    {\n      int r = __res_context_query (ctx, name, ns_c_in, qtypes[i],\n\t\t\t\t   buf, sizeof (buf), &ansp.ptr, NULL, NULL,\n\t\t\t\t   NULL, NULL);\n      if (r > 0)\n\t{\n\t  /* We need to decode the response.  Just one question record.\n\t     And if we got no answers we bail out, too.  */\n\t  if (ansp.buf->hdr.qdcount != htons (1))\n\t    continue;\n\n\t  /* Number of answers.   */\n\t  unsigned int ancount = ntohs (ansp.buf->hdr.ancount);\n\n\t  /* Beginning and end of the buffer with query, answer, and the\n\t     rest.  */\n\t  unsigned char *ptr = &ansp.buf->buf[sizeof (HEADER)];\n\t  unsigned char *endptr = ansp.ptr + r;\n\n\t  /* Skip over the query.  This is the name, type, and class.  */\n\t  int s = __libc_dn_skipname (ptr, endptr);\n\t  if (s < 0)\n\t    {\n\t    unavail:\n\t      status = NSS_STATUS_UNAVAIL;\n\t      break;\n\t    }\n\n\t  /* Skip over the name and the two 16-bit values containing type\n\t     and class.  */\n\t  ptr += s + 2 * sizeof (uint16_t);\n\n\t  while (ancount-- > 0)\n\t    {\n\t      /* Now the reply.  First again the name from the query,\n\t\t then type, class, TTL, and the length of the RDATA.\n\t\t We remember the name start.  */\n\t      unsigned char *namestart = ptr;\n\t      s = __libc_dn_skipname (ptr, endptr);\n\t      if (s < 0)\n\t\tgoto unavail;\n\n\t      ptr += s;\n\n\t      /* Check that there are enough bytes for the RR\n\t\t metadata.  */\n\t      if (endptr - ptr < 10)\n\t\tgoto unavail;\n\n\t      /* Check whether type and class match.  */\n\t      short int type;\n\t      NS_GET16 (type, ptr);\n\t      if (type == qtypes[i])\n\t\t{\n\t\t  /* We found the record.  */\n\t\t  s = __libc_dn_expand (ansp.buf->buf, endptr, namestart,\n\t\t\t\t\tbuffer, buflen);\n\t\t  if (s < 0)\n\t\t    {\n\t\t      if (errno != EMSGSIZE)\n\t\t\tgoto unavail;\n\n\t\t      /* The buffer is too small.  */\n\t\t      *errnop = ERANGE;\n\t\t      status = NSS_STATUS_TRYAGAIN;\n\t\t      h_errno = NETDB_INTERNAL;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      /* Success.  */\n\t\t      *result = buffer;\n\t\t      status = NSS_STATUS_SUCCESS;\n\t\t    }\n\n\t\t  goto out;\n\t\t}\n\n\t      if (type != ns_t_cname)\n\t\tgoto unavail;\n\n\t      uint16_t rrclass;\n\t      NS_GET16 (rrclass, ptr);\n\t      if (rrclass != ns_c_in)\n\t\tgoto unavail;\n\n\t      /* Skip over TTL.  */\n\t      ptr += sizeof (uint32_t);\n\n\t      /* Skip over RDATA length and RDATA itself.  */\n\t      uint16_t rdatalen;\n\t      NS_GET16 (rdatalen, ptr);\n\n\t      /* Not enough room for RDATA.  */\n\t      if (endptr - ptr < rdatalen)\n\t\tgoto unavail;\n\t      ptr += rdatalen;\n\t    }\n\t}\n\n      /* Restore original buffer before retry.  */\n      if (ansp.ptr != buf)\n\t{\n\t  free (ansp.ptr);\n\t  ansp.ptr = buf;\n\t}\n    }\n\n out:\n  *h_errnop = h_errno;\n\n  if (ansp.ptr != buf)\n    free (ansp.ptr);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_gethostbyname3_r": "_nss_dns_gethostbyname3_r (const char *name, int af, struct hostent *result,\n\t\t\t   char *buffer, size_t buflen, int *errnop,\n\t\t\t   int *h_errnop, int32_t *ttlp, char **canonp){\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n  enum nss_status status = gethostbyname3_context\n    (ctx, name, af, result, buffer, buflen, errnop, h_errnop, ttlp, canonp);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_gethostbyname2_r": "_nss_dns_gethostbyname2_r (const char *name, int af, struct hostent *result,\n\t\t\t   char *buffer, size_t buflen, int *errnop,\n\t\t\t   int *h_errnop){\n  enum nss_status status = check_name (name, h_errnop);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n  return _nss_dns_gethostbyname3_r (name, af, result, buffer, buflen, errnop,\n\t\t\t\t    h_errnop, NULL, NULL);\n}",
    "_nss_dns_gethostbyname_r": "_nss_dns_gethostbyname_r (const char *name, struct hostent *result,\n\t\t\t  char *buffer, size_t buflen, int *errnop,\n\t\t\t  int *h_errnop){\n  enum nss_status status = check_name (name, h_errnop);\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n  status = gethostbyname3_context (ctx, name, AF_INET, result, buffer,\n\t\t\t\t   buflen, errnop, h_errnop, NULL, NULL);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_gethostbyname4_r": "_nss_dns_gethostbyname4_r (const char *name, struct gaih_addrtuple **pat,\n\t\t\t   char *buffer, size_t buflen, int *errnop,\n\t\t\t   int *herrnop, int32_t *ttlp){\n  enum nss_status status = check_name (name, herrnop);\n  char tmp[NS_MAXDNAME];\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *herrnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  /*\n   * if there aren't any dots, it could be a user-level alias.\n   * this is also done in res_query() since we are not the only\n   * function that looks up host names.\n   */\n  if (strchr (name, '.') == NULL)\n    {\n      const char *cp = __res_context_hostalias (ctx, name, tmp, sizeof (tmp));\n      if (cp != NULL)\n\tname = cp;\n    }\n\n  unsigned char dns_packet_buffer[2048];\n  unsigned char *alt_dns_packet_buffer = dns_packet_buffer;\n  u_char *ans2p = NULL;\n  int nans2p = 0;\n  int resplen2 = 0;\n  int ans2p_malloced = 0;\n  struct alloc_buffer abuf = alloc_buffer_create (buffer, buflen);\n\n\n  int olderr = errno;\n  int n;\n\n  if ((ctx->resp->options & RES_NOAAAA) == 0)\n    {\n      n = __res_context_search (ctx, name, C_IN, T_QUERY_A_AND_AAAA,\n\t\t\t\tdns_packet_buffer, sizeof (dns_packet_buffer),\n\t\t\t\t&alt_dns_packet_buffer, &ans2p, &nans2p,\n\t\t\t\t&resplen2, &ans2p_malloced);\n      if (n >= 0)\n\tstatus = gaih_getanswer (alt_dns_packet_buffer, n, ans2p, resplen2,\n\t\t\t\t &abuf, pat, errnop, herrnop, ttlp);\n    }\n  else\n    {\n      n = __res_context_search (ctx, name, C_IN, T_A,\n\t\t\t\tdns_packet_buffer, sizeof (dns_packet_buffer),\n\t\t\t\t&alt_dns_packet_buffer, NULL, NULL, NULL, NULL);\n      if (n >= 0)\n\tstatus = gaih_getanswer_noaaaa (alt_dns_packet_buffer, n,\n\t\t\t\t\t&abuf, pat, errnop, herrnop, ttlp);\n    }\n  if (n < 0)\n    {\n      switch (errno)\n\t{\n\tcase ESRCH:\n\t  status = NSS_STATUS_TRYAGAIN;\n\t  h_errno = TRY_AGAIN;\n\t  break;\n\t/* System has run out of file descriptors.  */\n\tcase EMFILE:\n\tcase ENFILE:\n\t  h_errno = NETDB_INTERNAL;\n\t  /* Fall through.  */\n\tcase ECONNREFUSED:\n\tcase ETIMEDOUT:\n\t  status = NSS_STATUS_UNAVAIL;\n\t  break;\n\tdefault:\n\t  status = NSS_STATUS_NOTFOUND;\n\t  break;\n\t}\n\n      *herrnop = h_errno;\n      if (h_errno == TRY_AGAIN)\n\t*errnop = EAGAIN;\n      else\n\t__set_errno (olderr);\n    }\n\n  /* Implement the buffer resizing protocol.  */\n  if (alloc_buffer_has_failed (&abuf))\n    {\n      *errnop = ERANGE;\n      *herrnop = NETDB_INTERNAL;\n      status = NSS_STATUS_TRYAGAIN;\n    }\n\n  /* Check whether ans2p was separately allocated.  */\n  if (ans2p_malloced)\n    free (ans2p);\n\n  if (alt_dns_packet_buffer != dns_packet_buffer)\n    free (alt_dns_packet_buffer);\n\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_gethostbyaddr2_r": "_nss_dns_gethostbyaddr2_r (const void *addr, socklen_t len, int af,\n\t\t\t   struct hostent *result, char *buffer, size_t buflen,\n\t\t\t   int *errnop, int *h_errnop, int32_t *ttlp){\n  static const u_char mapped[] = { 0,0, 0,0, 0,0, 0,0, 0,0, 0xff,0xff };\n  static const u_char tunnelled[] = { 0,0, 0,0, 0,0, 0,0, 0,0, 0,0 };\n  static const u_char v6local[] = { 0,0, 0,1 };\n  const u_char *uaddr = (const u_char *)addr;\n  char qbuf[MAXDNAME+1], *qp = NULL;\n  size_t size;\n  int n, status;\n  int olderr = errno;\n\n  /* Prepare the allocation buffer.  Store the pointer array first, to\n     benefit from buffer alignment.  */\n  struct alloc_buffer abuf = alloc_buffer_create (buffer, buflen);\n  char **address_array = alloc_buffer_alloc_array (&abuf, char *, 2);\n  if (address_array == NULL)\n    {\n      *errnop = ERANGE;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_TRYAGAIN;\n    }\n\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  if (af == AF_INET6 && len == IN6ADDRSZ\n      && (memcmp (uaddr, mapped, sizeof mapped) == 0\n\t  || (memcmp (uaddr, tunnelled, sizeof tunnelled) == 0\n\t      && memcmp (&uaddr[sizeof tunnelled], v6local, sizeof v6local))))\n    {\n      /* Unmap. */\n      addr += sizeof mapped;\n      uaddr += sizeof mapped;\n      af = AF_INET;\n      len = INADDRSZ;\n    }\n\n  switch (af)\n    {\n    case AF_INET:\n      size = INADDRSZ;\n      break;\n    case AF_INET6:\n      size = IN6ADDRSZ;\n      break;\n    default:\n      *errnop = EAFNOSUPPORT;\n      *h_errnop = NETDB_INTERNAL;\n      __resolv_context_put (ctx);\n      return NSS_STATUS_UNAVAIL;\n    }\n  if (size > len)\n    {\n      *errnop = EAFNOSUPPORT;\n      *h_errnop = NETDB_INTERNAL;\n      __resolv_context_put (ctx);\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  switch (af)\n    {\n    case AF_INET:\n      sprintf (qbuf, \"%u.%u.%u.%u.in-addr.arpa\", (uaddr[3] & 0xff),\n\t       (uaddr[2] & 0xff), (uaddr[1] & 0xff), (uaddr[0] & 0xff));\n      break;\n    case AF_INET6:\n      qp = qbuf;\n      for (n = IN6ADDRSZ - 1; n >= 0; n--)\n\t{\n\t  static const char nibblechar[16] = \"0123456789abcdef\";\n\t  *qp++ = nibblechar[uaddr[n] & 0xf];\n\t  *qp++ = '.';\n\t  *qp++ = nibblechar[(uaddr[n] >> 4) & 0xf];\n\t  *qp++ = '.';\n\t}\n      strcpy(qp, \"ip6.arpa\");\n      break;\n    default:\n      /* Cannot happen.  */\n      break;\n    }\n\n  unsigned char dns_packet_buffer[1024];\n  unsigned char *alt_dns_packet_buffer = dns_packet_buffer;\n  n = __res_context_query (ctx, qbuf, C_IN, T_PTR,\n\t\t\t   dns_packet_buffer, sizeof (dns_packet_buffer),\n\t\t\t   &alt_dns_packet_buffer,\n\t\t\t   NULL, NULL, NULL, NULL);\n  if (n < 0)\n    {\n      *h_errnop = h_errno;\n      __set_errno (olderr);\n      if (alt_dns_packet_buffer != dns_packet_buffer)\n\tfree (alt_dns_packet_buffer);\n      __resolv_context_put (ctx);\n      return errno == ECONNREFUSED ? NSS_STATUS_UNAVAIL : NSS_STATUS_NOTFOUND;\n    }\n\n  status = getanswer_ptr (alt_dns_packet_buffer, n,\n\t\t\t  &abuf, &result->h_name, errnop, h_errnop, ttlp);\n\n  if (alt_dns_packet_buffer != dns_packet_buffer)\n    free (alt_dns_packet_buffer);\n  __resolv_context_put (ctx);\n\n  if (status != NSS_STATUS_SUCCESS)\n    return status;\n\n  /* result->h_name has already been set by getanswer_ptr.  */\n  result->h_addrtype = af;\n  result->h_length = len;\n  /* Increase the alignment to 4, in case there are applications out\n     there that expect at least this level of address alignment.  */\n  address_array[0] = (char *) alloc_buffer_next (&abuf, uint32_t);\n  alloc_buffer_copy_bytes (&abuf, uaddr, len);\n  address_array[1] = NULL;\n\n  /* This check also covers allocation failure in getanswer_ptr.  */\n  if (alloc_buffer_has_failed (&abuf))\n    {\n      *errnop = ERANGE;\n      *h_errnop = NETDB_INTERNAL;\n      return NSS_STATUS_TRYAGAIN;\n    }\n  result->h_addr_list = address_array;\n  result->h_aliases = &address_array[1]; /* Points to NULL.  */\n\n  *h_errnop = NETDB_SUCCESS;\n  return NSS_STATUS_SUCCESS;\n}",
    "_nss_dns_gethostbyaddr_r": "_nss_dns_gethostbyaddr_r (const void *addr, socklen_t len, int af,\n\t\t\t  struct hostent *result, char *buffer, size_t buflen,\n\t\t\t  int *errnop, int *h_errnop){\n  return _nss_dns_gethostbyaddr2_r (addr, len, af, result, buffer, buflen,\n\t\t\t\t    errnop, h_errnop, NULL);\n}",
    "_nss_dns_getnetbyname_r": "_nss_dns_getnetbyname_r (const char *name, struct netent *result,\n\t\t\t char *buffer, size_t buflen, int *errnop,\n\t\t\t int *herrnop){\n  /* Return entry for network with NAME.  */\n  union\n  {\n    querybuf *buf;\n    u_char *ptr;\n  } net_buffer;\n  querybuf *orig_net_buffer;\n  int anslen;\n  enum nss_status status;\n\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *herrnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  net_buffer.buf = orig_net_buffer = (querybuf *) alloca (1024);\n\n  anslen = __res_context_search\n    (ctx, name, C_IN, T_PTR, net_buffer.buf->buf,\n     1024, &net_buffer.ptr, NULL, NULL, NULL, NULL);\n  if (anslen < 0)\n    {\n      /* Nothing found.  */\n      *errnop = errno;\n      if (net_buffer.buf != orig_net_buffer)\n\tfree (net_buffer.buf);\n      __resolv_context_put (ctx);\n      return (errno == ECONNREFUSED\n\t      || errno == EPFNOSUPPORT\n\t      || errno == EAFNOSUPPORT)\n\t? NSS_STATUS_UNAVAIL : NSS_STATUS_NOTFOUND;\n    }\n\n  status = getanswer_r (net_buffer.buf, anslen, result, buffer, buflen,\n\t\t\terrnop, herrnop, BYNAME);\n  if (net_buffer.buf != orig_net_buffer)\n    free (net_buffer.buf);\n  __resolv_context_put (ctx);\n  return status;\n}",
    "_nss_dns_getnetbyaddr_r": "_nss_dns_getnetbyaddr_r (uint32_t net, int type, struct netent *result,\n\t\t\t char *buffer, size_t buflen, int *errnop,\n\t\t\t int *herrnop){\n  /* Return entry for network with NAME.  */\n  enum nss_status status;\n  union\n  {\n    querybuf *buf;\n    u_char *ptr;\n  } net_buffer;\n  querybuf *orig_net_buffer;\n  unsigned int net_bytes[4];\n  char qbuf[MAXDNAME];\n  int cnt, anslen;\n  uint32_t net2;\n  int olderr = errno;\n\n  /* No net address lookup for IPv6 yet.  */\n  if (type != AF_INET)\n    return NSS_STATUS_UNAVAIL;\n\n  struct resolv_context *ctx = __resolv_context_get ();\n  if (ctx == NULL)\n    {\n      *errnop = errno;\n      *herrnop = NETDB_INTERNAL;\n      return NSS_STATUS_UNAVAIL;\n    }\n\n  net2 = (uint32_t) net;\n  for (cnt = 4; net2 != 0; net2 >>= 8)\n    net_bytes[--cnt] = net2 & 0xff;\n\n  switch (cnt)\n    {\n    case 3:\n      /* Class A network.  */\n      sprintf (qbuf, \"0.0.0.%u.in-addr.arpa\", net_bytes[3]);\n      break;\n    case 2:\n      /* Class B network.  */\n      sprintf (qbuf, \"0.0.%u.%u.in-addr.arpa\", net_bytes[3], net_bytes[2]);\n      break;\n    case 1:\n      /* Class C network.  */\n      sprintf (qbuf, \"0.%u.%u.%u.in-addr.arpa\", net_bytes[3], net_bytes[2],\n\t       net_bytes[1]);\n      break;\n    case 0:\n      /* Class D - E network.  */\n      sprintf (qbuf, \"%u.%u.%u.%u.in-addr.arpa\", net_bytes[3], net_bytes[2],\n\t       net_bytes[1], net_bytes[0]);\n      break;\n    }\n\n  net_buffer.buf = orig_net_buffer = (querybuf *) alloca (1024);\n\n  anslen = __res_context_query (ctx, qbuf, C_IN, T_PTR, net_buffer.buf->buf,\n\t\t\t\t1024, &net_buffer.ptr, NULL, NULL, NULL, NULL);\n  if (anslen < 0)\n    {\n      /* Nothing found.  */\n      int err = errno;\n      __set_errno (olderr);\n      if (net_buffer.buf != orig_net_buffer)\n\tfree (net_buffer.buf);\n      __resolv_context_put (ctx);\n      return (err == ECONNREFUSED\n\t      || err == EPFNOSUPPORT\n\t      || err == EAFNOSUPPORT)\n\t? NSS_STATUS_UNAVAIL : NSS_STATUS_NOTFOUND;\n    }\n\n  status = getanswer_r (net_buffer.buf, anslen, result, buffer, buflen,\n\t\t\terrnop, herrnop, BYADDR);\n  if (net_buffer.buf != orig_net_buffer)\n    free (net_buffer.buf);\n  if (status == NSS_STATUS_SUCCESS)\n    {\n      /* Strip trailing zeros.  */\n      unsigned int u_net = net;\t/* Maybe net should be unsigned?  */\n\n      while ((u_net & 0xff) == 0 && u_net != 0)\n\tu_net >>= 8;\n      result->n_net = u_net;\n    }\n\n  __resolv_context_put (ctx);\n  return status;\n}",
    "__getrlimit": "__getrlimit (enum __rlimit_resource resource, struct rlimit *rlimits){\n  struct rlimit lim;\n\n  if (rlimits == NULL || (unsigned int) resource >= RLIMIT_NLIMITS)\n    return __hurd_fail (EINVAL);\n\n  HURD_CRITICAL_BEGIN;\n  __mutex_lock (&_hurd_rlimit_lock);\n  lim = _hurd_rlimits[resource];\n  __mutex_unlock (&_hurd_rlimit_lock);\n  HURD_CRITICAL_END;\n\n  *rlimits = lim;\n\n  return 0;\n}",
    "nice": "nice (int incr){\n  int save;\n  int prio;\n  int result;\n\n  /* -1 is a valid priority, so we use errno to check for an error.  */\n  save = errno;\n  __set_errno (0);\n  prio = __getpriority (PRIO_PROCESS, 0);\n  if (prio == -1)\n    {\n      if (errno != 0)\n\treturn -1;\n    }\n\n  result = __setpriority (PRIO_PROCESS, 0, prio + incr);\n  if (result == -1)\n    {\n      if (errno == EACCES)\n\t__set_errno (EPERM);\n      return -1;\n    }\n\n  __set_errno (save);\n  return __getpriority (PRIO_PROCESS, 0);\n}",
    "setrlimit64": "setrlimit64 (enum __rlimit_resource resource, const struct rlimit64 *rlimits){\n  struct rlimit rlimits32;\n\n  if (rlimits->rlim_cur >= RLIM_INFINITY)\n    rlimits32.rlim_cur = RLIM_INFINITY;\n  else\n    rlimits32.rlim_cur = rlimits->rlim_cur;\n  if (rlimits->rlim_max >= RLIM_INFINITY)\n    rlimits32.rlim_max = RLIM_INFINITY;\n  else\n    rlimits32.rlim_max = rlimits->rlim_max;\n\n  return __setrlimit (resource, &rlimits32);\n}",
    "vlimit": "vlimit (enum __vlimit_resource resource, int value){\n  if (resource >= LIM_CPU && resource <= LIM_MAXRSS)\n    {\n      /* The rlimit codes happen to each be one less\n\t than the corresponding vlimit codes.  */\n      enum __rlimit_resource rlimit_res =\n\t(enum __rlimit_resource) ((int) resource - 1);\n      struct rlimit lims;\n\n      if (__getrlimit (rlimit_res, &lims) < 0)\n\treturn -1;\n\n      lims.rlim_cur = value;\n      return __setrlimit (rlimit_res, &lims);\n    }\n\n  __set_errno (EINVAL);\n  return -1;\n}",
    "mq_close": "mq_close (mqd_t mqdes){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_getattr": "mq_getattr (mqd_t mqdes, struct mq_attr *mqstat){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_notify": "mq_notify (mqd_t mqdes, const struct sigevent *notification){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__mq_open_2": "__mq_open_2 (const char *name, int oflag){\n  if (oflag & O_CREAT)\n    __fortify_fail (\"invalid mq_open call: O_CREAT without mode and attr\");\n\n  return __mq_open (name, oflag);\n}",
    "mq_receive": "mq_receive (mqd_t mqdes, char *msg_ptr, size_t msg_len,\n\t    unsigned int *msg_prio){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_send": "mq_send (mqd_t mqdes, const char *msg_ptr, size_t msg_len,\n\t unsigned int msg_prio){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_setattr": "mq_setattr (mqd_t mqdes, const struct mq_attr *__restrict mqstat,\n\t    struct mq_attr *__restrict omqstat){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "mq_unlink": "mq_unlink (const char *name){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "timer_create": "timer_create (clockid_t clock_id, struct sigevent *evp, timer_t *timerid){\n  int retval = -1;\n  struct timer_node *newtimer = NULL;\n  struct thread_node *thread = NULL;\n\n  if (0\n#if defined _POSIX_CPUTIME && _POSIX_CPUTIME >= 0\n      || clock_id == CLOCK_PROCESS_CPUTIME_ID\n#endif\n#if defined _POSIX_THREAD_CPUTIME && _POSIX_THREAD_CPUTIME >= 0\n      || clock_id == CLOCK_THREAD_CPUTIME_ID\n#endif\n      )\n    {\n      /* We don't allow timers for CPU clocks.  At least not in the\n\t moment.  */\n      __set_errno (ENOTSUP);\n      return -1;\n    }\n\n  if (clock_id != CLOCK_REALTIME)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  pthread_once (&__timer_init_once_control, __timer_init_once);\n\n  if (__timer_init_failed)\n    {\n      __set_errno (ENOMEM);\n      return -1;\n    }\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  newtimer = __timer_alloc ();\n  if (__glibc_unlikely (newtimer == NULL))\n    {\n      __set_errno (EAGAIN);\n      goto unlock_bail;\n    }\n\n  if (evp != NULL)\n    newtimer->event = *evp;\n  else\n    {\n      newtimer->event.sigev_notify = SIGEV_SIGNAL;\n      newtimer->event.sigev_signo = SIGALRM;\n      newtimer->event.sigev_value.sival_ptr = newtimer;\n      newtimer->event.sigev_notify_function = 0;\n    }\n\n  newtimer->event.sigev_notify_attributes = &newtimer->attr;\n  newtimer->creator_pid = getpid ();\n\n  switch (__builtin_expect (newtimer->event.sigev_notify, SIGEV_SIGNAL))\n    {\n    case SIGEV_NONE:\n    case SIGEV_SIGNAL:\n      /* We have a global thread for delivering timed signals.\n\t If it is not running, try to start it up.  */\n      thread = &__timer_signal_thread_rclk;\n      if (! thread->exists)\n\t{\n\t  if (__builtin_expect (__timer_thread_start (thread),\n\t\t\t\t1) < 0)\n\t    {\n\t      __set_errno (EAGAIN);\n\t      goto unlock_bail;\n            }\n        }\n      break;\n\n    case SIGEV_THREAD:\n      /* Copy over thread attributes or set up default ones.  */\n      if (evp->sigev_notify_attributes)\n\tnewtimer->attr = *(pthread_attr_t *) evp->sigev_notify_attributes;\n      else\n\tpthread_attr_init (&newtimer->attr);\n\n      /* Ensure thread attributes call for detached thread.  */\n      pthread_attr_setdetachstate (&newtimer->attr, PTHREAD_CREATE_DETACHED);\n\n      /* Try to find existing thread having the right attributes.  */\n      thread = __timer_thread_find_matching (&newtimer->attr, clock_id);\n\n      /* If no existing thread has these attributes, try to allocate one.  */\n      if (thread == NULL)\n\tthread = __timer_thread_alloc (&newtimer->attr, clock_id);\n\n      /* Out of luck; no threads are available.  */\n      if (__glibc_unlikely (thread == NULL))\n\t{\n\t  __set_errno (EAGAIN);\n\t  goto unlock_bail;\n\t}\n\n      /* If the thread is not running already, try to start it.  */\n      if (! thread->exists\n\t  && __builtin_expect (! __timer_thread_start (thread), 0))\n\t{\n\t  __set_errno (EAGAIN);\n\t  goto unlock_bail;\n\t}\n      break;\n\n    default:\n      __set_errno (EINVAL);\n      goto unlock_bail;\n    }\n\n  newtimer->clock = clock_id;\n  newtimer->abstime = 0;\n  newtimer->armed = 0;\n  newtimer->thread = thread;\n\n  *timerid = timer_ptr2id (newtimer);\n  retval = 0;\n\n  if (__builtin_expect (retval, 0) == -1)\n    {\n    unlock_bail:\n      if (thread != NULL)\n\t__timer_thread_dealloc (thread);\n      if (newtimer != NULL)\n\t{\n\t  timer_delref (newtimer);\n\t  __timer_dealloc (newtimer);\n\t}\n    }\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  return retval;\n}",
    "timer_delete": "timer_delete (timer_t timerid){\n  struct timer_node *timer;\n  int retval = -1;\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  timer = timer_id2ptr (timerid);\n  if (! timer_valid (timer))\n    /* Invalid timer ID or the timer is not in use.  */\n    __set_errno (EINVAL);\n  else\n    {\n      if (timer->armed && timer->thread != NULL)\n\t{\n\t  struct thread_node *thread = timer->thread;\n\t  assert (thread != NULL);\n\n\t  /* If thread is cancelled while waiting for handler to terminate,\n\t     the mutex is unlocked and timer_delete is aborted.  */\n\t  pthread_cleanup_push (__timer_mutex_cancel_handler, &__timer_mutex);\n\n\t  /* If timer is currently being serviced, wait for it to finish.  */\n\t  while (thread->current_timer == timer)\n\t    pthread_cond_wait (&thread->cond, &__timer_mutex);\n\n\t  pthread_cleanup_pop (0);\n        }\n\n      /* Remove timer from whatever queue it may be on and deallocate it.  */\n      timer->inuse = TIMER_DELETED;\n      list_unlink_ip (&timer->links);\n      timer_delref (timer);\n      retval = 0;\n    }\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  return retval;\n}",
    "timer_getoverrun": "timer_getoverrun (timer_t timerid){\n  struct timer_node *timer;\n  int retval = -1;\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  if (! timer_valid (timer = timer_id2ptr (timerid)))\n    __set_errno (EINVAL);\n  else\n    retval = timer->overrun_count;\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  return retval;\n}",
    "timer_gettime": "timer_gettime (timer_t timerid, struct itimerspec *value){\n  struct timer_node *timer;\n  struct timespec now, expiry;\n  int retval = -1, armed = 0, valid;\n  clock_t clock = 0;\n\n  pthread_mutex_lock (&__timer_mutex);\n\n  timer = timer_id2ptr (timerid);\n  valid = timer_valid (timer);\n\n  if (valid) {\n    armed = timer->armed;\n    expiry = timer->expirytime;\n    clock = timer->clock;\n    value->it_interval = timer->value.it_interval;\n  }\n\n  pthread_mutex_unlock (&__timer_mutex);\n\n  if (valid)\n    {\n      if (armed)\n\t{\n\t  __clock_gettime (clock, &now);\n\t  if (timespec_compare (&now, &expiry) < 0)\n\t    timespec_sub (&value->it_value, &expiry, &now);\n\t  else\n\t    {\n\t      value->it_value.tv_sec = 0;\n\t      value->it_value.tv_nsec = 0;\n\t    }\n\t}\n      else\n\t{\n\t  value->it_value.tv_sec = 0;\n\t  value->it_value.tv_nsec = 0;\n\t}\n\n      retval = 0;\n    }\n  else\n    __set_errno (EINVAL);\n\n  return retval;\n}",
    "timer_settime": "timer_settime (timer_t timerid, int flags, const struct itimerspec *value,\n\t       struct itimerspec *ovalue){\n  struct timer_node *timer;\n  struct thread_node *thread = NULL;\n  struct timespec now;\n  int have_now = 0, need_wakeup = 0;\n  int retval = -1;\n\n  timer = timer_id2ptr (timerid);\n  if (timer == NULL)\n    {\n      __set_errno (EINVAL);\n      goto bail;\n    }\n\n  if (! valid_nanoseconds (value->it_interval.tv_nsec)\n      || ! valid_nanoseconds (value->it_value.tv_nsec))\n    {\n      __set_errno (EINVAL);\n      goto bail;\n    }\n\n  /* Will need to know current time since this is a relative timer;\n     might as well make the system call outside of the lock now! */\n\n  if ((flags & TIMER_ABSTIME) == 0)\n    {\n      __clock_gettime (timer->clock, &now);\n      have_now = 1;\n    }\n\n  pthread_mutex_lock (&__timer_mutex);\n  timer_addref (timer);\n\n  /* One final check of timer validity; this one is possible only\n     until we have the mutex, because it accesses the inuse flag. */\n\n  if (! timer_valid(timer))\n    {\n      __set_errno (EINVAL);\n      goto unlock_bail;\n    }\n\n  if (ovalue != NULL)\n    {\n      ovalue->it_interval = timer->value.it_interval;\n\n      if (timer->armed)\n\t{\n\t  if (! have_now)\n\t    {\n\t      pthread_mutex_unlock (&__timer_mutex);\n\t      __clock_gettime (timer->clock, &now);\n\t      have_now = 1;\n\t      pthread_mutex_lock (&__timer_mutex);\n\t      timer_addref (timer);\n\t    }\n\n\t  timespec_sub (&ovalue->it_value, &timer->expirytime, &now);\n\t}\n      else\n\t{\n\t  ovalue->it_value.tv_sec = 0;\n\t  ovalue->it_value.tv_nsec = 0;\n\t}\n    }\n\n  timer->value = *value;\n\n  list_unlink_ip (&timer->links);\n  timer->armed = 0;\n\n  thread = timer->thread;\n\n  /* A value of { 0, 0 } causes the timer to be stopped. */\n  if (value->it_value.tv_sec != 0\n      || __builtin_expect (value->it_value.tv_nsec != 0, 1))\n    {\n      if ((flags & TIMER_ABSTIME) != 0)\n\t/* The user specified the expiration time.  */\n\ttimer->expirytime = value->it_value;\n      else\n\ttimespec_add (&timer->expirytime, &now, &value->it_value);\n\n      /* Only need to wake up the thread if timer is inserted\n\t at the head of the queue. */\n      if (thread != NULL)\n\tneed_wakeup = __timer_thread_queue_timer (thread, timer);\n      timer->armed = 1;\n    }\n\n  retval = 0;\n\nunlock_bail:\n  timer_delref (timer);\n  pthread_mutex_unlock (&__timer_mutex);\n\nbail:\n  if (thread != NULL && need_wakeup)\n    __timer_thread_wakeup (thread);\n\n  return retval;\n}",
    "_setjmp": "_setjmp (jmp_buf env){\n  return __sigsetjmp (env, 0);\n}",
    "setjmp": "setjmp (jmp_buf env){\n  return __sigsetjmp (env, 1);\n}",
    "__libc_current_sigrtmin": "__libc_current_sigrtmin (void){\n#ifdef __SIGRTMIN\n  return current_rtmin;\n#else\n  return -1;\n#endif\n}",
    "__libc_current_sigrtmax": "__libc_current_sigrtmax (void){\n#ifdef __SIGRTMIN\n  return current_rtmax;\n#else\n  return -1;\n#endif\n}",
    "__libc_allocate_rtsig": "__libc_allocate_rtsig (int high){\n#ifndef __SIGRTMIN\n  return -1;\n#else\n  if (current_rtmin == -1 || current_rtmin > current_rtmax)\n    /* We don't have any more signals available.  */\n    return -1;\n\n  return high ? current_rtmin++ : current_rtmax--;\n#endif\n}",
    "killpg": "killpg (__pid_t pgrp, int sig){\n  if (pgrp < 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __kill (- pgrp, sig);\n}",
    "__libc_sigaction": "__libc_sigaction (int sig, const struct sigaction *act, struct sigaction *oact){\n  int result;\n\n  struct kernel_sigaction kact, koact;\n\n  if (act)\n    {\n      kact.k_sa_handler = act->sa_handler;\n      memcpy (&kact.sa_mask, &act->sa_mask, sizeof (sigset_t));\n      kact.sa_flags = act->sa_flags;\n      SET_SA_RESTORER (&kact, act);\n    }\n\n  /* XXX The size argument hopefully will have to be changed to the\n     real size of the user-level sigset_t.  */\n  result = INLINE_SYSCALL_CALL (rt_sigaction, sig,\n\t\t\t\tact ? &kact : NULL,\n\t\t\t\toact ? &koact : NULL, STUB (act,\n\t\t\t\t\t\t\t    __NSIG_BYTES));\n\n  if (oact && result >= 0)\n    {\n      oact->sa_handler = koact.k_sa_handler;\n      memcpy (&oact->sa_mask, &koact.sa_mask, sizeof (sigset_t));\n      oact->sa_flags = koact.sa_flags;\n      RESET_SA_RESTORER (oact, &koact);\n    }\n  return result;\n}",
    "raise": "raise (int sig){\n  int ret = __pthread_kill (__pthread_self (), sig);\n  if (ret != 0)\n    {\n      __set_errno (ret);\n      ret = -1;\n    }\n  return ret;\n}",
    "__sigaction": "__sigaction (int sig, const struct sigaction *act, struct sigaction *oact){\n  if (sig <= 0 || sig >= NSIG || is_internal_signal (sig))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __libc_sigaction (sig, act, oact);\n}",
    "sigaddset": "sigaddset (sigset_t *set, int signo){\n  if (set == NULL || signo <= 0 || signo >= NSIG\n      || is_internal_signal (signo))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigaddset (set, signo);\n  return 0;\n}",
    "sigaltstack": "sigaltstack (const stack_t *ss, stack_t *oss){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "sigandset": "sigandset (sigset_t *dest, const sigset_t *left, const sigset_t *right){\n  if (!dest || !left || !right)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigandset (dest, left, right);\n  return 0;\n}",
    "sigdelset": "sigdelset (sigset_t *set, int signo){\n  if (set == NULL || signo <= 0 || signo >= NSIG\n      || is_internal_signal (signo))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigdelset (set, signo);\n  return 0;\n}",
    "sigemptyset": "sigemptyset (sigset_t *set){\n  if (set == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigemptyset (set);\n  return 0;\n}",
    "sigfillset": "sigfillset (sigset_t *set){\n  if (set == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigfillset (set);\n  clear_internal_signals (set);\n  return 0;\n}",
    "siggetmask": "siggetmask (void){\n  return __sigblock (0);\n}",
    "sighold": "sighold (int sig){\n  sigset_t set;\n\n  sigemptyset (&set);\n  if (sigaddset (&set, sig) < 0)\n    return -1;\n  return __sigprocmask (SIG_BLOCK, &set, NULL);\n}",
    "sigignore": "sigignore (int sig){\n  struct sigaction act;\n\n  act.sa_handler = SIG_IGN;\n  __sigemptyset (&act.sa_mask);\n  act.sa_flags = 0;\n\n  return __sigaction (sig, &act, NULL);\n}",
    "siginterrupt": "siginterrupt (int sig, int interrupt){\n#ifdef\tSA_RESTART\n  extern sigset_t _sigintr attribute_hidden;\t/* Defined in signal.c.  */\n  struct sigaction action;\n\n  if (__sigaction (sig, (struct sigaction *) NULL, &action) < 0)\n    return -1;\n\n  if (interrupt)\n    {\n      __sigaddset (&_sigintr, sig);\n      action.sa_flags &= ~SA_RESTART;\n    }\n  else\n    {\n      __sigdelset (&_sigintr, sig);\n      action.sa_flags |= SA_RESTART;\n    }\n\n  if (__sigaction (sig, &action, (struct sigaction *) NULL) < 0)\n    return -1;\n\n  return 0;\n#else\n  __set_errno (ENOSYS);\n  return -1;\n#endif\n}",
    "sigisemptyset": "sigisemptyset (const sigset_t *set){\n  if (!set)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __sigisemptyset (set);\n}",
    "sigismember": "sigismember (const sigset_t *set, int signo){\n  if (set == NULL || signo <= 0 || signo >= NSIG)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __sigismember (set, signo);\n}",
    "signal": "signal (int sig, __sighandler_t handler){\n  __set_errno (ENOSYS);\n  return SIG_ERR;\n}",
    "sigorset": "sigorset (sigset_t *dest, const sigset_t *left, const sigset_t *right){\n  if (!dest || !left || !right)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __sigorset (dest, left, right);\n  return 0;\n}",
    "__sigpause": "__sigpause (int sig_or_mask, int is_sig){\n  sigset_t set;\n\n  if (is_sig != 0)\n    {\n      /* The modern X/Open implementation is requested.  */\n      if (__sigprocmask (0, NULL, &set) < 0\n\t  || sigdelset (&set, sig_or_mask) < 0)\n\treturn -1;\n    }\n  else if (sigset_set_old_mask (&set, sig_or_mask) < 0)\n    return -1;\n\n  /* Note the sigpause() is a cancellation point.  But since we call\n     sigsuspend() which itself is a cancellation point we do not have\n     to do anything here.  */\n  return __sigsuspend (&set);\n}",
    "sigpending": "sigpending (sigset_t *set){\n  return INLINE_SYSCALL_CALL (rt_sigpending, set, __NSIG_BYTES);\n}",
    "sigrelse": "sigrelse (int sig){\n  sigset_t set;\n\n  sigemptyset (&set);\n  if (sigaddset (&set, sig) < 0)\n    return -1;\n  return __sigprocmask (SIG_UNBLOCK, &set, NULL);\n}",
    "sigset": "sigset (int sig, __sighandler_t disp){\n  struct sigaction act;\n  struct sigaction oact;\n  sigset_t set;\n  sigset_t oset;\n\n  __sigemptyset (&set);\n  if (sigaddset (&set, sig) < 0)\n    return SIG_ERR;\n\n  if (disp == SIG_HOLD)\n    {\n      /* Add the signal to the current signal mask.  */\n      if (__sigprocmask (SIG_BLOCK, &set, &oset) < 0)\n\treturn SIG_ERR;\n\n      /* If the signal was already blocked signal this to the caller.  */\n      if (__sigismember (&oset, sig))\n\treturn SIG_HOLD;\n\n      /* We need to determine whether a specific handler is installed.  */\n      if (__sigaction (sig, NULL, &oact) < 0)\n\treturn SIG_ERR;\n\n      return oact.sa_handler;\n    }\n  else\n    {\n      act.sa_handler = disp;\n      __sigemptyset (&act.sa_mask);\n      act.sa_flags = 0;\n      if (__sigaction (sig, &act, &oact) < 0)\n\treturn SIG_ERR;\n\n      /* Remove the signal from the current signal mask.  */\n      if (__sigprocmask (SIG_UNBLOCK, &set, &oset) < 0)\n\treturn SIG_ERR;\n\n      /* If the signal was already blocked return SIG_HOLD.  */\n      return __sigismember (&oset, sig) ? SIG_HOLD : oact.sa_handler;\n    }\n}",
    "sigstack": "sigstack (struct sigstack *ss, struct sigstack *oss){\n  stack_t sas;\n  stack_t *sasp = NULL;\n  stack_t osas;\n  stack_t *osasp = oss == NULL ? NULL : &osas;\n  int result;\n\n  if (ss != NULL)\n    {\n      /* We have to convert the information.  */\n      sas.ss_sp = ss->ss_sp;\n      sas.ss_flags = ss->ss_onstack ? SS_ONSTACK : 0;\n\n      /* For the size of the stack we have no value we can pass to the\n\t kernel.  This is why this function should not be used.  We simply\n\t assume that all the memory down to address zero (in case the stack\n\t grows down) is available.  */\n      sas.ss_size = ss->ss_sp - NULL;\n\n      sasp = &sas;\n    }\n\n  /* Call the kernel.  */\n  result = __sigaltstack (sasp, osasp);\n\n  /* Convert the result, if wanted and possible.  */\n  if (result == 0 && oss != NULL)\n    {\n      oss->ss_sp = osas.ss_sp;\n      oss->ss_onstack = (osas.ss_flags & SS_ONSTACK) != 0;\n    }\n\n  return result;\n}",
    "__sigsuspend": "__sigsuspend (const sigset_t *set){\n  return SYSCALL_CANCEL (rt_sigsuspend, set, __NSIG_BYTES);\n}",
    "__sigtimedwait": "__sigtimedwait (const sigset_t *set, siginfo_t *info,\n\t\tconst struct timespec *timeout){\n  struct __timespec64 ts64, *pts64 = NULL;\n  if (timeout != NULL)\n    {\n      ts64 = valid_timespec_to_timespec64 (*timeout);\n      pts64 = &ts64;\n    }\n  return __sigtimedwait64 (set, info, pts64);\n}",
    "__sysv_signal": "__sysv_signal (int sig, __sighandler_t handler){\n  struct sigaction act, oact;\n\n  /* Check signal extents to protect __sigismember.  */\n  if (handler == SIG_ERR || sig < 1 || sig >= NSIG)\n    {\n      __set_errno (EINVAL);\n      return SIG_ERR;\n    }\n\n  act.sa_handler = handler;\n  __sigemptyset (&act.sa_mask);\n  act.sa_flags = SA_ONESHOT | SA_NOMASK | SA_INTERRUPT;\n  act.sa_flags &= ~SA_RESTART;\n  if (__sigaction (sig, &act, &oact) < 0)\n    return SIG_ERR;\n\n  return oact.sa_handler;\n}",
    "accept": "accept (int fd, __SOCKADDR_ARG addrarg, socklen_t *addr_len){\n  return __libc_accept4 (fd, addrarg, addr_len, 0);\n}",
    "__connect": "__connect (int fd, __CONST_SOCKADDR_ARG addrarg, socklen_t len){\n  error_t err;\n  addr_port_t aport;\n  const struct sockaddr_un *addr = addrarg.__sockaddr_un__;\n  int cancel_oldtype;\n\n  if (addr->sun_family == AF_LOCAL)\n    {\n      char *name = _hurd_sun_path_dupa (addr, len);\n      /* For the local domain, we must look up the name as a file and talk\n\t to it with the ifsock protocol.  */\n      file_t file;\n      cancel_oldtype = LIBC_CANCEL_ASYNC();\n      file = __file_name_lookup (name, 0, 0);\n      LIBC_CANCEL_RESET (cancel_oldtype);\n      if (file == MACH_PORT_NULL)\n\treturn -1;\n      err = __ifsock_getsockaddr (file, &aport);\n      __mach_port_deallocate (__mach_task_self (), file);\n      if (err == MIG_BAD_ID || err == EOPNOTSUPP)\n\t/* The file did not grok the ifsock protocol.  */\n\terr = ENOTSOCK;\n      if (err)\n\treturn __hurd_fail (err);\n    }\n  else\n    err = EIEIO;\n\n  err = HURD_DPORT_USE_CANCEL (fd,\n\t\t\t({\n\t\t\t  if (err)\n\t\t\t    err = __socket_create_address (port,\n\t\t\t\t\t\t\t   addr->sun_family,\n\t\t\t\t\t\t\t   (char *) addr, len,\n\t\t\t\t\t\t\t   &aport);\n\t\t\t  if (! err)\n\t\t\t    {\n\t\t\t      cancel_oldtype = LIBC_CANCEL_ASYNC();\n\t\t\t      err = __socket_connect (port, aport);\n\t\t\t      LIBC_CANCEL_RESET (cancel_oldtype);\n\t\t\t      __mach_port_deallocate (__mach_task_self (),\n\t\t\t\t\t\t      aport);\n\t\t\t    }\n\t\t\t  err;\n\t\t\t}));\n\n  return err ? __hurd_dfail (fd, err) : 0;\n}",
    "getpeername": "getpeername (int fd, __SOCKADDR_ARG addr, socklen_t *len){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getsockopt": "getsockopt (int fd,\n\t    int level,\n\t    int optname,\n\t    void *optval,\n\t    socklen_t *optlen){\n  error_t err;\n  char *buf = optval;\n  mach_msg_type_number_t buflen = *optlen;\n\n  if (err = HURD_DPORT_USE (fd, __socket_getopt (port,\n\t\t\t\t\t\t level, optname,\n\t\t\t\t\t\t &buf, &buflen)))\n    return __hurd_dfail (fd, err);\n\n  if (*optlen > buflen)\n    *optlen = buflen;\n  if (buf != optval)\n    {\n      memcpy (optval, buf, *optlen);\n      __vm_deallocate (__mach_task_self (), (vm_address_t) buf, buflen);\n    }\n\n  return 0;\n}",
    "isfdtype": "isfdtype (int fildes, int fdtype){\n  struct __stat64_t64 st;\n  int result;\n\n  {\n    int save_error = errno;\n    result = __fstat64_time64 (fildes, &st);\n    __set_errno (save_error);\n  }\n\n  return result ?: (st.st_mode & S_IFMT) == (mode_t) fdtype;\n}",
    "__recv": "__recv (int fd, void *buf, size_t n, int flags){\n  error_t err;\n  mach_port_t addrport;\n  char *bufp = buf;\n  mach_msg_type_number_t nread = n;\n  mach_port_t *ports;\n  mach_msg_type_number_t nports = 0;\n  char *cdata = NULL;\n  mach_msg_type_number_t clen = 0;\n  int cancel_oldtype;\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  err = HURD_DPORT_USE_CANCEL (fd, __socket_recv (port, &addrport,\n\t\t\t\t\t\t  flags, &bufp, &nread,\n\t\t\t\t\t\t  &ports, &nports,\n\t\t\t\t\t\t  &cdata, &clen,\n\t\t\t\t\t\t  &flags,\n\t\t\t\t\t\t  n));\n  LIBC_CANCEL_RESET (cancel_oldtype);\n\n  if (err == MIG_BAD_ID || err == EOPNOTSUPP)\n    /* The file did not grok the socket protocol.  */\n    err = ENOTSOCK;\n  if (err)\n    return __hurd_sockfail (fd, flags, err);\n\n  if (MACH_PORT_VALID (addrport))\n    __mach_port_deallocate (__mach_task_self (), addrport);\n  __vm_deallocate (__mach_task_self (), (vm_address_t) cdata, clen);\n\n  if (bufp != buf)\n    {\n      memcpy (buf, bufp, nread);\n      __vm_deallocate (__mach_task_self (), (vm_address_t) bufp, nread);\n    }\n\n  return nread;\n}",
    "recvmmsg": "recvmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags,\n\t  struct timespec *tmo){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_sa_len": "__libc_sa_len (sa_family_t af){\n  switch (af)\n    {\n# ifdef HAVE_NETATALK_AT_H\n    case AF_APPLETALK:\n      return sizeof (struct sockaddr_at);\n# endif\n# ifdef HAVE_NETASH_ASH_H\n    case AF_ASH:\n      return sizeof (struct sockaddr_ash);\n# endif\n# ifdef HAVE_NETAX25_AX25_H\n    case AF_AX25:\n      return sizeof (struct sockaddr_ax25);\n# endif\n# ifdef HAVE_NETECONET_EC_H\n    case AF_ECONET:\n      return sizeof (struct sockaddr_ec);\n# endif\n    case AF_INET:\n      return sizeof (struct sockaddr_in);\n    case AF_INET6:\n      return sizeof (struct sockaddr_in6);\n# ifdef HAVE_NETIPX_IPX_H\n    case AF_IPX:\n      return sizeof (struct sockaddr_ipx);\n# endif\n# ifdef HAVE_NETIUCV_IUCV_H\n    case AF_IUCV:\n      return sizeof (struct sockaddr_iucv);\n# endif\n    case AF_LOCAL:\n      return sizeof (struct sockaddr_un);\n# ifdef HAVE_NETPACKET_PACKET_H\n    case AF_PACKET:\n      return sizeof (struct sockaddr_ll);\n# endif\n# ifdef HAVE_NETROSE_ROSE_H\n    case AF_ROSE:\n      return sizeof (struct sockaddr_rose);\n# endif\n    }\n  return 0;\n}",
    "__send": "__send (int fd, const void *buf, size_t n, int flags){\n  error_t err;\n  vm_size_t wrote;\n  int cancel_oldtype;\n\n  cancel_oldtype = LIBC_CANCEL_ASYNC();\n  err = HURD_DPORT_USE_CANCEL (fd, __socket_send (port, MACH_PORT_NULL,\n\t\t\t\t\t\t  flags, buf, n,\n\t\t\t\t\t\t  NULL, MACH_MSG_TYPE_COPY_SEND, 0,\n\t\t\t\t\t\t  NULL, 0, &wrote));\n  LIBC_CANCEL_RESET (cancel_oldtype);\n\n  if (err == MIG_BAD_ID || err == EOPNOTSUPP)\n    /* The file did not grok the socket protocol.  */\n    err = ENOTSOCK;\n\n  return err ? __hurd_sockfail (fd, flags, err) : wrote;\n}",
    "__sendmmsg": "__sendmmsg (int fd, struct mmsghdr *vmessages, unsigned int vlen, int flags){\n#ifdef __ASSUME_SENDMMSG_SYSCALL\n  return SYSCALL_CANCEL (sendmmsg, fd, vmessages, vlen, flags);\n#else\n  return SOCKETCALL_CANCEL (sendmmsg, fd, vmessages, vlen, flags);\n#endif\n}",
    "shutdown": "shutdown (int fd, int how){\n  error_t err = HURD_DPORT_USE (fd, __socket_shutdown (port, how));\n  if (err)\n    return __hurd_dfail (fd, err);\n  return 0;\n}",
    "sockatmark": "sockatmark (int fd){\n  int answ;\n\n  return __ioctl (fd, SIOCATMARK, &answ) == -1 ? -1 : answ;\n}",
    "__socket": "__socket (int fd, int type, int domain){\n#ifdef __ASSUME_SOCKET_SYSCALL\n  return INLINE_SYSCALL_CALL (socket, fd, type, domain);\n#else\n  return SOCKETCALL (socket, fd, type, domain);\n#endif\n}",
    "socketpair": "socketpair (int domain, int type, int protocol, int fds[2]){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "ctermid": "*\nctermid (char *s){\n  char *name = (char /*drop const*/ *) \"/dev/tty\";\n\n  if (s == NULL)\n    return name;\n\n  return strcpy (s, name);\n}",
    "cuserid": "*\ncuserid (char *s){\n  static char name[L_cuserid];\n  char buf[NSS_BUFLEN_PASSWD];\n  struct passwd pwent;\n  struct passwd *pwptr;\n\n  if (__getpwuid_r (__geteuid (), &pwent, buf, sizeof (buf), &pwptr)\n      || pwptr == NULL)\n    {\n      if (s != NULL)\n\ts[0] = '\\0';\n      return s;\n    }\n\n  if (s == NULL)\n    s = name;\n  s[L_cuserid - 1] = '\\0';\n  return strncpy (s, pwptr->pw_name, L_cuserid - 1);\n}",
    "getw": "getw (FILE *stream){\n  int w;\n\n  /* Is there a better way?  */\n  if (fread ((void *) &w, sizeof (w), 1, stream) != 1)\n    return EOF;\n  return w;\n}",
    "__isoc23_fscanf": "attribute_hidden\n__isoc23_fscanf (FILE *stream, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___isoc23_vfscanf (stream, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_scanf": "attribute_hidden\n__isoc23_scanf (const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___isoc23_vfscanf (stdin, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_sscanf": "attribute_hidden\n__isoc23_sscanf (const char *s, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___isoc23_vsscanf (s, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_vfscanf": "__isoc23_vfscanf (FILE *s, const char *fmt, va_list ap){\n  return __nldbl___isoc23_vfscanf (s, fmt, ap);\n}",
    "__isoc23_vscanf": "attribute_hidden\n__isoc23_vscanf (const char *fmt, va_list ap){\n  return __nldbl___isoc23_vfscanf (stdin, fmt, ap);\n}",
    "__isoc23_vsscanf": "__isoc23_vsscanf (const char *string, const char *fmt, va_list ap){\n  return __nldbl___isoc23_vsscanf (string, fmt, ap);\n}",
    "__isoc99_fscanf": "attribute_hidden\n__isoc99_fscanf (FILE *stream, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___isoc99_vfscanf (stream, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_scanf": "attribute_hidden\n__isoc99_scanf (const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___isoc99_vfscanf (stdin, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_sscanf": "attribute_hidden\n__isoc99_sscanf (const char *s, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___isoc99_vsscanf (s, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_vfscanf": "__isoc99_vfscanf (FILE *s, const char *fmt, va_list ap){\n  return __nldbl___isoc99_vfscanf (s, fmt, ap);\n}",
    "__isoc99_vscanf": "attribute_hidden\n__isoc99_vscanf (const char *fmt, va_list ap){\n  return __nldbl___isoc99_vfscanf (stdin, fmt, ap);\n}",
    "__isoc99_vsscanf": "__isoc99_vsscanf (const char *string, const char *fmt, va_list ap){\n  return __nldbl___isoc99_vsscanf (string, fmt, ap);\n}",
    "perror": "perror (const char *s){\n  int errnum = errno;\n  FILE *fp;\n  int fd = -1;\n\n\n  /* The standard says that 'perror' must not change the orientation\n     of the stream.  What is supposed to happen when the stream isn't\n     oriented yet?  In this case we'll create a new stream which is\n     using the same underlying file descriptor.  */\n  if (__builtin_expect (_IO_fwide (stderr, 0) != 0, 1)\n      || (fd = __fileno (stderr)) == -1\n      || (fd = __dup (fd)) == -1\n      || (fp = fdopen (fd, \"w+\")) == NULL)\n    {\n      if (__glibc_unlikely (fd != -1))\n\t__close (fd);\n\n      /* Use standard error as is.  */\n      perror_internal (stderr, s, errnum);\n    }\n  else\n    {\n      /* We don't have to do any special hacks regarding the file\n\t position.  Since the stderr stream wasn't used so far we just\n\t write to the descriptor.  */\n      perror_internal (fp, s, errnum);\n\n      if (_IO_ferror_unlocked (fp))\n\tstderr->_flags |= _IO_ERR_SEEN;\n\n      /* Close the stream.  */\n      fclose (fp);\n    }\n}",
    "parse_printf_format": "parse_printf_format (const char *fmt, size_t n, int *argtypes){\n  size_t nargs;\t\t\t/* Number of arguments.  */\n  size_t max_ref_arg;\t\t/* Highest index used in a positional arg.  */\n  struct printf_spec spec;\n  const unsigned char *f = (const unsigned char *) fmt;\n  bool failed;\n\n  nargs = 0;\n  max_ref_arg = 0;\n\n  /* Search for format specifications.  */\n  for (f = __find_specmb (f); *f != '\\0'; f = spec.next_fmt)\n    {\n      /* Parse this spec.  */\n      nargs += __parse_one_specmb (f, nargs, &spec, &max_ref_arg, &failed);\n\n      /* If the width is determined by an argument, it is an int.  */\n      if (spec.width_arg != -1 && (size_t) spec.width_arg < n)\n\targtypes[spec.width_arg] = PA_INT;\n\n      /* If the precision is determined by an argument, it is an int.  */\n      if (spec.prec_arg != -1 && (size_t) spec.prec_arg < n)\n\targtypes[spec.prec_arg] = PA_INT;\n\n      if ((size_t) spec.data_arg < n)\n\tswitch (spec.ndata_args)\n\t  {\n\t  case 0:\t\t/* No arguments.  */\n\t    break;\n\t  case 1:\t\t/* One argument; we already have the type.  */\n\t    argtypes[spec.data_arg] = spec.data_arg_type;\n\t    break;\n\t  default:\n\t    /* We have more than one argument for this format spec.  We must\n               call the arginfo function again to determine all the types.  */\n\t    (void) (*__printf_arginfo_table[spec.info.spec])\n\t      (&spec.info, n - spec.data_arg, &argtypes[spec.data_arg],\n\t       &spec.size);\n\t    break;\n\t  }\n    }\n\n  return MAX (nargs, max_ref_arg);\n}",
    "printf_size_info": "printf_size_info (const struct printf_info *info, size_t n, int *argtypes){\n  /* We need only one double or long double argument.  */\n  if (n >= 1)\n    argtypes[0] = PA_DOUBLE | (info->is_long_double ? PA_FLAG_LONG_DOUBLE : 0);\n\n  return 1;\n}",
    "psiginfo": "psiginfo (const siginfo_t *pinfo, const char *s){\n  char buf[512];\n  FILE *fp = __fmemopen (buf, sizeof (buf), \"w\");\n  if (fp == NULL)\n    {\n      const char *colon;\n\n      if (s == NULL || *s == '\\0')\n\ts = colon = \"\";\n      else\n\tcolon = \": \";\n\n      __fxprintf (NULL, \"%s%ssignal %d\\n\", s, colon, pinfo->si_signo);\n      return;\n    }\n\n  if (s != NULL && *s != '\\0')\n    fprintf (fp, \"%s: \", s);\n\n  const char *desc;\n  if (pinfo->si_signo >= 0 && pinfo->si_signo < NSIG\n      && ((desc = __sys_siglist[pinfo->si_signo]) != NULL\n#ifdef SIGRTMIN\n\t  || (pinfo->si_signo >= SIGRTMIN && pinfo->si_signo < SIGRTMAX)\n#endif\n\t ))\n    {\n#ifdef SIGRTMIN\n      if (desc == NULL)\n\t{\n\t  if (pinfo->si_signo - SIGRTMIN < SIGRTMAX - pinfo->si_signo)\n\t    {\n\t      if (pinfo->si_signo == SIGRTMIN)\n\t\tfprintf (fp, \"SIGRTMIN (\");\n\t      else\n\t\tfprintf (fp, \"SIGRTMIN+%d (\", pinfo->si_signo - SIGRTMIN);\n\t    }\n\t  else\n\t    {\n\t      if (pinfo->si_signo == SIGRTMAX)\n\t\tfprintf (fp, \"SIGRTMAX (\");\n\t      else\n\t\tfprintf (fp, \"SIGRTMAX-%d (\", SIGRTMAX - pinfo->si_signo);\n\t    }\n\t}\n      else\n#endif\n\tfprintf (fp, \"%s (\", _(desc));\n\n      const char *base = NULL;\n      const uint8_t *offarr = NULL;\n      size_t offarr_len = 0;\n      switch (pinfo->si_signo)\n\t{\n#define H(sig) \\\n\tcase sig:\t\t\t\t\t\t\t      \\\n\t  base = C(codestrs_, sig).str;\t\t\t\t\t      \\\n\t  offarr = C (codes_, sig);\t\t\t\t\t      \\\n\t  offarr_len = array_length (C (codes_, sig));\t\t\t      \\\n\t  break\n\n\t  H (SIGILL);\n\t  H (SIGFPE);\n\t  H (SIGSEGV);\n\t  H (SIGBUS);\n\t  H (SIGTRAP);\n\t  H (SIGCHLD);\n\t  H (SIGPOLL);\n\t}\n\n      const char *str = NULL;\n      if (offarr != NULL\n\t  && pinfo->si_code >= 1 && pinfo->si_code <= offarr_len)\n\tstr = base + offarr[pinfo->si_code - 1];\n      else\n\tswitch (pinfo->si_code)\n\t  {\n\t  case SI_USER:\n\t    str = N_(\"Signal sent by kill()\");\n\t    break;\n\t  case SI_QUEUE:\n\t    str = N_(\"Signal sent by sigqueue()\");\n\t    break;\n\t  case SI_TIMER:\n\t    str = N_(\"Signal generated by the expiration of a timer\");\n\t    break;\n\t  case SI_ASYNCIO:\n\t    str = N_(\"\\\nSignal generated by the completion of an asynchronous I/O request\");\n\t    break;\n\t  case SI_MESGQ:\n\t    str = N_(\"\\\nSignal generated by the arrival of a message on an empty message queue\");\n\t    break;\n#ifdef SI_TKILL\n\t  case SI_TKILL:\n\t    str = N_(\"Signal sent by tkill()\");\n\t    break;\n#endif\n#ifdef SI_ASYNCNL\n\t  case SI_ASYNCNL:\n\t    str = N_(\"\\\nSignal generated by the completion of an asynchronous name lookup request\");\n\t    break;\n#endif\n#ifdef SI_SIGIO\n\t  case SI_SIGIO:\n\t    str = N_(\"\\\nSignal generated by the completion of an I/O request\");\n\t    break;\n#endif\n#ifdef SI_KERNEL\n\t  case SI_KERNEL:\n\t    str = N_(\"Signal sent by the kernel\");\n\t    break;\n#endif\n\t  }\n\n      if (str != NULL)\n\tfprintf (fp, \"%s \", _(str));\n      else\n\tfprintf (fp, \"%d \", pinfo->si_code);\n\n      if (pinfo->si_signo == SIGILL || pinfo->si_signo == SIGFPE\n\t  || pinfo->si_signo == SIGSEGV || pinfo->si_signo == SIGBUS)\n\tfprintf (fp, \"[%p])\\n\", pinfo->si_addr);\n      else if (pinfo->si_signo == SIGCHLD)\n\tfprintf (fp, \"%ld %d %ld)\\n\",\n\t\t (long int) pinfo->si_pid, pinfo->si_status,\n\t\t (long int) pinfo->si_uid);\n      else if (pinfo->si_signo == SIGPOLL)\n\tfprintf (fp, \"%ld)\\n\", (long int) pinfo->si_band);\n      else\n\tfprintf (fp, \"%ld %ld)\\n\",\n\t\t (long int) pinfo->si_pid, (long int) pinfo->si_uid);\n    }\n  else\n    fprintf (fp, _(\"Unknown signal %d\\n\"),  pinfo->si_signo);\n\n  fclose (fp);\n\n  __write_nocancel (STDERR_FILENO, buf, strlen (buf));\n}",
    "psignal": "psignal (int sig, const char *s){\n  const char *colon, *desc;\n\n  if (s == NULL || *s == '\\0')\n    s = colon = \"\";\n  else\n    colon = \": \";\n\n  if (sig >= 0 && sig < NSIG && (desc = __sys_siglist[sig]) != NULL)\n    (void) __fxprintf (NULL, \"%s%s%s\\n\", s, colon, _(desc));\n  else\n    {\n      char *buf;\n\n      if (__asprintf (&buf, _(\"%s%sUnknown signal %d\\n\"), s, colon, sig) < 0)\n\t(void) __fxprintf (NULL, \"%s%s%s\\n\", s, colon, _(\"Unknown signal\"));\n      else\n\t{\n\t  (void) __fxprintf (NULL, \"%s\", buf);\n\n\t  free (buf);\n\t}\n    }\n}",
    "putw": "putw (int w, FILE *stream){\n  /* Is there a better way?  */\n  if (fwrite ((const void *) &w, sizeof (w), 1, stream) < 1)\n    return EOF;\n  return 0;\n}",
    "remove": "remove (const char *file){\n  /* First try to unlink since this is more frequently the necessary action. */\n  if (__unlink (file) != 0\n      /* If it is indeed a directory...  */\n      && (IS_NO_DIRECTORY_ERROR\n\t  /* ...try to remove it.  */\n\t  || __rmdir (file) != 0))\n    /* Cannot remove the object for whatever reason.  */\n    return -1;\n\n  return 0;\n}",
    "rename": "rename (const char *old, const char *new){\n#if defined (__NR_rename)\n  return INLINE_SYSCALL_CALL (rename, old, new);\n#elif defined (__NR_renameat)\n  return INLINE_SYSCALL_CALL (renameat, AT_FDCWD, old, AT_FDCWD, new);\n#else\n  return INLINE_SYSCALL_CALL (renameat2, AT_FDCWD, old, AT_FDCWD, new, 0);\n#endif\n}",
    "tempnam": "*\ntempnam (const char *dir, const char *pfx){\n  char buf[FILENAME_MAX];\n\n  if (__path_search (buf, FILENAME_MAX, dir, pfx, 1))\n    return NULL;\n\n  if (__gen_tempname (buf, 0, 0, __GT_NOCREATE))\n    return NULL;\n\n  return __strdup (buf);\n}",
    "tmpfile": "*\ntmpfile (void){\n  int fd;\n  FILE *f;\n  int flags = 0;\n#ifdef FLAGS\n  flags = FLAGS;\n#endif\n\n  /* First try a system specific method.  */\n  fd = __gen_tempfd (flags);\n\n  if (fd < 0)\n    {\n      char buf[FILENAME_MAX];\n\n      if (__path_search (buf, sizeof buf, NULL, \"tmpf\", 0))\n\treturn NULL;\n\n      fd = __gen_tempname (buf, 0, flags, __GT_FILE);\n      if (fd < 0)\n\treturn NULL;\n\n      /* Note that this relies on the Unix semantics that\n\t a file is not really removed until it is closed.  */\n      (void) __unlink (buf);\n    }\n\n  if ((f = __fdopen (fd, \"w+b\")) == NULL)\n    __close (fd);\n\n  return f;\n}",
    "tmpnam": "*\ntmpnam (char s[L_tmpnam]){\n  /* By using two buffers we manage to be thread safe in the case\n     where S != NULL.  */\n  char tmpbufmem[L_tmpnam];\n  char *tmpbuf = s ?: tmpbufmem;\n\n  /* In the following call we use the buffer pointed to by S if\n     non-NULL although we don't know the size.  But we limit the size\n     to L_tmpnam characters in any case.  */\n  if (__builtin_expect (__path_search (tmpbuf, L_tmpnam, NULL, NULL, 0),\n\t\t\t0))\n    return NULL;\n\n  if (__glibc_unlikely (__gen_tempname (tmpbuf, 0, 0, __GT_NOCREATE)))\n    return NULL;\n\n  if (s == NULL)\n    return (char *) memcpy (tmpnam_buffer, tmpbuf, L_tmpnam);\n\n  return s;\n}",
    "tmpnam_r": "*\ntmpnam_r (char s[L_tmpnam]){\n  if (s == NULL)\n    return NULL;\n\n  if (__path_search (s, L_tmpnam, NULL, NULL, 0))\n    return NULL;\n  if (__gen_tempname (s, 0, 0, __GT_NOCREATE))\n    return NULL;\n\n  return s;\n}",
    "vfprintf": "attribute_hidden\nvfprintf (FILE *s, const char *fmt, va_list ap){\n  return __nldbl_vfprintf (s, fmt, ap);\n}",
    "a64l": "a64l (const char *string){\n  const char *ptr = string;\n  unsigned long int result = 0ul;\n  const char *end = ptr + 6;\n  int shift = 0;\n\n  do\n    {\n      unsigned index;\n      unsigned value;\n\n      index = *ptr - TABLE_BASE;\n      if ((unsigned int) index >= TABLE_SIZE)\n\tbreak;\n      value = (int) a64l_table[index];\n      if (value == (int) XX)\n\tbreak;\n      ++ptr;\n      result |= value << shift;\n      shift += 6;\n    }\n  while (ptr != end);\n\n  return (long int) result;\n}",
    "abort": "weak_function\nabort (void){\n  /* Try to abort using the system specific command.  */\n  ABORT_INSTRUCTION;\n\n  /* If the abort instruction failed, exit.  */\n  _exit (127);\n\n  /* If even this fails, make sure we never return.  */\n  while (1)\n    /* Try for ever and ever.  */\n    ABORT_INSTRUCTION;\n}",
    "abs": "abs (int i){\n  return i < 0 ? -i : i;\n}",
    "atof": "atof (const char *nptr){\n  return strtod (nptr, (char **) NULL);\n}",
    "atoi": "atoi (const char *nptr){\n  return (int) strtol (nptr, (char **) NULL, 10);\n}",
    "atol": "atol (const char *nptr){\n  return strtol (nptr, (char **) NULL, 10);\n}",
    "atoll": "atoll (const char *nptr){\n  return strtoll (nptr, (char **) NULL, 10);\n}",
    "__cxa_at_quick_exit": "__cxa_at_quick_exit (void (*func) (void *), void *d){\n  return __internal_atexit (func, NULL, d, &__quick_exit_funcs);\n}",
    "__cxa_atexit": "__cxa_atexit (void (*func) (void *), void *arg, void *d){\n  return __internal_atexit (func, arg, d, &__exit_funcs);\n}",
    "__cxa_finalize": "__cxa_finalize (void *d){\n  struct exit_function_list *funcs;\n\n  __libc_lock_lock (__exit_funcs_lock);\n\n restart:\n  for (funcs = __exit_funcs; funcs; funcs = funcs->next)\n    {\n      struct exit_function *f;\n\n      for (f = &funcs->fns[funcs->idx - 1]; f >= &funcs->fns[0]; --f)\n\tif ((d == NULL || d == f->func.cxa.dso_handle) && f->flavor == ef_cxa)\n\t  {\n\t    const uint64_t check = __new_exitfn_called;\n\t    void (*cxafn) (void *arg, int status) = f->func.cxa.fn;\n\t    void *cxaarg = f->func.cxa.arg;\n\n\t    /* We don't want to run this cleanup more than once.  The Itanium\n\t       C++ ABI requires that multiple calls to __cxa_finalize not\n\t       result in calling termination functions more than once.  One\n\t       potential scenario where that could happen is with a concurrent\n\t       dlclose and exit, where the running dlclose must at some point\n\t       release the list lock, an exiting thread may acquire it, and\n\t       without setting flavor to ef_free, might re-run this destructor\n\t       which could result in undefined behaviour.  Therefore we must\n\t       set flavor to ef_free to avoid calling this destructor again.\n\t       Note that the concurrent exit must also take the dynamic loader\n\t       lock (for library finalizer processing) and therefore will\n\t       block while dlclose completes the processing of any in-progress\n\t       exit functions. Lastly, once we release the list lock for the\n\t       entry marked ef_free, we must not read from that entry again\n\t       since it may have been reused by the time we take the list lock\n\t       again.  Lastly the detection of new registered exit functions is\n\t       based on a monotonically incrementing counter, and there is an\n\t       ABA if between the unlock to run the exit function and the\n\t       re-lock after completion the user registers 2^64 exit functions,\n\t       the implementation will not detect this and continue without\n\t       executing any more functions.\n\n\t       One minor issue remains: A registered exit function that is in\n\t       progress by a call to dlclose() may not completely finish before\n\t       the next registered exit function is run. This may, according to\n\t       some readings of POSIX violate the requirement that functions\n\t       run in effective LIFO order.  This should probably be fixed in a\n\t       future implementation to ensure the functions do not run in\n\t       parallel.  */\n\t    f->flavor = ef_free;\n\n\t    PTR_DEMANGLE (cxafn);\n\n\t    /* Unlock the list while we call a foreign function.  */\n\t    __libc_lock_unlock (__exit_funcs_lock);\n\t    cxafn (cxaarg, 0);\n\t    __libc_lock_lock (__exit_funcs_lock);\n\n\t    /* It is possible that that last exit function registered\n\t       more exit functions.  Start the loop over.  */\n\t    if (__glibc_unlikely (check != __new_exitfn_called))\n\t      goto restart;\n\t  }\n    }\n\n  /* Also remove the quick_exit handlers, but do not call them.  */\n  for (funcs = __quick_exit_funcs; funcs; funcs = funcs->next)\n    {\n      struct exit_function *f;\n\n      for (f = &funcs->fns[funcs->idx - 1]; f >= &funcs->fns[0]; --f)\n\tif (d == NULL || d == f->func.cxa.dso_handle)\n\t  f->flavor = ef_free;\n    }\n\n  /* Remove the registered fork handlers.  We do not have to\n     unregister anything if the program is going to terminate anyway.  */\n  if (d != NULL)\n    UNREGISTER_ATFORK (d);\n  __libc_lock_unlock (__exit_funcs_lock);\n}",
    "__cxa_thread_atexit_impl": "__cxa_thread_atexit_impl (dtor_func func, void *obj, void *dso_symbol){\n  PTR_MANGLE (func);\n\n  /* Prepend.  */\n  struct dtor_list *new = calloc (1, sizeof (struct dtor_list));\n  if (__glibc_unlikely (new == NULL))\n    __libc_fatal (\"Fatal glibc error: failed to register TLS destructor: \"\n\t\t  \"out of memory\\n\");\n  new->func = func;\n  new->obj = obj;\n  new->next = tls_dtor_list;\n  tls_dtor_list = new;\n\n  /* We have to acquire the big lock to prevent a racing dlclose from pulling\n     our DSO from underneath us while we're setting up our destructor.  */\n  __rtld_lock_lock_recursive (GL(dl_load_lock));\n\n  /* See if we already encountered the DSO.  */\n  if (__glibc_unlikely (dso_symbol_cache != dso_symbol))\n    {\n      ElfW(Addr) caller = (ElfW(Addr)) dso_symbol;\n\n      struct link_map *l = _dl_find_dso_for_object (caller);\n\n      /* If the address is not recognized the call comes from the main\n\t program (we hope).  */\n      lm_cache = l ? l : GL(dl_ns)[LM_ID_BASE]._ns_loaded;\n    }\n\n  /* This increment may only be concurrently observed either by the decrement\n     in __call_tls_dtors since the other l_tls_dtor_count access in\n     _dl_close_worker is protected by the dl_load_lock.  The execution in\n     __call_tls_dtors does not really depend on this value beyond the fact that\n     it should be atomic, so Relaxed MO should be sufficient.  */\n  atomic_fetch_add_relaxed (&lm_cache->l_tls_dtor_count, 1);\n  __rtld_lock_unlock_recursive (GL(dl_load_lock));\n\n  new->map = lm_cache;\n\n  return 0;\n}",
    "__call_tls_dtors": "__call_tls_dtors (void){\n  while (tls_dtor_list)\n    {\n      struct dtor_list *cur = tls_dtor_list;\n      dtor_func func = cur->func;\n      PTR_DEMANGLE (func);\n\n      tls_dtor_list = tls_dtor_list->next;\n      func (cur->obj);\n\n      /* Ensure that the MAP dereference happens before\n\t l_tls_dtor_count decrement.  That way, we protect this access from a\n\t potential DSO unload in _dl_close_worker, which happens when\n\t l_tls_dtor_count is 0.  See CONCURRENCY NOTES for more detail.  */\n      atomic_fetch_add_release (&cur->map->l_tls_dtor_count, -1);\n      free (cur);\n    }\n}",
    "div": "div (int numer, int denom){\n  div_t result;\n\n  result.quot = numer / denom;\n  result.rem = numer % denom;\n\n  return result;\n}",
    "drand48": "drand48 (void){\n  double result;\n\n  (void) __erand48_r (__libc_drand48_data.__x, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "drand48_r": "drand48_r (struct drand48_data *buffer, double *result){\n  return __erand48_r (buffer->__x, buffer, result);\n}",
    "erand48": "erand48 (unsigned short int xsubi[3]){\n  double result;\n\n  (void) __erand48_r (xsubi, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "exit": "exit (int status){\n  __run_exit_handlers (status, &__exit_funcs, true, true);\n}",
    "fmtmsg": "fmtmsg (long int classification, const char *label, int severity,\n\tconst char *text, const char *action, const char *tag){\n  __libc_once_define (static, once);\n  struct severity_info *severity_rec;\n\n  /* Make sure everything is initialized.  */\n  __libc_once (once, init);\n\n  /* Start the real work.  First check whether the input is ok.  */\n  if (label != MM_NULLLBL)\n    {\n      /* Must be two fields, separated by a colon.  */\n      const char *cp = strchr (label, ':');\n      if (cp == NULL)\n\treturn MM_NOTOK;\n\n      /* The first field must not contain more than 10 bytes.  */\n      if (cp - label > 10\n\t  /* The second field must not have more than 14 bytes.  */\n\t  || strlen (cp + 1) > 14)\n\treturn MM_NOTOK;\n    }\n\n  /* We do not want this call to be cut short by a thread\n     cancellation.  Therefore disable cancellation for now.  */\n  int state = PTHREAD_CANCEL_ENABLE;\n  __pthread_setcancelstate (PTHREAD_CANCEL_DISABLE, &state);\n\n  __libc_lock_lock (lock);\n\n  for (severity_rec = severity_list; severity_rec != NULL;\n       severity_rec = severity_rec->next)\n    if (severity == severity_rec->severity)\n      /* Bingo.  */\n      break;\n\n  /* If we don't know anything about the severity level return an error.  */\n  int result = MM_NOTOK;\n  if (severity_rec != NULL)\n    {\n      result = MM_OK;\n\n      /* Now we can print.  */\n      if (classification & MM_PRINT)\n\t{\n\t  int do_label = (print & label_mask) && label != MM_NULLLBL;\n\t  int do_severity = (print & severity_mask) && severity != MM_NULLSEV;\n\t  int do_text = (print & text_mask) && text != MM_NULLTXT;\n\t  int do_action = (print & action_mask) && action != MM_NULLACT;\n\t  int do_tag = (print & tag_mask) && tag != MM_NULLTAG;\n\t  int need_colon = (do_label\n\t\t\t    && (do_severity | do_text | do_action | do_tag));\n\n\t  if (__fxprintf (stderr, \"%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\t\t  do_label ? label : \"\",\n\t\t\t  need_colon ? \": \" : \"\",\n\t\t\t  do_severity ? severity_rec->string : \"\",\n\t\t\t  do_severity && (do_text | do_action | do_tag)\n\t\t\t  ? \": \" : \"\",\n\t\t\t  do_text ? text : \"\",\n\t\t\t  do_text && (do_action | do_tag) ? \"\\n\" : \"\",\n\t\t\t  do_action ? \"TO FIX: \" : \"\",\n\t\t\t  do_action ? action : \"\",\n\t\t\t  do_action && do_tag ? \"  \" : \"\",\n\t\t\t  do_tag ? tag : \"\") < 0)\n\t    /* Oh, oh.  An error occurred during the output.  */\n\t    result = MM_NOMSG;\n\t}\n\n      if (classification & MM_CONSOLE)\n\t{\n\t  int do_label = label != MM_NULLLBL;\n\t  int do_severity = severity != MM_NULLSEV;\n\t  int do_text = text != MM_NULLTXT;\n\t  int do_action = action != MM_NULLACT;\n\t  int do_tag = tag != MM_NULLTAG;\n\t  int need_colon = (do_label\n\t\t\t    && (do_severity | do_text | do_action | do_tag));\n\n\t  syslog (LOG_ERR, \"%s%s%s%s%s%s%s%s%s%s\\n\",\n\t\t  do_label ? label : \"\",\n\t\t  need_colon ? \": \" : \"\",\n\t\t  do_severity ? severity_rec->string : \"\",\n\t\t  do_severity && (do_text | do_action | do_tag) ? \": \" : \"\",\n\t\t  do_text ? text : \"\",\n\t\t  do_text && (do_action | do_tag) ? \"\\n\" : \"\",\n\t\t  do_action ? \"TO FIX: \" : \"\",\n\t\t  do_action ? action : \"\",\n\t\t  do_action && do_tag ? \"  \" : \"\",\n\t\t  do_tag ? tag : \"\");\n\t}\n    }\n\n  __libc_lock_unlock (lock);\n\n  __pthread_setcancelstate (state, NULL);\n\n  return result;\n}",
    "getcontext": "getcontext (ucontext_t *ucp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "getentropy": "getentropy (void *buffer, size_t length){\n  /* The interface is documented to return EIO for buffer lengths\n     longer than 256 bytes.  */\n  if (length > 256)\n    {\n      __set_errno (EIO);\n      return -1;\n    }\n\n  /* Try to fill the buffer completely.  Even with the 256 byte limit\n     above, we might still receive an EINTR error (when blocking\n     during boot).  */\n  void *end = buffer + length;\n  while (buffer < end)\n    {\n      /* NB: No cancellation point.  */\n      ssize_t bytes = INLINE_SYSCALL_CALL (getrandom, buffer, end - buffer, 0);\n      if (bytes < 0)\n        {\n          if (errno == EINTR)\n            /* Try again if interrupted by a signal.  */\n            continue;\n          else\n            return -1;\n        }\n      if (bytes == 0)\n        {\n          /* No more bytes available.  This should not happen under\n             normal circumstances.  */\n          __set_errno (EIO);\n          return -1;\n        }\n      /* Try again in case of a short read.  */\n      buffer += bytes;\n    }\n  return 0;\n}",
    "getenv": "*\ngetenv (const char *name){\n  if (__environ == NULL || name[0] == '\\0')\n    return NULL;\n\n  size_t len = strlen (name);\n  for (char **ep = __environ; *ep != NULL; ++ep)\n    {\n      if (name[0] == (*ep)[0]\n\t  && strncmp (name, *ep, len) == 0 && (*ep)[len] == '=')\n\treturn *ep + len + 1;\n    }\n\n  return NULL;\n}",
    "getsubopt": "getsubopt (char **optionp, char *const *tokens, char **valuep){\n  char *endp, *vstart;\n  int cnt;\n\n  if (**optionp == '\\0')\n    return -1;\n\n  /* Find end of next token.  */\n  endp = __strchrnul (*optionp, ',');\n\n  /* Find start of value.  */\n  vstart = memchr (*optionp, '=', endp - *optionp);\n  if (vstart == NULL)\n    vstart = endp;\n\n  /* Try to match the characters between *OPTIONP and VSTART against\n     one of the TOKENS.  */\n  for (cnt = 0; tokens[cnt] != NULL; ++cnt)\n    if (strncmp (*optionp, tokens[cnt], vstart - *optionp) == 0\n\t&& tokens[cnt][vstart - *optionp] == '\\0')\n      {\n\t/* We found the current option in TOKENS.  */\n\t*valuep = vstart != endp ? vstart + 1 : NULL;\n\n\tif (*endp != '\\0')\n\t  *endp++ = '\\0';\n\t*optionp = endp;\n\n\treturn cnt;\n      }\n\n  /* The current suboption does not match any option.  */\n  *valuep = *optionp;\n\n  if (*endp != '\\0')\n    *endp++ = '\\0';\n  *optionp = endp;\n\n  return -1;\n}",
    "jrand48": "jrand48 (unsigned short int xsubi[3]){\n  long int result;\n\n  (void) __jrand48_r (xsubi, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "l64a": "*\nl64a (long int n){\n  unsigned long int m = (unsigned long int) n;\n  static char result[7];\n  int cnt;\n\n  /* The standard says that only 32 bits are used.  */\n  m &= 0xffffffff;\n\n  if (m == 0ul)\n    /* The value for N == 0 is defined to be the empty string. */\n    return (char *) \"\";\n\n  for (cnt = 0; m > 0ul; ++cnt)\n    {\n      result[cnt] = conv_table[m & 0x3f];\n      m >>= 6;\n    }\n  result[cnt] = '\\0';\n\n  return result;\n}",
    "labs": "labs (long int i){\n  return i < 0 ? -i : i;\n}",
    "lcong48": "lcong48 (unsigned short int param[7]){\n  (void) __lcong48_r (param, &__libc_drand48_data);\n}",
    "ldiv": "ldiv (long int numer, long int denom){\n  ldiv_t result;\n\n  result.quot = numer / denom;\n  result.rem = numer % denom;\n\n  return result;\n}",
    "llabs": "llabs (long long int i){\n  return i < 0 ? -i : i;\n}",
    "lldiv": "lldiv (long long int numer, long long int denom){\n  lldiv_t result;\n\n  result.quot = numer / denom;\n  result.rem = numer % denom;\n\n  return result;\n}",
    "lrand48": "lrand48 (void){\n  long int result;\n\n  (void) __nrand48_r (__libc_drand48_data.__x, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "lrand48_r": "lrand48_r (struct drand48_data *buffer, long int *result){\n  /* Be generous for the arguments, detect some errors.  */\n  if (buffer == NULL)\n   return -1;\n\n  return __nrand48_r (buffer->__x, buffer, result);\n}",
    "makecontext": "makecontext (ucontext_t *ucp, void (*func) (void), int argc, ...){\n  __set_errno (ENOSYS);\n}",
    "mblen": "mblen (const char *s, size_t n){\n  int result;\n\n  /* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */\n  if (s == NULL)\n    {\n      const struct gconv_fcts *fcts;\n\n      /* Get the conversion functions.  */\n      fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n      /* Reset the state.  */\n      memset (&state, '\\0', sizeof state);\n\n      result = fcts->towc->__stateful;\n    }\n  else if (*s == '\\0')\n    /* According to the ISO C 89 standard this is the expected behaviour.  */\n    result = 0;\n  else\n    {\n      memset (&state, '\\0', sizeof state);\n\n      result = __mbrtowc (NULL, s, n, &state);\n\n      /* The `mbrtowc' functions tell us more than we need.  Fold the -1\n\t and -2 result into -1.  */\n      if (result < 0)\n\tresult = -1;\n    }\n\n  return result;\n}",
    "mbstowcs": "mbstowcs (wchar_t *pwcs, const char *s, size_t n){\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n  /* Return how many we wrote (or maybe an error).  */\n  return __mbsrtowcs (pwcs, &s, n, &state);\n}",
    "mbtowc": "mbtowc (wchar_t *pwc, const char *s, size_t n){\n  int result;\n  static mbstate_t state;\n\n  /* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */\n  if (s == NULL)\n    {\n      const struct gconv_fcts *fcts;\n\n      /* Get the conversion functions.  */\n      fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n      /* This is an extension in the Unix standard which does not directly\n\t violate ISO C.  */\n      memset (&state, '\\0', sizeof state);\n\n      result = fcts->towc->__stateful;\n    }\n  else if (*s == '\\0')\n    {\n      if (pwc != NULL)\n\t*pwc = L'\\0';\n      result = 0;\n    }\n  else\n    {\n      result = __mbrtowc (pwc, s, n, &state);\n\n      /* The `mbrtowc' functions tell us more than we need.  Fold the -1\n\t and -2 result into -1.  */\n      if (result < 0)\n\tresult = -1;\n    }\n\n  return result;\n}",
    "mrand48": "mrand48 (void){\n  long int result;\n\n  (void) __jrand48_r (__libc_drand48_data.__x, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "mrand48_r": "mrand48_r (struct drand48_data *buffer, long int *result){\n  /* Be generous for the arguments, detect some errors.  */\n  if (buffer == NULL)\n   return -1;\n\n  return __jrand48_r (buffer->__x, buffer, result);\n}",
    "nrand48": "nrand48 (unsigned short int xsubi[3]){\n  long int result;\n\n  (void) __nrand48_r (xsubi, &__libc_drand48_data, &result);\n\n  return result;\n}",
    "putenv": "putenv (char *string){\n  const char *const name_end = strchr (string, '=');\n\n  if (name_end != NULL)\n    {\n      char *name;\n#ifdef _LIBC\n      int use_malloc = !__libc_use_alloca (name_end - string + 1);\n      if (__builtin_expect (use_malloc, 0))\n\t{\n\t  name = __strndup (string, name_end - string);\n\t  if (name == NULL)\n\t    return -1;\n\t}\n      else\n\tname = strndupa (string, name_end - string);\n#else\n# define use_malloc 1\n      name = malloc (name_end - string + 1);\n      if (name == NULL)\n\treturn -1;\n      memcpy (name, string, name_end - string);\n      name[name_end - string] = '\\0';\n#endif\n      int result = __add_to_environ (name, NULL, string, 1);\n\n      if (__glibc_unlikely (use_malloc))\n\tfree (name);\n\n      return result;\n    }\n\n  __unsetenv (string);\n  return 0;\n}",
    "qsort": "void\nqsort (void *b, size_t n, size_t s, __compar_fn_t cmp){\n  return __qsort_r (b, n, s, (__compar_d_fn_t) cmp, NULL);\n}",
    "rand": "rand (void){\n  return (int) __random ();\n}",
    "rand_r": "rand_r (unsigned int *seed){\n  unsigned int next = *seed;\n  int result;\n\n  next *= 1103515245;\n  next += 12345;\n  result = (unsigned int) (next / 65536) % 2048;\n\n  next *= 1103515245;\n  next += 12345;\n  result <<= 10;\n  result ^= (unsigned int) (next / 65536) % 1024;\n\n  next *= 1103515245;\n  next += 12345;\n  result <<= 10;\n  result ^= (unsigned int) (next / 65536) % 1024;\n\n  *seed = next;\n\n  return result;\n}",
    "rpmatch": "rpmatch (const char *response){\n  /* We cache the response patterns and compiled regexps here.  */\n  static const char *yesexpr, *noexpr;\n  static regex_t yesre, nore;\n\n  return (try (response, YESEXPR, 1, 0, &yesexpr, &yesre) ?:\n\t  try (response, NOEXPR, 0, -1, &noexpr, &nore));\n}",
    "__libc_secure_getenv": "*\n__libc_secure_getenv (const char *name){\n  return __libc_enable_secure ? NULL : getenv (name);\n}",
    "seed48": "*\nseed48 (unsigned short int seed16v[3]){\n  (void) __seed48_r (seed16v, &__libc_drand48_data);\n\n  return __libc_drand48_data.__old_x;\n}",
    "setcontext": "setcontext (const ucontext_t *ucp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "setenv": "setenv (const char *name, const char *value, int replace){\n  if (name == NULL || *name == '\\0' || strchr (name, '=') != NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return __add_to_environ (name, value, NULL, replace);\n}",
    "clearenv": "clearenv (void){\n  LOCK;\n\n  if (__environ == last_environ && __environ != NULL)\n    {\n      /* We allocated this environment so we can free it.  */\n      free (__environ);\n      last_environ = NULL;\n    }\n\n  /* Clear the environment pointer removes the whole environment.  */\n  __environ = NULL;\n\n  UNLOCK;\n\n  return 0;\n}",
    "srand48": "srand48 (long seedval){\n  (void) __srand48_r (seedval, &__libc_drand48_data);\n}",
    "__isoc23_strtol": "__isoc23_strtol (const STRING_TYPE *nptr, STRING_TYPE **endptr, int base){\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, true,\n\t\t\t\t_NL_CURRENT_LOCALE);\n}",
    "__strtol_l": "__strtol_l (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t    int base, locale_t loc){\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, false, loc);\n}",
    "__isoc23_strtol_l": "INT\n__isoc23_strtol_l (const STRING_TYPE *nptr, STRING_TYPE **endptr,\n\t\t   int base, locale_t loc){\n  return INTERNAL (__strtol_l) (nptr, endptr, base, 0, true, loc);\n}",
    "swapcontext": "swapcontext (ucontext_t *oucp, const ucontext_t *ucp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_system": "__libc_system (const char *line){\n  if (line == NULL)\n    /* Check that we have a command processor available.  It might\n       not be available after a chroot(), for example.  */\n    return do_system (\"exit 0\") == 0;\n\n  return do_system (line);\n}",
    "wcstombs": "wcstombs (char *s, const wchar_t *pwcs, size_t n){\n  mbstate_t state;\n\n  memset (&state, '\\0', sizeof state);\n\n  /* Return how many we wrote (or maybe an error).  */\n  return __wcsrtombs (s, &pwcs, n, &state);\n}",
    "wctomb": "wctomb (char *s, wchar_t wchar){\n  /* If S is NULL the function has to return null or not null\n     depending on the encoding having a state depending encoding or\n     not.  */\n  if (s == NULL)\n    {\n      const struct gconv_fcts *fcts;\n\n      /* Get the conversion functions.  */\n      fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n      /* This is an extension in the Unix standard which does not directly\n\t violate ISO C.  */\n      memset (&__wctomb_state, '\\0', sizeof __wctomb_state);\n\n      return fcts->tomb->__stateful;\n    }\n\n  return __wcrtomb (s, wchar, &__wctomb_state);\n}",
    "__xpg_basename": "*\n__xpg_basename (char *filename){\n  char *p;\n\n  if (filename == NULL || filename[0] == '\\0')\n    /* We return a pointer to a static string containing \".\".  */\n    p = (char *) \".\";\n  else\n    {\n      p = strrchr (filename, '/');\n\n      if (p == NULL)\n\t/* There is no slash in the filename.  Return the whole string.  */\n\tp = filename;\n      else\n\t{\n\t  if (p[1] == '\\0')\n\t    {\n\t      /* We must remove trailing '/'.  */\n\t      while (p > filename && p[-1] == '/')\n\t\t--p;\n\n\t      /* Now we can be in two situations:\n\t\t a) the string only contains '/' characters, so we return\n\t\t    '/'\n\t\t b) p points past the last component, but we have to remove\n\t\t    the trailing slash.  */\n\t      if (p > filename)\n\t\t{\n\t\t  *p-- = '\\0';\n\t\t  while (p > filename && p[-1] != '/')\n\t\t    --p;\n\t\t}\n\t      else\n\t\t/* The last slash we already found is the right position\n\t\t   to return.  */\n\t\twhile (p[1] != '\\0')\n\t\t  ++p;\n\t    }\n\t  else\n\t    /* Go to the first character of the name.  */\n\t    ++p;\n\t}\n    }\n\n  return p;\n}",
    "__argz_count": "__argz_count (const char *argz, size_t len){\n  size_t count = 0;\n  while (len > 0)\n    {\n      size_t part_len = strlen(argz);\n      argz += part_len + 1;\n      len -= part_len + 1;\n      count++;\n    }\n  return count;\n}",
    "argz_delete": "argz_delete (char **argz, size_t *argz_len, char *entry){\n  if (entry)\n    /* Get rid of the old value for NAME.  */\n    {\n      size_t entry_len = strlen (entry) + 1;\n      *argz_len -= entry_len;\n      memmove (entry, entry + entry_len, *argz_len - (entry - *argz));\n      if (*argz_len == 0)\n\t{\n\t  free (*argz);\n\t  *argz = 0;\n\t}\n    }\n}",
    "__argz_next": "*\n__argz_next (const char *argz, size_t argz_len, const char *entry){\n  if (entry)\n    {\n      if (entry < argz + argz_len)\n\tentry = strchr (entry, '\\0') + 1;\n\n      return entry >= argz + argz_len ? NULL : (char *) entry;\n    }\n  else\n    if (argz_len > 0)\n      return (char *) argz;\n    else\n      return NULL;\n}",
    "__argz_stringify": "__argz_stringify (char *argz, size_t len, int sep){\n  if (len > 0)\n    while (1)\n      {\n\tsize_t part_len = __strnlen (argz, len);\n\targz += part_len;\n\tlen -= part_len;\n\tif (len-- <= 1)\t\t/* includes final '\\0' we want to stop at */\n\t  break;\n\t*argz++ = sep;\n      }\n}",
    "bcopy": "bcopy (const void *src, void *dest, size_t len){\n  memmove (dest, src, len);\n}",
    "__bzero": "__bzero (void *s, size_t len){\n  memset (s, '\\0', len);\n}",
    "envz_entry": "*\nenvz_entry (const char *envz, size_t envz_len, const char *name){\n  while (envz_len)\n    {\n      const char *p = name;\n      const char *entry = envz;\t/* Start of this entry. */\n\n      /* See how far NAME and ENTRY match.  */\n      while (envz_len && *p == *envz && *p && *p != SEP)\n\tp++, envz++, envz_len--;\n\n      if ((*envz == '\\0' || *envz == SEP) && (*p == '\\0' || *p == SEP))\n\t/* Bingo! */\n\treturn (char *) entry;\n\n      /* No match, skip to the next entry.  */\n      while (envz_len && *envz)\n\tenvz++, envz_len--;\n      if (envz_len)\n\tenvz++, envz_len--;\t/* skip '\\0' */\n    }\n\n  return 0;\n}",
    "envz_get": "*\nenvz_get (const char *envz, size_t envz_len, const char *name){\n  char *entry = envz_entry (envz, envz_len, name);\n  if (entry)\n    {\n      while (*entry && *entry != SEP)\n\tentry++;\n      if (*entry)\n\tentry++;\n      else\n\tentry = 0;\t\t/* A null entry.  */\n    }\n  return entry;\n}",
    "envz_remove": "envz_remove (char **envz, size_t *envz_len, const char *name){\n  char *entry = envz_entry (*envz, *envz_len, name);\n  if (entry)\n    argz_delete (envz, envz_len, entry);\n}",
    "envz_add": "envz_add (char **envz, size_t *envz_len, const char *name, const char *value){\n  envz_remove (envz, envz_len, name);\n\n  if (value)\n    /* Add the new value, if there is one.  */\n    {\n      size_t name_len = strlen (name);\n      size_t value_len = strlen (value);\n      size_t old_envz_len = *envz_len;\n      size_t new_envz_len = old_envz_len + name_len + 1 + value_len + 1;\n      char *new_envz = realloc (*envz, new_envz_len);\n\n      if (new_envz)\n\t{\n\t  memcpy (new_envz + old_envz_len, name, name_len);\n\t  new_envz[old_envz_len + name_len] = SEP;\n\t  memcpy (new_envz + old_envz_len + name_len + 1, value, value_len);\n\t  new_envz[new_envz_len - 1] = 0;\n\n\t  *envz = new_envz;\n\t  *envz_len = new_envz_len;\n\n\t  return 0;\n\t}\n      else\n\treturn ENOMEM;\n    }\n  else\n    /* Add a null entry.  */\n    return __argz_add (envz, envz_len, name);\n}",
    "envz_merge": "envz_merge (char **envz, size_t *envz_len, const char *envz2,\n\t    size_t envz2_len, int override){\n  error_t err = 0;\n\n  while (envz2_len && ! err)\n    {\n      char *old = envz_entry (*envz, *envz_len, envz2);\n      size_t new_len = strlen (envz2) + 1;\n\n      if (! old)\n\terr = __argz_append (envz, envz_len, envz2, new_len);\n      else if (override)\n\t{\n\t  argz_delete (envz, envz_len, old);\n\t  err = __argz_append (envz, envz_len, envz2, new_len);\n\t}\n\n      envz2 += new_len;\n      envz2_len -= new_len;\n    }\n\n  return err;\n}",
    "envz_strip": "envz_strip (char **envz, size_t *envz_len){\n  char *entry = *envz;\n  size_t left = *envz_len;\n  while (left)\n    {\n      size_t entry_len = strlen (entry) + 1;\n      left -= entry_len;\n      if (! strchr (entry, SEP))\n\t/* Null entry. */\n\tmemmove (entry, entry + entry_len, left);\n      else\n\tentry += entry_len;\n    }\n  *envz_len = entry - *envz;\n}",
    "explicit_bzero": "explicit_bzero (void *s, size_t len){\n  memset (s, '\\0', len);\n  /* Compiler barrier.  */\n  asm volatile (\"\" ::: \"memory\");\n}",
    "__ffs": "__ffs (int x){\n  int cnt;\n  int tmp;\n\n  asm (\"bsfl %2,%0\\n\"\t\t/* Count low bits in X and store in %1.  */\n       \"cmovel %1,%0\\n\"\t\t/* If number was zero, use -1 as result.  */\n       : \"=&r\" (cnt), \"=r\" (tmp) : \"rm\" (x), \"1\" (-1));\n\n  return cnt + 1;\n}",
    "ffsll": "ffsll (long long int x){\n  long long int cnt;\n  long long int tmp;\n\n  asm (\"bsfq %2,%0\\n\"\t\t/* Count low bits in X and store in %1.  */\n       \"cmoveq %1,%0\\n\"\t\t/* If number was zero, use -1 as result.  */\n       : \"=&r\" (cnt), \"=r\" (tmp) : \"rm\" (x), \"1\" (-1));\n\n  return cnt + 1;\n}",
    "memfrob": "*\nmemfrob (void *s, size_t n){\n  char *p = (char *) s;\n\n  while (n-- > 0)\n    *p++ ^= 42;\n\n  return s;\n}",
    "sigabbrev_np": "*\nsigabbrev_np (int signum){\n  const char *abbrev = NULL;\n\n  if (signum >= 0 && signum <= NSIG\n      && signum < array_length (__sys_sigabbrev))\n    abbrev = __sys_sigabbrev[signum];\n\n  return abbrev;\n}",
    "__strcasecmp": "__strcasecmp (const char *s1, const char *s2 LOCALE_PARAM){\n#if defined _LIBC && !defined USE_IN_EXTENDED_LOCALE_MODEL\n  locale_t loc = _NL_CURRENT_LOCALE;\n#endif\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n  int result;\n\n  if (p1 == p2)\n    return 0;\n\n  while ((result = TOLOWER (*p1) - TOLOWER (*p2++)) == 0)\n    if (*p1++ == '\\0')\n      break;\n\n  return result;\n}",
    "strchr": "*\nstrchr (const char *s, int c_in){\n  char *r = __strchrnul (s, c_in);\n  return (*(unsigned char *)r == (unsigned char)c_in) ? r : NULL;\n}",
    "strcmp": "strcmp (const char *p1, const char *p2){\n  /* Handle the unaligned bytes of p1 first.  */\n  uintptr_t n = -(uintptr_t)p1 % sizeof(op_t);\n  for (int i = 0; i < n; ++i)\n    {\n      unsigned char c1 = *p1++;\n      unsigned char c2 = *p2++;\n      int diff = c1 - c2;\n      if (c1 == '\\0' || diff != 0)\n\treturn diff;\n    }\n\n  /* P1 is now aligned to op_t.  P2 may or may not be.  */\n  const op_t *x1 = (const op_t *) p1;\n  op_t w1 = *x1++;\n  uintptr_t ofs = (uintptr_t) p2 % sizeof(op_t);\n  return ofs == 0\n    ? strcmp_aligned_loop (x1, (const op_t *)p2, w1)\n    : strcmp_unaligned_loop (x1, (const op_t *)(p2 - ofs), w1, ofs);\n}",
    "__strdup": "*\n__strdup (const char *s){\n  size_t len = strlen (s) + 1;\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (char *) memcpy (new, s, len);\n}",
    "strerror": "*\nstrerror (int errnum){\n  return __strerror_l (errnum, __libc_tsd_get (locale_t, LOCALE));\n}",
    "strerrorname_np": "*\nstrerrorname_np (int errnum){\n  return __get_errname (errnum);\n}",
    "strfry": "*\nstrfry (char *string){\n  static int init;\n  static struct random_data rdata;\n\n  if (!init)\n    {\n      static char state[32];\n      rdata.state = NULL;\n      __initstate_r (random_bits (),\n\t\t     state, sizeof (state), &rdata);\n      init = 1;\n    }\n\n  size_t len = strlen (string);\n  if (len > 0)\n    for (size_t i = 0; i < len - 1; ++i)\n      {\n\tint32_t j;\n\t__random_r (&rdata, &j);\n\tj = j % (len - i) + i;\n\n\tchar c = string[i];\n\tstring[i] = string[j];\n\tstring[j] = c;\n      }\n\n  return string;\n}",
    "__strndup": "*\n__strndup (const char *s, size_t n){\n  size_t len = __strnlen (s, n);\n  char *new = (char *) malloc (len + 1);\n\n  if (new == NULL)\n    return NULL;\n\n  new[len] = '\\0';\n  return (char *) memcpy (new, s, len);\n}",
    "strsignal": "*\nstrsignal (int signum){\n  const char *desc = __sigdescr_np (signum);\n  if (desc != NULL)\n    return _(desc);\n\n  struct tls_internal_t *tls_internal = __glibc_tls_internal ();\n  free (tls_internal->strsignal_buf);\n\n  int r;\n#ifdef SIGRTMIN\n  if (signum >= SIGRTMIN && signum <= SIGRTMAX)\n    r = __asprintf (&tls_internal->strsignal_buf, _(\"Real-time signal %d\"),\n\t\t    signum - SIGRTMIN);\n  else\n#endif\n    r = __asprintf (&tls_internal->strsignal_buf, _(\"Unknown signal %d\"),\n\t\t    signum);\n\n  if (r == -1)\n    tls_internal->strsignal_buf = NULL;\n\n  return tls_internal->strsignal_buf;\n}",
    "strtok": "*\nstrtok (char *s, const char *delim){\n  static char *olds;\n  return __strtok_r (s, delim, &olds);\n}",
    "__strtok_r": "*\n__strtok_r (char *s, const char *delim, char **save_ptr){\n  char *end;\n\n  if (s == NULL)\n    s = *save_ptr;\n\n  if (*s == '\\0')\n    {\n      *save_ptr = s;\n      return NULL;\n    }\n\n  /* Scan leading delimiters.  */\n  s += strspn (s, delim);\n  if (*s == '\\0')\n    {\n      *save_ptr = s;\n      return NULL;\n    }\n\n  /* Find the end of the token.  */\n  end = s + strcspn (s, delim);\n  if (*end == '\\0')\n    {\n      *save_ptr = end;\n      return s;\n    }\n\n  /* Terminate the token and make *SAVE_PTR point past it.  */\n  *end = '\\0';\n  *save_ptr = end + 1;\n  return s;\n}",
    "__strverscmp": "__strverscmp (const char *s1, const char *s2){\n  const unsigned char *p1 = (const unsigned char *) s1;\n  const unsigned char *p2 = (const unsigned char *) s2;\n\n  /* Symbol(s)    0       [1-9]   others\n     Transition   (10) 0  (01) d  (00) x   */\n  static const uint8_t next_state[] =\n  {\n      /* state    x    d    0  */\n      /* S_N */  S_N, S_I, S_Z,\n      /* S_I */  S_N, S_I, S_I,\n      /* S_F */  S_N, S_F, S_F,\n      /* S_Z */  S_N, S_F, S_Z\n  };\n\n  static const int8_t result_type[] =\n  {\n      /* state   x/x  x/d  x/0  d/x  d/d  d/0  0/x  0/d  0/0  */\n\n      /* S_N */  CMP, CMP, CMP, CMP, LEN, CMP, CMP, CMP, CMP,\n      /* S_I */  CMP, -1,  -1,  +1,  LEN, LEN, +1,  LEN, LEN,\n      /* S_F */  CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP, CMP,\n      /* S_Z */  CMP, +1,  +1,  -1,  CMP, CMP, -1,  CMP, CMP\n  };\n\n  if (p1 == p2)\n    return 0;\n\n  unsigned char c1 = *p1++;\n  unsigned char c2 = *p2++;\n  /* Hint: '0' is a digit too.  */\n  int state = S_N + ((c1 == '0') + (isdigit (c1) != 0));\n\n  int diff;\n  while ((diff = c1 - c2) == 0)\n    {\n      if (c1 == '\\0')\n\treturn diff;\n\n      state = next_state[state];\n      c1 = *p1++;\n      c2 = *p2++;\n      state += (c1 == '0') + (isdigit (c1) != 0);\n    }\n\n  state = result_type[state * 3 + (((c2 == '0') + (isdigit (c2) != 0)))];\n\n  switch (state)\n  {\n    case CMP:\n      return diff;\n\n    case LEN:\n      while (isdigit (*p1++))\n\tif (!isdigit (*p2++))\n\t  return 1;\n\n      return isdigit (*p2) ? -1 : diff;\n\n    default:\n      return state;\n  }\n}",
    "swab": "swab (const void *bfrom, void *bto, ssize_t n){\n  const char *from = (const char *) bfrom;\n  char *to = (char *) bto;\n\n  n &= ~((ssize_t) 1);\n  while (n > 1)\n    {\n      const char b0 = from[--n], b1 = from[--n];\n      to[n] = b0;\n      to[n + 1] = b1;\n    }\n}",
    "__xpg_strerror_r": "__xpg_strerror_r (int errnum, char *buf, size_t buflen){\n  int system;\n  int sub;\n  int code;\n  const struct error_system *es;\n  extern void __mach_error_map_compat (int *);\n  const char *estr;\n\n  __mach_error_map_compat (&errnum);\n\n  system = err_get_system (errnum);\n  sub = err_get_sub (errnum);\n  code = err_get_code (errnum);\n\n  if (system > err_max_system || ! __mach_error_systems[system].bad_sub)\n    {\n      __snprintf (buf, buflen, \"%s%X\", _(\"Error in unknown error system: \"),\n\t\t  errnum);\n      return EINVAL;\n    }\n\n  es = &__mach_error_systems[system];\n\n  if (sub >= es->max_sub)\n    estr = (const char *) es->bad_sub;\n  else if (code >= es->subsystem[sub].max_code)\n    return EINVAL;\n  else\n    estr = (const char *) _(es->subsystem[sub].codes[code]);\n\n  size_t estrlen = strlen (estr);\n\n  /* Terminate the string in any case.  */\n  if (buflen > 0)\n    *((char *) __mempcpy (buf, estr, MIN (buflen - 1, estrlen))) = '\\0';\n\n  return buflen <= estrlen ? ERANGE : 0;\n}",
    "authdes_pk_create": "#endif\n\nAUTH *\nauthdes_pk_create (const char *servername, netobj *pkey, u_int window,\n\t\t   struct sockaddr *syncaddr, des_block *ckey){\n  AUTH *auth;\n  struct ad_private *ad;\n  char namebuf[MAXNETNAMELEN + 1];\n\n  /*\n   * Allocate everything now\n   */\n  auth = ALLOC (AUTH);\n  ad = ALLOC (struct ad_private);\n\n  if (auth == NULL || ad == NULL)\n    {\n      debug (\"authdes_create: out of memory\");\n      goto failed;\n    }\n\n  memset (ad, 0, sizeof (struct ad_private));\n  memcpy (ad->ad_pkey, pkey->n_bytes, pkey->n_len);\n  if (!getnetname (namebuf))\n    goto failed;\n  ad->ad_fullnamelen = RNDUP (strlen (namebuf));\n  ad->ad_fullname = mem_alloc (ad->ad_fullnamelen + 1);\n\n  ad->ad_servernamelen = strlen (servername);\n  ad->ad_servername = mem_alloc (ad->ad_servernamelen + 1);\n\n  if (ad->ad_fullname == NULL || ad->ad_servername == NULL)\n    {\n      debug (\"authdes_create: out of memory\");\n      goto failed;\n    }\n\n  /*\n   * Set up private data\n   */\n  memcpy (ad->ad_fullname, namebuf, ad->ad_fullnamelen + 1);\n  memcpy (ad->ad_servername, servername, ad->ad_servernamelen + 1);\n  ad->ad_timediff.tv_sec = ad->ad_timediff.tv_usec = 0;\n  if (syncaddr != NULL)\n    {\n      ad->ad_syncaddr = *syncaddr;\n      ad->ad_dosync = TRUE;\n    }\n  else\n    ad->ad_dosync = FALSE;\n\n  ad->ad_window = window;\n  if (ckey == NULL)\n    {\n      if (key_gendes (&auth->ah_key) < 0)\n\t{\n\t  debug (\"authdes_create: unable to gen conversation key\");\n\t  goto failed;\n\t}\n    }\n  else\n    auth->ah_key = *ckey;\n\n  /*\n   * Set up auth handle\n   */\n  auth->ah_cred.oa_flavor = AUTH_DES;\n  auth->ah_verf.oa_flavor = AUTH_DES;\n  auth->ah_ops = (struct auth_ops *) &authdes_ops;\n  auth->ah_private = (caddr_t) ad;\n\n  if (!authdes_refresh (auth))\n    goto failed;\n\n  return auth;\n\nfailed:\n  if (auth != NULL)\n    FREE (auth, sizeof (AUTH));\n  if (ad != NULL)\n    {\n      if (ad->ad_fullname != NULL)\n\tFREE (ad->ad_fullname, ad->ad_fullnamelen + 1);\n      if (ad->ad_servername != NULL)\n\tFREE (ad->ad_servername, ad->ad_servernamelen + 1);\n      FREE (ad, sizeof (struct ad_private));\n    }\n  return NULL;\n}",
    "authnone_create": "*\nauthnone_create (void){\n  __libc_once (authnone_private_guard, authnone_create_once);\n  return &authnone_private.no_client;\n}",
    "authunix_create": "*\nauthunix_create (char *machname, uid_t uid, gid_t gid, int len,\n\t\t gid_t *aup_gids){\n  struct authunix_parms aup;\n  char mymem[MAX_AUTH_BYTES];\n  struct timespec now;\n  XDR xdrs;\n  AUTH *auth;\n  struct audata *au;\n\n  /*\n   * Allocate and set up auth handle\n   */\n  auth = (AUTH *) mem_alloc (sizeof (*auth));\n  au = (struct audata *) mem_alloc (sizeof (*au));\n  if (auth == NULL || au == NULL)\n    {\nno_memory:\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (auth, sizeof (*auth));\n      mem_free (au, sizeof (*au));\n      return NULL;\n    }\n  auth->ah_ops = (struct auth_ops *) &auth_unix_ops;\n  auth->ah_private = (caddr_t) au;\n  auth->ah_verf = au->au_shcred = _null_auth;\n  au->au_shfaults = 0;\n\n  /*\n   * fill in param struct from the given params\n   */\n  __clock_gettime (CLOCK_REALTIME, &now);\n  aup.aup_time = now.tv_sec;\n  aup.aup_machname = machname;\n  aup.aup_uid = uid;\n  aup.aup_gid = gid;\n  aup.aup_len = (u_int) len;\n  aup.aup_gids = aup_gids;\n\n  /*\n   * Serialize the parameters into origcred\n   */\n  xdrmem_create (&xdrs, mymem, MAX_AUTH_BYTES, XDR_ENCODE);\n  if (!xdr_authunix_parms (&xdrs, &aup))\n    abort ();\n  au->au_origcred.oa_length = len = XDR_GETPOS (&xdrs);\n  au->au_origcred.oa_flavor = AUTH_UNIX;\n  au->au_origcred.oa_base = mem_alloc ((u_int) len);\n  if (au->au_origcred.oa_base == NULL)\n    goto no_memory;\n  memcpy(au->au_origcred.oa_base, mymem, (u_int) len);\n\n  /*\n   * set auth handle to reflect new cred.\n   */\n  auth->ah_cred = au->au_origcred;\n  marshal_new_auth (auth);\n  return auth;\n}",
    "authunix_create_default": "*\nauthunix_create_default (void){\n  char machname[MAX_MACHINE_NAME + 1];\n\n  if (__gethostname (machname, MAX_MACHINE_NAME) == -1)\n    abort ();\n  machname[MAX_MACHINE_NAME] = 0;\n  uid_t uid = __geteuid ();\n  gid_t gid = __getegid ();\n\n  int max_nr_groups;\n  /* When we have to try a second time, do not use alloca() again.  We\n     might have reached the stack limit already.  */\n  bool retry = false;\n again:\n  /* Ask the kernel how many groups there are exactly.  Note that we\n     might have to redo all this if the number of groups has changed\n     between the two calls.  */\n  max_nr_groups = __getgroups (0, NULL);\n\n  /* Just some random reasonable stack limit.  */\n#define ALLOCA_LIMIT (1024 / sizeof (gid_t))\n  gid_t *gids = NULL;\n  if (max_nr_groups < ALLOCA_LIMIT && ! retry)\n    gids = (gid_t *) alloca (max_nr_groups * sizeof (gid_t));\n  else\n    {\n      gids = (gid_t *) malloc (max_nr_groups * sizeof (gid_t));\n      if (gids == NULL)\n\treturn NULL;\n    }\n\n  int len = __getgroups (max_nr_groups, gids);\n  if (len == -1)\n    {\n      if (errno == EINVAL)\n\t{\n\t  /* New groups added in the meantime.  Try again.  */\n\t  if (max_nr_groups >= ALLOCA_LIMIT || retry)\n\t    free (gids);\n\t  retry = true;\n\t  goto again;\n\t}\n      /* No other error can happen.  */\n      abort ();\n    }\n\n  /* This braindamaged Sun code forces us here to truncate the\n     list of groups to NGRPS members since the code in\n     authuxprot.c transforms a fixed array.  Grrr.  */\n  AUTH *result = authunix_create (machname, uid, gid, MIN (NGRPS, len), gids);\n\n  if (max_nr_groups >= ALLOCA_LIMIT || retry)\n    free (gids);\n\n  return result;\n}",
    "xdr_authdes_cred": "xdr_authdes_cred (XDR *xdrs, struct authdes_cred *cred){\n  /*\n   * Unrolled xdr\n   */\n  ATTEMPT (xdr_enum (xdrs, (enum_t *) & cred->adc_namekind));\n  switch (cred->adc_namekind)\n    {\n    case ADN_FULLNAME:\n      ATTEMPT (xdr_string (xdrs, &cred->adc_fullname.name, MAXNETNAMELEN));\n      ATTEMPT (xdr_opaque (xdrs, (caddr_t) & cred->adc_fullname.key,\n\t\t\t   sizeof (des_block)));\n      ATTEMPT (xdr_opaque (xdrs, (caddr_t) & cred->adc_fullname.window,\n\t\t\t   sizeof (cred->adc_fullname.window)));\n      return (TRUE);\n    case ADN_NICKNAME:\n      ATTEMPT (xdr_opaque (xdrs, (caddr_t) & cred->adc_nickname,\n\t\t\t   sizeof (cred->adc_nickname)));\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_authdes_verf": "xdr_authdes_verf (register XDR *xdrs, register struct authdes_verf *verf){\n  /*\n   * Unrolled xdr\n   */\n  ATTEMPT (xdr_opaque (xdrs, (caddr_t) & verf->adv_xtimestamp,\n\t\t       sizeof (des_block)));\n  ATTEMPT (xdr_opaque (xdrs, (caddr_t) & verf->adv_int_u,\n\t\t       sizeof (verf->adv_int_u)));\n  return TRUE;\n}",
    "xdr_authunix_parms": "xdr_authunix_parms (XDR * xdrs, struct authunix_parms *p){\n  if (xdr_u_long (xdrs, &(p->aup_time))\n      && xdr_string (xdrs, &(p->aup_machname), MAX_MACHINE_NAME)\n      && (sizeof (uid_t) == sizeof (short int)\n\t  ? xdr_u_short (xdrs, (u_short *) & (p->aup_uid))\n\t  : xdr_u_int (xdrs, (u_int *) & (p->aup_uid)))\n      && (sizeof (gid_t) == sizeof (short int)\n\t  ? xdr_u_short (xdrs, (u_short *) & (p->aup_gid))\n\t  : xdr_u_int (xdrs, (u_int *) & (p->aup_gid)))\n      && xdr_array (xdrs, (caddr_t *) & (p->aup_gids),\n\t\t    & (p->aup_len), NGRPS, sizeof (gid_t),\n\t\t    (sizeof (gid_t) == sizeof (short int)\n\t\t     ? (xdrproc_t) xdr_u_short\n\t\t     : (xdrproc_t) xdr_u_int)))\n    {\n      return TRUE;\n    }\n  return FALSE;\n}",
    "clnt_create": "*\nclnt_create (const char *hostname, u_long prog, u_long vers,\n\t     const char *proto){\n  struct protoent protobuf, *p;\n  size_t prtbuflen;\n  char *prttmpbuf;\n  struct sockaddr_in sin;\n  struct sockaddr_un sun;\n  int sock;\n  struct timeval tv;\n  CLIENT *client;\n\n  if (strcmp (proto, \"unix\") == 0)\n    {\n      if (__sockaddr_un_set (&sun, hostname) < 0)\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  return NULL;\n\t}\n      sock = RPC_ANYSOCK;\n      client = clntunix_create (&sun, prog, vers, &sock, 0, 0);\n      if (client == NULL)\n\treturn NULL;\n#if 0\n      /* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */\n      tv.tv_sec = 25;\n      tv.tv_usec = 0;\n      clnt_control (client, CLSET_TIMEOUT, (char *)&tv);\n#endif\n      return client;\n    }\n\n  if (__libc_rpc_gethostbyname (hostname, &sin) != 0)\n    return NULL;\n\n  prtbuflen = 1024;\n  prttmpbuf = __alloca (prtbuflen);\n  while (__getprotobyname_r (proto, &protobuf, prttmpbuf, prtbuflen, &p) != 0\n\t || p == NULL)\n    if (errno != ERANGE)\n      {\n\tstruct rpc_createerr *ce = &get_rpc_createerr ();\n\tce->cf_stat = RPC_UNKNOWNPROTO;\n\tce->cf_error.re_errno = EPFNOSUPPORT;\n\treturn NULL;\n      }\n    else\n      {\n\t/* Enlarge the buffer.  */\n\tprtbuflen *= 2;\n\tprttmpbuf = __alloca (prtbuflen);\n      }\n\n  sock = RPC_ANYSOCK;\n  switch (p->p_proto)\n    {\n    case IPPROTO_UDP:\n      tv.tv_sec = 5;\n      tv.tv_usec = 0;\n      client = clntudp_create (&sin, prog, vers, tv, &sock);\n      if (client == NULL)\n\t{\n\t  return NULL;\n\t}\n#if 0\n      /* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */\n      tv.tv_sec = 25;\n      clnt_control (client, CLSET_TIMEOUT, (char *)&tv);\n#endif\n      break;\n    case IPPROTO_TCP:\n      client = clnttcp_create (&sin, prog, vers, &sock, 0, 0);\n      if (client == NULL)\n\t{\n\t  return NULL;\n\t}\n#if 0\n      /* This is not wanted.  This would disable the user from having\n\t a timeout in the clnt_call() call.  Only a call to cnlt_control()\n\t by the user should set the timeout value.  */\n      tv.tv_sec = 25;\n      tv.tv_usec = 0;\n      clnt_control (client, CLSET_TIMEOUT, (char *)&tv);\n#endif\n      break;\n    default:\n      {\n\tstruct rpc_createerr *ce = &get_rpc_createerr ();\n\tce->cf_stat = RPC_SYSTEMERROR;\n\tce->cf_error.re_errno = EPFNOSUPPORT;\n      }\n      return (NULL);\n    }\n  return client;\n}",
    "clnt_sperror": "*\nclnt_sperror (CLIENT * rpch, const char *msg){\n  struct rpc_err e;\n  CLNT_GETERR (rpch, &e);\n\n  const char *errstr = clnt_sperrno (e.re_status);\n\n  char chrbuf[1024];\n  char *str;\n  char *tmpstr;\n  int res;\n  switch (e.re_status)\n    {\n    case RPC_SUCCESS:\n    case RPC_CANTENCODEARGS:\n    case RPC_CANTDECODERES:\n    case RPC_TIMEDOUT:\n    case RPC_PROGUNAVAIL:\n    case RPC_PROCUNAVAIL:\n    case RPC_CANTDECODEARGS:\n    case RPC_SYSTEMERROR:\n    case RPC_UNKNOWNHOST:\n    case RPC_UNKNOWNPROTO:\n    case RPC_PMAPFAILURE:\n    case RPC_PROGNOTREGISTERED:\n    case RPC_FAILED:\n      res = __asprintf (&str, \"%s: %s\\n\", msg, errstr);\n      break;\n\n    case RPC_CANTSEND:\n    case RPC_CANTRECV:\n      res = __asprintf (&str, \"%s: %s; errno = %s\\n\",\n\t\t\tmsg, errstr, __strerror_r (e.re_errno,\n\t\t\t\t\t\t   chrbuf, sizeof chrbuf));\n      break;\n\n    case RPC_VERSMISMATCH:\n      res = __asprintf (&str,\n\t\t\t_(\"%s: %s; low version = %lu, high version = %lu\"),\n\t\t\tmsg, errstr, e.re_vers.low, e.re_vers.high);\n      break;\n\n    case RPC_AUTHERROR:\n      tmpstr = auth_errmsg (e.re_why);\n      if (tmpstr != NULL)\n\tres = __asprintf (&str, _(\"%s: %s; why = %s\\n\"), msg, errstr, tmpstr);\n      else\n\tres = __asprintf (&str, _(\"\\\n%s: %s; why = (unknown authentication error - %d)\\n\"),\n\t\t\t  msg, errstr, (int) e.re_why);\n      break;\n\n    case RPC_PROGVERSMISMATCH:\n      res = __asprintf (&str,\n\t\t\t_(\"%s: %s; low version = %lu, high version = %lu\"),\n\t\t\tmsg, errstr, e.re_vers.low, e.re_vers.high);\n      break;\n\n    default:\t\t\t/* unknown */\n      res = __asprintf (&str, \"%s: %s; s1 = %lu, s2 = %lu\",\n\t\t\tmsg, errstr, e.re_lb.s1, e.re_lb.s2);\n      break;\n    }\n\n  if (res < 0)\n    return NULL;\n\n  char *oldbuf = buf;\n  buf = str;\n  free (oldbuf);\n\n  return str;\n}",
    "clnt_perror": "clnt_perror (CLIENT * rpch, const char *msg){\n  (void) __fxprintf (NULL, \"%s\", clnt_sperror (rpch, msg));\n}",
    "clnt_sperrno": "char *\nclnt_sperrno (enum clnt_stat stat){\n  size_t i;\n\n  for (i = 0; i < sizeof (rpc_errlist) / sizeof (struct rpc_errtab); i++)\n    {\n      if (rpc_errlist[i].status == stat)\n\t{\n\t  return _(rpc_errstr + rpc_errlist[i].message_off);\n\t}\n    }\n  return _(\"RPC: (unknown error code)\");\n}",
    "clnt_perrno": "#endif\n\nvoid\nclnt_perrno (enum clnt_stat num){\n  (void) __fxprintf (NULL, \"%s\", clnt_sperrno (num));\n}",
    "clnt_spcreateerror": "#endif\n\nchar *\nclnt_spcreateerror (const char *msg){\n  struct rpc_createerr *ce = &get_rpc_createerr ();\n\n  char chrbuf[1024];\n  const char *connector = \"\";\n  const char *errstr = \"\";\n  switch (ce->cf_stat)\n    {\n    case RPC_PMAPFAILURE:\n      connector = \" - \";\n      errstr = clnt_sperrno (ce->cf_error.re_status);\n      break;\n\n    case RPC_SYSTEMERROR:\n      connector = \" - \";\n      errstr = __strerror_r (ce->cf_error.re_errno, chrbuf, sizeof chrbuf);\n      break;\n\n    default:\n      break;\n    }\n\n  char *str;\n  if (__asprintf (&str, \"%s: %s%s%s\\n\",\n\t\t  msg, clnt_sperrno (ce->cf_stat), connector, errstr) < 0)\n    return NULL;\n\n  char *oldbuf = buf;\n  buf = str;\n  free (oldbuf);\n\n  return str;\n}",
    "clnt_pcreateerror": "clnt_pcreateerror (const char *msg){\n  (void) __fxprintf (NULL, \"%s\", clnt_spcreateerror (msg));\n}",
    "clntraw_create": "*\nclntraw_create (u_long prog, u_long vers){\n  struct clntraw_private_s *clp = clntraw_private;\n  struct rpc_msg call_msg;\n  XDR *xdrs;\n  CLIENT *client;\n\n  if (clp == 0)\n    {\n      clp = (struct clntraw_private_s *) calloc (1, sizeof (*clp));\n      if (clp == 0)\n\treturn (0);\n      clntraw_private = clp;\n    }\n  xdrs = &clp->xdr_stream;\n  client = &clp->client_object;\n  /*\n   * pre-serialize the static part of the call msg and stash it away\n   */\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = prog;\n  call_msg.rm_call.cb_vers = vers;\n  xdrmem_create (xdrs, clp->mashl_callmsg.msg, MCALL_MSG_SIZE, XDR_ENCODE);\n  if (!xdr_callhdr (xdrs, &call_msg))\n    {\n      perror (_ (\"clnt_raw.c: fatal header serialization error\"));\n    }\n  clp->mcnt = XDR_GETPOS (xdrs);\n  XDR_DESTROY (xdrs);\n\n  /*\n   * Set xdrmem for client/server shared buffer\n   */\n  xdrmem_create (xdrs, clp->_raw_buf, UDPMSGSIZE, XDR_FREE);\n\n  /*\n   * create client handle\n   */\n  client->cl_ops = (struct clnt_ops *) &client_ops;\n  client->cl_auth = authnone_create ();\n  return client;\n}",
    "callrpc": "callrpc (const char *host, u_long prognum, u_long versnum, u_long procnum,\n\t xdrproc_t inproc, const char *in, xdrproc_t outproc, char *out){\n  struct callrpc_private_s *crp = callrpc_private;\n  struct sockaddr_in server_addr;\n  enum clnt_stat clnt_stat;\n  struct timeval timeout, tottimeout;\n\n  if (crp == 0)\n    {\n      crp = (struct callrpc_private_s *) calloc (1, sizeof (*crp));\n      if (crp == 0)\n\treturn 0;\n      callrpc_private = crp;\n    }\n  if (crp->oldhost == NULL)\n    {\n      crp->oldhost = malloc (256);\n      crp->oldhost[0] = 0;\n      crp->socket = RPC_ANYSOCK;\n    }\n  if (crp->valid && crp->oldprognum == prognum && crp->oldversnum == versnum\n      && strcmp (crp->oldhost, host) == 0)\n    {\n      /* reuse old client */\n    }\n  else\n    {\n      crp->valid = 0;\n      if (crp->socket != RPC_ANYSOCK)\n\t{\n\t  (void) __close (crp->socket);\n\t  crp->socket = RPC_ANYSOCK;\n\t}\n      if (crp->client)\n\t{\n\t  clnt_destroy (crp->client);\n\t  crp->client = NULL;\n\t}\n\n      if (__libc_rpc_gethostbyname (host, &server_addr) != 0)\n\treturn (int) get_rpc_createerr().cf_stat;\n\n      timeout.tv_usec = 0;\n      timeout.tv_sec = 5;\n      if ((crp->client = clntudp_create (&server_addr, (u_long) prognum,\n\t\t\t  (u_long) versnum, timeout, &crp->socket)) == NULL)\n\treturn (int) get_rpc_createerr().cf_stat;\n      crp->valid = 1;\n      crp->oldprognum = prognum;\n      crp->oldversnum = versnum;\n      (void) strncpy (crp->oldhost, host, 255);\n      crp->oldhost[255] = '\\0';\n    }\n  tottimeout.tv_sec = 25;\n  tottimeout.tv_usec = 0;\n  clnt_stat = clnt_call (crp->client, procnum, inproc, (char *) in,\n\t\t\t outproc, out, tottimeout);\n  /*\n   * if call failed, empty cache\n   */\n  if (clnt_stat != RPC_SUCCESS)\n    crp->valid = 0;\n  return (int) clnt_stat;\n}",
    "clnttcp_create": "*\nclnttcp_create (struct sockaddr_in *raddr, u_long prog, u_long vers,\n\t\tint *sockp, u_int sendsz, u_int recvsz){\n  CLIENT *h;\n  struct ct_data *ct;\n  struct rpc_msg call_msg;\n\n  h = (CLIENT *) mem_alloc (sizeof (*h));\n  ct = (struct ct_data *) mem_alloc (sizeof (*ct));\n  if (h == NULL || ct == NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      ce->cf_stat = RPC_SYSTEMERROR;\n      ce->cf_error.re_errno = ENOMEM;\n      goto fooy;\n    }\n\n  /*\n   * If no port number given ask the pmap for one\n   */\n  if (raddr->sin_port == 0)\n    {\n      u_short port;\n      if ((port = pmap_getport (raddr, prog, vers, IPPROTO_TCP)) == 0)\n\t{\n\t  mem_free ((caddr_t) ct, sizeof (struct ct_data));\n\t  mem_free ((caddr_t) h, sizeof (CLIENT));\n\t  return ((CLIENT *) NULL);\n\t}\n      raddr->sin_port = htons (port);\n    }\n\n  /*\n   * If no socket given, open one\n   */\n  if (*sockp < 0)\n    {\n      *sockp = __socket (AF_INET, SOCK_STREAM, IPPROTO_TCP);\n      (void) bindresvport (*sockp, (struct sockaddr_in *) 0);\n      if ((*sockp < 0)\n\t  || (__connect (*sockp, (struct sockaddr *) raddr,\n\t\t\t sizeof (*raddr)) < 0))\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  if (*sockp >= 0)\n\t    (void) __close (*sockp);\n\t  goto fooy;\n\t}\n      ct->ct_closeit = TRUE;\n    }\n  else\n    {\n      ct->ct_closeit = FALSE;\n    }\n\n  /*\n   * Set up private data struct\n   */\n  ct->ct_sock = *sockp;\n  ct->ct_wait.tv_usec = 0;\n  ct->ct_waitset = FALSE;\n  ct->ct_addr = *raddr;\n\n  /*\n   * Initialize call message\n   */\n  call_msg.rm_xid = _create_xid ();\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = prog;\n  call_msg.rm_call.cb_vers = vers;\n\n  /*\n   * pre-serialize the static part of the call msg and stash it away\n   */\n  xdrmem_create (&(ct->ct_xdrs), ct->ct_mcall, MCALL_MSG_SIZE, XDR_ENCODE);\n  if (!xdr_callhdr (&(ct->ct_xdrs), &call_msg))\n    {\n      if (ct->ct_closeit)\n\t{\n\t  (void) __close (*sockp);\n\t}\n      goto fooy;\n    }\n  ct->ct_mpos = XDR_GETPOS (&(ct->ct_xdrs));\n  XDR_DESTROY (&(ct->ct_xdrs));\n\n  /*\n   * Create a client handle which uses xdrrec for serialization\n   * and authnone for authentication.\n   */\n  xdrrec_create (&(ct->ct_xdrs), sendsz, recvsz,\n\t\t (caddr_t) ct, readtcp, writetcp);\n  h->cl_ops = (struct clnt_ops *) &tcp_ops;\n  h->cl_private = (caddr_t) ct;\n  h->cl_auth = authnone_create ();\n  return h;\n\nfooy:\n  /*\n   * Something goofed, free stuff and barf\n   */\n  mem_free ((caddr_t) ct, sizeof (struct ct_data));\n  mem_free ((caddr_t) h, sizeof (CLIENT));\n  return ((CLIENT *) NULL);\n}",
    "__libc_clntudp_bufcreate": "*\n__libc_clntudp_bufcreate (struct sockaddr_in *raddr, u_long program,\n\t\t\t  u_long version, struct timeval wait, int *sockp,\n\t\t\t  u_int sendsz, u_int recvsz, int flags){\n  CLIENT *cl;\n  struct cu_data *cu = NULL;\n  struct rpc_msg call_msg;\n\n  cl = (CLIENT *) mem_alloc (sizeof (CLIENT));\n  sendsz = ((sendsz + 3) / 4) * 4;\n  recvsz = ((recvsz + 3) / 4) * 4;\n  cu = (struct cu_data *) mem_alloc (sizeof (*cu) + sendsz + recvsz);\n  if (cl == NULL || cu == NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      (void) __fxprintf (NULL, \"%s: %s\",\n\t\t\t \"clntudp_create\", _(\"out of memory\\n\"));\n      ce->cf_stat = RPC_SYSTEMERROR;\n      ce->cf_error.re_errno = ENOMEM;\n      goto fooy;\n    }\n  cu->cu_outbuf = &cu->cu_inbuf[recvsz];\n\n  if (raddr->sin_port == 0)\n    {\n      u_short port;\n      if ((port =\n\t   pmap_getport (raddr, program, version, IPPROTO_UDP)) == 0)\n\t{\n\t  goto fooy;\n\t}\n      raddr->sin_port = htons (port);\n    }\n  cl->cl_ops = (struct clnt_ops *) &udp_ops;\n  cl->cl_private = (caddr_t) cu;\n  cu->cu_raddr = *raddr;\n  cu->cu_rlen = sizeof (cu->cu_raddr);\n  cu->cu_wait = wait;\n  cu->cu_total.tv_sec = -1;\n  cu->cu_total.tv_usec = -1;\n  cu->cu_sendsz = sendsz;\n  cu->cu_recvsz = recvsz;\n  call_msg.rm_xid = _create_xid ();\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = program;\n  call_msg.rm_call.cb_vers = version;\n  xdrmem_create (&(cu->cu_outxdrs), cu->cu_outbuf, sendsz, XDR_ENCODE);\n  if (!xdr_callhdr (&(cu->cu_outxdrs), &call_msg))\n    {\n      goto fooy;\n    }\n  cu->cu_xdrpos = XDR_GETPOS (&(cu->cu_outxdrs));\n  if (*sockp < 0)\n    {\n      *sockp = __socket (AF_INET, SOCK_DGRAM|SOCK_NONBLOCK|flags, IPPROTO_UDP);\n      if (__glibc_unlikely (*sockp < 0))\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  goto fooy;\n\t}\n      /* attempt to bind to prov port */\n      (void) bindresvport (*sockp, (struct sockaddr_in *) 0);\n#ifdef IP_RECVERR\n      {\n\tint on = 1;\n\t__setsockopt (*sockp, SOL_IP, IP_RECVERR, &on, sizeof(on));\n      }\n#endif\n      cu->cu_closeit = TRUE;\n    }\n  else\n    {\n      cu->cu_closeit = FALSE;\n    }\n  cu->cu_sock = *sockp;\n  cl->cl_auth = authnone_create ();\n  return cl;\nfooy:\n  if (cu)\n    mem_free ((caddr_t) cu, sizeof (*cu) + sendsz + recvsz);\n  if (cl)\n    mem_free ((caddr_t) cl, sizeof (CLIENT));\n  return (CLIENT *) NULL;\n}",
    "clntudp_bufcreate": "#endif\n\nCLIENT *\nclntudp_bufcreate (struct sockaddr_in *raddr, u_long program, u_long version,\n\t\t   struct timeval wait, int *sockp, u_int sendsz,\n\t\t   u_int recvsz){\n  return __libc_clntudp_bufcreate (raddr, program, version, wait,\n\t\t\t\t   sockp, sendsz, recvsz, 0);\n}",
    "clntudp_create": "*\nclntudp_create (struct sockaddr_in *raddr, u_long program, u_long version,\n\t\tstruct timeval wait, int *sockp){\n  return __libc_clntudp_bufcreate (raddr, program, version, wait,\n\t\t\t\t   sockp, UDPMSGSIZE, UDPMSGSIZE, 0);\n}",
    "clntunix_create": "*\nclntunix_create (struct sockaddr_un *raddr, u_long prog, u_long vers,\n\t\t int *sockp, u_int sendsz, u_int recvsz){\n  CLIENT *h;\n  struct ct_data *ct = (struct ct_data *) mem_alloc (sizeof (*ct));\n  struct rpc_msg call_msg;\n  int len;\n\n  h = (CLIENT *) mem_alloc (sizeof (*h));\n  if (h == NULL || ct == NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      ce->cf_stat = RPC_SYSTEMERROR;\n      ce->cf_error.re_errno = ENOMEM;\n      goto fooy;\n    }\n\n  /*\n   * If no socket given, open one\n   */\n  if (*sockp < 0)\n    {\n      *sockp = __socket (AF_UNIX, SOCK_STREAM, 0);\n      len = strlen (raddr->sun_path) + sizeof (raddr->sun_family) + 1;\n      if (*sockp < 0\n\t  || __connect (*sockp, (struct sockaddr *) raddr, len) < 0)\n\t{\n\t  struct rpc_createerr *ce = &get_rpc_createerr ();\n\t  ce->cf_stat = RPC_SYSTEMERROR;\n\t  ce->cf_error.re_errno = errno;\n\t  if (*sockp != -1)\n\t    __close (*sockp);\n\t  goto fooy;\n\t}\n      ct->ct_closeit = TRUE;\n    }\n  else\n    {\n      ct->ct_closeit = FALSE;\n    }\n\n  /*\n   * Set up private data struct\n   */\n  ct->ct_sock = *sockp;\n  ct->ct_wait.tv_usec = 0;\n  ct->ct_waitset = FALSE;\n  ct->ct_addr = *raddr;\n\n  /*\n   * Initialize call message\n   */\n  call_msg.rm_xid = _create_xid ();\n  call_msg.rm_direction = CALL;\n  call_msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  call_msg.rm_call.cb_prog = prog;\n  call_msg.rm_call.cb_vers = vers;\n\n  /*\n   * pre-serialize the static part of the call msg and stash it away\n   */\n  xdrmem_create (&(ct->ct_xdrs), ct->ct_mcall, MCALL_MSG_SIZE, XDR_ENCODE);\n  if (!xdr_callhdr (&(ct->ct_xdrs), &call_msg))\n    {\n      if (ct->ct_closeit)\n\t__close (*sockp);\n      goto fooy;\n    }\n  ct->ct_mpos = XDR_GETPOS (&(ct->ct_xdrs));\n  XDR_DESTROY (&(ct->ct_xdrs));\n\n  /*\n   * Create a client handle which uses xdrrec for serialization\n   * and authnone for authentication.\n   */\n  xdrrec_create (&(ct->ct_xdrs), sendsz, recvsz,\n\t\t (caddr_t) ct, readunix, writeunix);\n  h->cl_ops = (struct clnt_ops *) &unix_ops;\n  h->cl_private = (caddr_t) ct;\n  h->cl_auth = authnone_create ();\n  return h;\n\nfooy:\n  /*\n   * Something goofed, free stuff and barf\n   */\n  mem_free ((caddr_t) ct, sizeof (struct ct_data));\n  mem_free ((caddr_t) h, sizeof (CLIENT));\n  return (CLIENT *) NULL;\n}",
    "cbc_crypt": "cbc_crypt (char *key, char *buf, unsigned int len, unsigned int mode,\n\t   char *ivec){\n  int err;\n  struct desparams dp;\n\n  dp.des_mode = CBC;\n  COPY8 (ivec, dp.des_ivec);\n  err = common_crypt (key, buf, len, mode, &dp);\n  COPY8 (dp.des_ivec, ivec);\n  return err;\n}",
    "ecb_crypt": "ecb_crypt (char *key, char *buf, unsigned int len, unsigned int mode){\n  struct desparams dp;\n\n  dp.des_mode = ECB;\n  return common_crypt (key, buf, len, mode, &dp);\n}",
    "des_setparity": "des_setparity (char *p){\n  int i;\n\n  for (i = 0; i < 8; i++)\n    {\n      *p = partab[*p & 0x7f];\n      p++;\n    }\n}",
    "get_myaddress": "get_myaddress (struct sockaddr_in *addr){\n  struct ifaddrs *ifa;\n\n  if (getifaddrs (&ifa) != 0)\n    {\n      perror (\"get_myaddress: getifaddrs\");\n      exit (1);\n    }\n\n  int loopback = 0;\n  struct ifaddrs *run;\n\n again:\n  run = ifa;\n  while (run != NULL)\n    {\n      if ((run->ifa_flags & IFF_UP)\n\t  && run->ifa_addr != NULL\n\t  && run->ifa_addr->sa_family == AF_INET\n\t  && (!(run->ifa_flags & IFF_LOOPBACK)\n\t      || (loopback == 1 && (run->ifa_flags & IFF_LOOPBACK))))\n\t{\n\t  *addr = *((struct sockaddr_in *) run->ifa_addr);\n\t  addr->sin_port = htons (PMAPPORT);\n\t  goto out;\n\t}\n\n      run = run->ifa_next;\n    }\n\n  if (loopback == 0)\n    {\n      loopback = 1;\n      goto again;\n    }\n out:\n  freeifaddrs (ifa);\n\n  /* The function is horribly specified.  It does not return any error\n     if no interface is up.  Probably this won't happen (at least\n     loopback is there) but still...  */\n}",
    "getrpcport": "getrpcport (const char *host, u_long prognum, u_long versnum, u_int proto){\n  struct sockaddr_in addr;\n\n  if (__libc_rpc_gethostbyname (host, &addr) != 0)\n    return 0;\n  return pmap_getport (&addr, prognum, versnum, proto);\n}",
    "key_setsecret": "key_setsecret (char *secretkey){\n  keystatus status;\n\n  if (!key_call ((u_long) KEY_SET, (xdrproc_t) xdr_keybuf, secretkey,\n\t\t (xdrproc_t) xdr_keystatus, (char *) &status))\n    return -1;\n  if (status != KEY_SUCCESS)\n    {\n      debug (\"set status is nonzero\");\n      return -1;\n    }\n  return 0;\n}",
    "key_secretkey_is_set": "key_secretkey_is_set (void){\n  struct key_netstres kres;\n\n  memset (&kres, 0, sizeof (kres));\n  if (key_call ((u_long) KEY_NET_GET, (xdrproc_t) xdr_void,\n\t\t(char *) NULL, (xdrproc_t) xdr_key_netstres,\n\t\t(char *) &kres) &&\n      (kres.status == KEY_SUCCESS) &&\n      (kres.key_netstres_u.knet.st_priv_key[0] != 0))\n    {\n      /* avoid leaving secret key in memory */\n      memset (kres.key_netstres_u.knet.st_priv_key, 0, HEXKEYBYTES);\n      return 1;\n    }\n  return 0;\n}",
    "key_encryptsession": "#endif\n\nint\nkey_encryptsession (char *remotename, des_block *deskey){\n  cryptkeyarg arg;\n  cryptkeyres res;\n\n  arg.remotename = remotename;\n  arg.deskey = *deskey;\n  if (!key_call ((u_long) KEY_ENCRYPT, (xdrproc_t) xdr_cryptkeyarg,\n\t\t (char *) &arg, (xdrproc_t) xdr_cryptkeyres,\n\t\t (char *) &res))\n    return -1;\n\n  if (res.status != KEY_SUCCESS)\n    {\n      debug (\"encrypt status is nonzero\");\n      return -1;\n    }\n  *deskey = res.cryptkeyres_u.deskey;\n  return 0;\n}",
    "key_decryptsession": "key_decryptsession (char *remotename, des_block *deskey){\n  cryptkeyarg arg;\n  cryptkeyres res;\n\n  arg.remotename = remotename;\n  arg.deskey = *deskey;\n  if (!key_call ((u_long) KEY_DECRYPT, (xdrproc_t) xdr_cryptkeyarg,\n\t\t (char *) &arg, (xdrproc_t) xdr_cryptkeyres,\n\t\t (char *) &res))\n    return -1;\n  if (res.status != KEY_SUCCESS)\n    {\n      debug (\"decrypt status is nonzero\");\n      return -1;\n    }\n  *deskey = res.cryptkeyres_u.deskey;\n  return 0;\n}",
    "key_encryptsession_pk": "key_encryptsession_pk (char *remotename, netobj *remotekey,\n\t\t       des_block *deskey){\n  cryptkeyarg2 arg;\n  cryptkeyres res;\n\n  arg.remotename = remotename;\n  arg.remotekey = *remotekey;\n  arg.deskey = *deskey;\n  if (!key_call ((u_long) KEY_ENCRYPT_PK, (xdrproc_t) xdr_cryptkeyarg2,\n\t\t (char *) &arg, (xdrproc_t) xdr_cryptkeyres,\n\t\t (char *) &res))\n    return -1;\n\n  if (res.status != KEY_SUCCESS)\n    {\n      debug (\"encrypt status is nonzero\");\n      return -1;\n    }\n  *deskey = res.cryptkeyres_u.deskey;\n  return 0;\n}",
    "key_decryptsession_pk": "key_decryptsession_pk (char *remotename, netobj *remotekey,\n\t\t       des_block *deskey){\n  cryptkeyarg2 arg;\n  cryptkeyres res;\n\n  arg.remotename = remotename;\n  arg.remotekey = *remotekey;\n  arg.deskey = *deskey;\n  if (!key_call ((u_long) KEY_DECRYPT_PK, (xdrproc_t) xdr_cryptkeyarg2,\n\t\t (char *) &arg, (xdrproc_t) xdr_cryptkeyres,\n\t\t (char *) &res))\n    return -1;\n\n  if (res.status != KEY_SUCCESS)\n    {\n      debug (\"decrypt status is nonzero\");\n      return -1;\n    }\n  *deskey = res.cryptkeyres_u.deskey;\n  return 0;\n}",
    "key_gendes": "key_gendes (des_block *key){\n  struct sockaddr_in sin;\n  CLIENT *client;\n  int socket;\n  enum clnt_stat stat;\n\n  sin.sin_family = AF_INET;\n  sin.sin_port = 0;\n  sin.sin_addr.s_addr = htonl (INADDR_LOOPBACK);\n  memset (sin.sin_zero, 0, sizeof (sin.sin_zero));\n  socket = RPC_ANYSOCK;\n  client = clntudp_bufcreate (&sin, (u_long) KEY_PROG, (u_long) KEY_VERS,\n\t\t\t      trytimeout, &socket, RPCSMALLMSGSIZE,\n\t\t\t      RPCSMALLMSGSIZE);\n  if (client == NULL)\n    return -1;\n\n  stat = clnt_call (client, KEY_GEN, (xdrproc_t) xdr_void, NULL,\n\t\t    (xdrproc_t) xdr_des_block, (caddr_t) key,\n\t\t    tottimeout);\n  clnt_destroy (client);\n  __close (socket);\n  if (stat != RPC_SUCCESS)\n    return -1;\n\n  return 0;\n}",
    "key_setnet": "#endif\n\nint\nkey_setnet (struct key_netstarg *arg){\n  keystatus status;\n\n  if (!key_call ((u_long) KEY_NET_PUT, (xdrproc_t) xdr_key_netstarg,\n\t\t (char *) arg,(xdrproc_t) xdr_keystatus,\n\t\t (char *) &status))\n    return -1;\n\n  if (status != KEY_SUCCESS)\n    {\n      debug (\"key_setnet status is nonzero\");\n      return -1;\n    }\n  return 1;\n}",
    "key_get_conv": "key_get_conv (char *pkey, des_block *deskey){\n  cryptkeyres res;\n\n  if (!key_call ((u_long) KEY_GET_CONV, (xdrproc_t) xdr_keybuf, pkey,\n\t\t (xdrproc_t) xdr_cryptkeyres, (char *) &res))\n    return -1;\n\n  if (res.status != KEY_SUCCESS)\n    {\n      debug (\"get_conv status is nonzero\");\n      return -1;\n    }\n  *deskey = res.cryptkeyres_u.deskey;\n  return 0;\n}",
    "xdr_keystatus": "xdr_keystatus (XDR * xdrs, keystatus * objp){\n  if (!xdr_enum (xdrs, (enum_t *) objp))\n    return FALSE;\n\n  return TRUE;\n}",
    "xdr_keybuf": "xdr_keybuf (XDR * xdrs, keybuf objp){\n  if (!xdr_opaque (xdrs, objp, HEXKEYBYTES))\n    return FALSE;\n\n  return TRUE;\n}",
    "xdr_netnamestr": "xdr_netnamestr (XDR * xdrs, netnamestr * objp){\n  if (!xdr_string (xdrs, objp, MAXNETNAMELEN))\n    return FALSE;\n\n  return TRUE;\n}",
    "xdr_cryptkeyarg": "xdr_cryptkeyarg (XDR * xdrs, cryptkeyarg * objp){\n  if (!xdr_netnamestr (xdrs, &objp->remotename))\n    return FALSE;\n\n  if (!xdr_des_block (xdrs, &objp->deskey))\n    return FALSE;\n\n  return TRUE;\n}",
    "xdr_cryptkeyarg2": "xdr_cryptkeyarg2 (XDR * xdrs, cryptkeyarg2 * objp){\n  if (!xdr_netnamestr (xdrs, &objp->remotename))\n    return FALSE;\n  if (!xdr_netobj (xdrs, &objp->remotekey))\n    return FALSE;\n  if (!xdr_des_block (xdrs, &objp->deskey))\n    return FALSE;\n  return TRUE;\n}",
    "xdr_cryptkeyres": "xdr_cryptkeyres (XDR * xdrs, cryptkeyres * objp){\n  if (!xdr_keystatus (xdrs, &objp->status))\n    return FALSE;\n  switch (objp->status)\n    {\n    case KEY_SUCCESS:\n      if (!xdr_des_block (xdrs, &objp->cryptkeyres_u.deskey))\n\treturn FALSE;\n      break;\n    default:\n      break;\n    }\n  return TRUE;\n}",
    "xdr_unixcred": "xdr_unixcred (XDR * xdrs, unixcred * objp){\n  if (!xdr_u_int (xdrs, &objp->uid))\n    return FALSE;\n  if (!xdr_u_int (xdrs, &objp->gid))\n    return FALSE;\n  if (!xdr_array (xdrs, (void *) &objp->gids.gids_val,\n\t\t  (u_int *) & objp->gids.gids_len, MAXGIDS,\n\t\t  sizeof (u_int), (xdrproc_t) xdr_u_int))\n    return FALSE;\n  return TRUE;\n}",
    "xdr_getcredres": "xdr_getcredres (XDR * xdrs, getcredres * objp){\n  if (!xdr_keystatus (xdrs, &objp->status))\n    return FALSE;\n  switch (objp->status)\n    {\n    case KEY_SUCCESS:\n      if (!xdr_unixcred (xdrs, &objp->getcredres_u.cred))\n\treturn FALSE;\n      break;\n    default:\n      break;\n    }\n  return TRUE;\n}",
    "xdr_key_netstarg": "xdr_key_netstarg (XDR * xdrs, key_netstarg * objp){\n  if (!xdr_keybuf (xdrs, objp->st_priv_key))\n    return FALSE;\n  if (!xdr_keybuf (xdrs, objp->st_pub_key))\n    return FALSE;\n  if (!xdr_netnamestr (xdrs, &objp->st_netname))\n    return FALSE;\n  return TRUE;\n}",
    "xdr_key_netstres": "xdr_key_netstres (XDR * xdrs, key_netstres * objp){\n  if (!xdr_keystatus (xdrs, &objp->status))\n    return FALSE;\n  switch (objp->status)\n    {\n    case KEY_SUCCESS:\n      if (!xdr_key_netstarg (xdrs, &objp->key_netstres_u.knet))\n\treturn FALSE;\n      break;\n    default:\n      break;\n    }\n  return TRUE;\n}",
    "user2netname": "user2netname (char netname[MAXNETNAMELEN + 1], const uid_t uid,\n\t      const char *domain){\n  char dfltdom[MAXNETNAMELEN + 1];\n  size_t i;\n\n  if (domain == NULL)\n    {\n      if (getdomainname (dfltdom, sizeof (dfltdom)) < 0)\n\treturn 0;\n    }\n  else\n    {\n      strncpy (dfltdom, domain, MAXNETNAMELEN);\n      dfltdom[MAXNETNAMELEN] = '\\0';\n    }\n\n  if ((strlen (dfltdom) + OPSYS_LEN + 3 + MAXIPRINT) > (size_t) MAXNETNAMELEN)\n    return 0;\n\n  /* GCC with -Os or -O1 warns that sprint might overflow while handling\n     dfltdom, however the above test does check if an overflow would\n     happen.  */\n#if __GNUC_PREREQ (8, 0)\n  DIAG_PUSH_NEEDS_COMMENT;\n  DIAG_IGNORE_NEEDS_COMMENT (8, \"-Wformat-overflow\");\n#endif\n  sprintf (netname, \"%s.%d@%s\", OPSYS, uid, dfltdom);\n#if __GNUC_PREREQ (8, 0)\n  DIAG_POP_NEEDS_COMMENT;\n#endif\n  i = strlen (netname);\n  if (netname[i - 1] == '.')\n    netname[i - 1] = '\\0';\n  return 1;\n}",
    "host2netname": "host2netname (char netname[MAXNETNAMELEN + 1], const char *host,\n\t      const char *domain){\n  char *p;\n  char hostname[MAXHOSTNAMELEN + 1];\n  char domainname[MAXHOSTNAMELEN + 1];\n  char *dot_in_host;\n  size_t i;\n\n  netname[0] = '\\0';\t\t/* make null first (no need for memset) */\n\n  if (host == NULL)\n    __gethostname (hostname, MAXHOSTNAMELEN);\n  else\n    {\n      strncpy (hostname, host, MAXHOSTNAMELEN);\n      hostname[MAXHOSTNAMELEN] = '\\0';\n    }\n\n  dot_in_host = strchr (hostname, '.');\n  if (domain == NULL)\n    {\n      p = dot_in_host;\n      if (p)\n\t{\n\t  ++p;\n\t  strncpy (domainname, p, MAXHOSTNAMELEN);\n\t  domainname[MAXHOSTNAMELEN] = '\\0';\n\t}\n      else\n\t{\n\t  domainname[0] = 0;\n\t  if (getdomainname (domainname, MAXHOSTNAMELEN))\n\t    return 0;\n\t}\n    }\n  else\n    {\n      strncpy (domainname, domain, MAXHOSTNAMELEN);\n      domainname[MAXHOSTNAMELEN] = '\\0';\n    }\n\n  i = strlen (domainname);\n  if (i == 0)\n    /* No domainname */\n    return 0;\n  if (domainname[i - 1] == '.')\n    domainname[i - 1] = 0;\n\n  if (dot_in_host)\t\t/* strip off rest of name */\n    *dot_in_host = '\\0';\n\n  if ((strlen (domainname) + strlen (hostname) + OPSYS_LEN + 3)\n      > MAXNETNAMELEN)\n    return 0;\n\n  sprintf (netname, \"%s.%s@%s\", OPSYS, hostname, domainname);\n  return 1;\n}",
    "getnetname": "#endif\n\nint\ngetnetname (char name[MAXNETNAMELEN + 1]){\n  uid_t uid;\n  int dummy;\n\n  uid = __geteuid ();\n  if (uid == 0)\n    dummy = host2netname (name, NULL, NULL);\n  else\n    dummy = user2netname (name, uid, NULL);\n  return (dummy);\n}",
    "netname2user": "netname2user (const char *netname, uid_t * uidp, gid_t * gidp,\n\t      int *gidlenp, gid_t * gidlist){\n  nss_action_list nip;\n  union\n  {\n    netname2user_function f;\n    void *ptr;\n  } fct;\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n  int no_more;\n\n  no_more = __nss_publickey_lookup2 (&nip, \"netname2user\", NULL, &fct.ptr);\n\n  while (!no_more)\n    {\n      status = (*fct.f) (netname, uidp, gidp, gidlenp, gidlist);\n\n      no_more = __nss_next2 (&nip, \"netname2user\", NULL, &fct.ptr, status, 0);\n    }\n\n  return status == NSS_STATUS_SUCCESS;\n}",
    "netname2host": "#endif\n\nint\nnetname2host (const char *netname, char *hostname, const int hostlen){\n  char *p1, *p2;\n\n  p1 = strchr (netname, '.');\n  if (p1 == NULL)\n    return 0;\n  p1++;\n\n  p2 = strchr (p1, '@');\n  if (p2 == NULL)\n    return 0;\n  *p2 = '\\0';\n\n  if (hostlen > MAXNETNAMELEN)\n    return 0;\n\n  strncpy (hostname, p1, hostlen);\n  hostname[hostlen] = '\\0';\n\n  return 1;\n}",
    "pmap_getmaps": "*\npmap_getmaps (struct sockaddr_in *address){\n  struct pmaplist *head = (struct pmaplist *) NULL;\n  struct timeval minutetimeout;\n  CLIENT *client;\n  bool closeit = false;\n\n  minutetimeout.tv_sec = 60;\n  minutetimeout.tv_usec = 0;\n  address->sin_port = htons (PMAPPORT);\n\n  /* Don't need a reserved port to get ports from the portmapper.  */\n  int socket = __get_socket (address);\n  if (socket != -1)\n    closeit = true;\n\n  client = clnttcp_create (address, PMAPPROG, PMAPVERS, &socket, 50, 500);\n  if (client != (CLIENT *) NULL)\n    {\n      if (CLNT_CALL (client, PMAPPROC_DUMP, (xdrproc_t)xdr_void, NULL,\n\t\t     (xdrproc_t)xdr_pmaplist, (caddr_t)&head,\n\t\t     minutetimeout) != RPC_SUCCESS)\n\t{\n\t  clnt_perror (client, _(\"pmap_getmaps.c: rpc problem\"));\n\t}\n      CLNT_DESTROY (client);\n    }\n  /* We only need to close the socket here if we opened  it.  */\n  if (closeit)\n    __close_nocancel (socket);\n  address->sin_port = 0;\n  return head;\n}",
    "__libc_rpc_getport": "__libc_rpc_getport (struct sockaddr_in *address, u_long program,\n\t\t    u_long version, u_int protocol, time_t timeout_sec,\n\t\t    time_t tottimeout_sec){\n  const struct timeval timeout = {timeout_sec, 0};\n  const struct timeval tottimeout = {tottimeout_sec, 0};\n\n  u_short port = 0;\n  int socket = -1;\n  CLIENT *client;\n  struct pmap parms;\n  bool closeit = false;\n\n  address->sin_port = htons (PMAPPORT);\n  if (protocol == IPPROTO_TCP)\n    {\n      /* Don't need a reserved port to get ports from the portmapper.  */\n      socket = __get_socket(address);\n      if (socket != -1)\n\tcloseit = true;\n      client = clnttcp_create (address, PMAPPROG, PMAPVERS, &socket,\n\t\t\t       RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n    }\n  else\n    client = clntudp_bufcreate (address, PMAPPROG, PMAPVERS, timeout,\n\t\t\t\t&socket, RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n  if (client != (CLIENT *) NULL)\n    {\n      struct rpc_createerr *ce = &get_rpc_createerr ();\n      parms.pm_prog = program;\n      parms.pm_vers = version;\n      parms.pm_prot = protocol;\n      parms.pm_port = 0;\t/* not needed or used */\n      if (CLNT_CALL (client, PMAPPROC_GETPORT, (xdrproc_t)xdr_pmap,\n\t\t     (caddr_t)&parms, (xdrproc_t)xdr_u_short,\n\t\t     (caddr_t)&port, tottimeout) != RPC_SUCCESS)\n\t{\n\t  ce->cf_stat = RPC_PMAPFAILURE;\n\t  clnt_geterr (client, &ce->cf_error);\n\t}\n      else if (port == 0)\n\t{\n\t  ce->cf_stat = RPC_PROGNOTREGISTERED;\n\t}\n      CLNT_DESTROY (client);\n    }\n  /* We only need to close the socket here if we opened  it.  */\n  if (closeit)\n    (void) __close (socket);\n  address->sin_port = 0;\n  return port;\n}",
    "pmap_getport": "u_short\npmap_getport (struct sockaddr_in *address, u_long program, u_long version,\n\t      u_int protocol){\n  return __libc_rpc_getport (address, program, version, protocol, 5, 60);\n}",
    "pmap_set": "pmap_set (u_long program, u_long version, int protocol, u_short port){\n  struct sockaddr_in myaddress;\n  int socket = -1;\n  CLIENT *client;\n  struct pmap parms;\n  bool_t rslt;\n\n  if (!__get_myaddress (&myaddress))\n    return FALSE;\n  client = clntudp_bufcreate (&myaddress, PMAPPROG, PMAPVERS, timeout, &socket,\n\t\t\t      RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n  if (client == (CLIENT *) NULL)\n    return (FALSE);\n  parms.pm_prog = program;\n  parms.pm_vers = version;\n  parms.pm_prot = protocol;\n  parms.pm_port = port;\n  if (CLNT_CALL (client, PMAPPROC_SET, (xdrproc_t)xdr_pmap,\n\t\t (caddr_t)&parms, (xdrproc_t)xdr_bool, (caddr_t)&rslt,\n\t\t tottimeout) != RPC_SUCCESS)\n    {\n      clnt_perror (client, _(\"Cannot register service\"));\n      rslt = FALSE;\n    }\n  CLNT_DESTROY (client);\n  /* (void)close(socket); CLNT_DESTROY closes it */\n  return rslt;\n}",
    "pmap_unset": "pmap_unset (u_long program, u_long version){\n  struct sockaddr_in myaddress;\n  int socket = -1;\n  CLIENT *client;\n  struct pmap parms;\n  bool_t rslt;\n\n  if (!__get_myaddress (&myaddress))\n    return FALSE;\n  client = clntudp_bufcreate (&myaddress, PMAPPROG, PMAPVERS, timeout, &socket,\n\t\t\t      RPCSMALLMSGSIZE, RPCSMALLMSGSIZE);\n  if (client == (CLIENT *) NULL)\n    return FALSE;\n  parms.pm_prog = program;\n  parms.pm_vers = version;\n  parms.pm_port = parms.pm_prot = 0;\n  CLNT_CALL (client, PMAPPROC_UNSET, (xdrproc_t)xdr_pmap,\n\t     (caddr_t)&parms, (xdrproc_t)xdr_bool, (caddr_t)&rslt,\n\t     tottimeout);\n  CLNT_DESTROY (client);\n  /* (void)close(socket); CLNT_DESTROY already closed it */\n  return rslt;\n}",
    "xdr_pmap": "xdr_pmap (XDR *xdrs, struct pmap *regs){\n\n  if (xdr_u_long (xdrs, &regs->pm_prog) &&\n      xdr_u_long (xdrs, &regs->pm_vers) &&\n      xdr_u_long (xdrs, &regs->pm_prot))\n    return xdr_u_long (xdrs, &regs->pm_port);\n  return FALSE;\n}",
    "xdr_pmaplist": "xdr_pmaplist (XDR *xdrs, struct pmaplist **rp){\n  /*\n   * more_elements is pre-computed in case the direction is\n   * XDR_ENCODE or XDR_FREE.  more_elements is overwritten by\n   * xdr_bool when the direction is XDR_DECODE.\n   */\n  bool_t more_elements;\n  int freeing = (xdrs->x_op == XDR_FREE);\n  struct pmaplist *next = NULL;\n\n  while (TRUE)\n    {\n      more_elements = (bool_t) (*rp != NULL);\n      if (!xdr_bool (xdrs, &more_elements))\n\treturn FALSE;\n      if (!more_elements)\n\treturn TRUE;\t\t/* we are done */\n      /*\n       * the unfortunate side effect of non-recursion is that in\n       * the case of freeing we must remember the next object\n       * before we free the current object ...\n       */\n      if (freeing)\n\tnext = (*rp)->pml_next;\n      if (!xdr_reference (xdrs, (caddr_t *) rp,\n\t\t\t  (u_int) sizeof (struct pmaplist),\n\t\t\t  (xdrproc_t) xdr_pmap))\n\t  return FALSE;\n      rp = freeing ? &next : &((*rp)->pml_next);\n    }\n}",
    "pmap_rmtcall": "pmap_rmtcall (struct sockaddr_in *addr, u_long prog, u_long vers, u_long proc,\n\t      xdrproc_t xdrargs, caddr_t argsp, xdrproc_t xdrres, caddr_t resp,\n\t      struct timeval tout, u_long *port_ptr){\n  int socket = -1;\n  CLIENT *client;\n  struct rmtcallargs a;\n  struct rmtcallres r;\n  enum clnt_stat stat;\n\n  addr->sin_port = htons (PMAPPORT);\n  client = clntudp_create (addr, PMAPPROG, PMAPVERS, timeout, &socket);\n  if (client != (CLIENT *) NULL)\n    {\n      a.prog = prog;\n      a.vers = vers;\n      a.proc = proc;\n      a.args_ptr = argsp;\n      a.xdr_args = xdrargs;\n      r.port_ptr = port_ptr;\n      r.results_ptr = resp;\n      r.xdr_results = xdrres;\n      stat = CLNT_CALL (client, PMAPPROC_CALLIT,\n\t\t\t(xdrproc_t)xdr_rmtcall_args,\n\t\t\t(caddr_t)&a, (xdrproc_t)xdr_rmtcallres,\n\t\t\t(caddr_t)&r, tout);\n      CLNT_DESTROY (client);\n    }\n  else\n    {\n      stat = RPC_FAILED;\n    }\n  /* (void)__close(socket); CLNT_DESTROY already closed it */\n  addr->sin_port = 0;\n  return stat;\n}",
    "xdr_rmtcall_args": "xdr_rmtcall_args (XDR *xdrs, struct rmtcallargs *cap){\n  u_int lenposition, argposition, position;\n\n  if (xdr_u_long (xdrs, &(cap->prog)) &&\n      xdr_u_long (xdrs, &(cap->vers)) &&\n      xdr_u_long (xdrs, &(cap->proc)))\n    {\n      u_long dummy_arglen = 0;\n      lenposition = XDR_GETPOS (xdrs);\n      if (!xdr_u_long (xdrs, &dummy_arglen))\n\treturn FALSE;\n      argposition = XDR_GETPOS (xdrs);\n      if (!(*(cap->xdr_args)) (xdrs, cap->args_ptr))\n\treturn FALSE;\n      position = XDR_GETPOS (xdrs);\n      cap->arglen = (u_long) position - (u_long) argposition;\n      XDR_SETPOS (xdrs, lenposition);\n      if (!xdr_u_long (xdrs, &(cap->arglen)))\n\treturn FALSE;\n      XDR_SETPOS (xdrs, position);\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_rmtcallres": "xdr_rmtcallres (XDR *xdrs, struct rmtcallres *crp){\n  caddr_t port_ptr;\n\n  port_ptr = (caddr_t) crp->port_ptr;\n  if (xdr_reference (xdrs, &port_ptr, sizeof (u_long),\n\t\t     (xdrproc_t) xdr_u_long)\n      && xdr_u_long (xdrs, &crp->resultslen))\n    {\n      crp->port_ptr = (u_long *) port_ptr;\n      return (*(crp->xdr_results)) (xdrs, crp->results_ptr);\n    }\n  return FALSE;\n}",
    "clnt_broadcast": "clnt_broadcast (/* program number */\n\t\tu_long prog,\n\t\t/* version number */\n\t\tu_long vers,\n\t\t/* procedure number */\n\t\tu_long proc,\n\t\t/* xdr routine for args */\n\t\txdrproc_t xargs,\n\t\t/* pointer to args */\n\t\tcaddr_t argsp,\n\t\t/* xdr routine for results */\n\t\txdrproc_t xresults,\n\t\t/* pointer to results */\n\t\tcaddr_t resultsp,\n\t\t/* call with each result obtained */\n\t\tresultproc_t eachresult){\n  enum clnt_stat stat = RPC_FAILED;\n  AUTH *unix_auth = authunix_create_default ();\n  XDR xdr_stream;\n  XDR *xdrs = &xdr_stream;\n  struct timeval t;\n  int outlen, inlen, nets;\n  socklen_t fromlen;\n  int sock;\n  int on = 1;\n  struct pollfd fd;\n  int milliseconds;\n  int i;\n  bool_t done = FALSE;\n  u_long xid;\n  u_long port;\n  struct in_addr addrs[20];\n  struct sockaddr_in baddr, raddr;\t/* broadcast and response addresses */\n  struct rmtcallargs a;\n  struct rmtcallres r;\n  struct rpc_msg msg;\n  char outbuf[MAX_BROADCAST_SIZE], inbuf[UDPMSGSIZE];\n\n  /*\n   * initialization: create a socket, a broadcast address, and\n   * preserialize the arguments into a send buffer.\n   */\n  if ((sock = __socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)\n    {\n      perror (_(\"Cannot create socket for broadcast rpc\"));\n      stat = RPC_CANTSEND;\n      goto done_broad;\n    }\n#ifdef SO_BROADCAST\n  if (__setsockopt (sock, SOL_SOCKET, SO_BROADCAST, &on, sizeof (on)) < 0)\n    {\n      perror (_(\"Cannot set socket option SO_BROADCAST\"));\n      stat = RPC_CANTSEND;\n      goto done_broad;\n    }\n#endif /* def SO_BROADCAST */\n  fd.fd = sock;\n  fd.events = POLLIN;\n  nets = getbroadcastnets (addrs, sizeof (addrs) / sizeof (addrs[0]));\n  memset ((char *) &baddr, 0, sizeof (baddr));\n  baddr.sin_family = AF_INET;\n  baddr.sin_port = htons (PMAPPORT);\n  baddr.sin_addr.s_addr = htonl (INADDR_ANY);\n/*      baddr.sin_addr.S_un.S_addr = htonl(INADDR_ANY); */\n  msg.rm_xid = xid = _create_xid ();\n  t.tv_usec = 0;\n  msg.rm_direction = CALL;\n  msg.rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  msg.rm_call.cb_prog = PMAPPROG;\n  msg.rm_call.cb_vers = PMAPVERS;\n  msg.rm_call.cb_proc = PMAPPROC_CALLIT;\n  msg.rm_call.cb_cred = unix_auth->ah_cred;\n  msg.rm_call.cb_verf = unix_auth->ah_verf;\n  a.prog = prog;\n  a.vers = vers;\n  a.proc = proc;\n  a.xdr_args = xargs;\n  a.args_ptr = argsp;\n  r.port_ptr = &port;\n  r.xdr_results = xresults;\n  r.results_ptr = resultsp;\n  xdrmem_create (xdrs, outbuf, MAX_BROADCAST_SIZE, XDR_ENCODE);\n  if ((!xdr_callmsg (xdrs, &msg))\n      || (!xdr_rmtcall_args (xdrs, &a)))\n    {\n      stat = RPC_CANTENCODEARGS;\n      goto done_broad;\n    }\n  outlen = (int) xdr_getpos (xdrs);\n  xdr_destroy (xdrs);\n  /*\n   * Basic loop: broadcast a packet and wait a while for response(s).\n   * The response timeout grows larger per iteration.\n   */\n  for (t.tv_sec = 4; t.tv_sec <= 14; t.tv_sec += 2)\n    {\n      for (i = 0; i < nets; i++)\n\t{\n\t  baddr.sin_addr = addrs[i];\n\t  if (__sendto (sock, outbuf, outlen, 0,\n\t\t\t(struct sockaddr *) &baddr,\n\t\t\tsizeof (struct sockaddr)) != outlen)\n\t    {\n\t      perror (_(\"Cannot send broadcast packet\"));\n\t      stat = RPC_CANTSEND;\n\t      goto done_broad;\n\t    }\n\t}\n      if (eachresult == NULL)\n\t{\n\t  stat = RPC_SUCCESS;\n\t  goto done_broad;\n\t}\n    recv_again:\n      msg.acpted_rply.ar_verf = _null_auth;\n      msg.acpted_rply.ar_results.where = (caddr_t) & r;\n      msg.acpted_rply.ar_results.proc = (xdrproc_t) xdr_rmtcallres;\n      milliseconds = t.tv_sec * 1000 + t.tv_usec / 1000;\n      switch (__poll(&fd, 1, milliseconds))\n\t{\n\n\tcase 0:\t\t/* timed out */\n\t  stat = RPC_TIMEDOUT;\n\t  continue;\n\n\tcase -1:\t\t/* some kind of error */\n\t  if (errno == EINTR)\n\t    goto recv_again;\n\t  perror (_(\"Broadcast poll problem\"));\n\t  stat = RPC_CANTRECV;\n\t  goto done_broad;\n\n\t}\t\t\t/* end of poll results switch */\n    try_again:\n      fromlen = sizeof (struct sockaddr);\n      inlen = __recvfrom (sock, inbuf, UDPMSGSIZE, 0,\n\t\t\t  (struct sockaddr *) &raddr, &fromlen);\n      if (inlen < 0)\n\t{\n\t  if (errno == EINTR)\n\t    goto try_again;\n\t  perror (_(\"Cannot receive reply to broadcast\"));\n\t  stat = RPC_CANTRECV;\n\t  goto done_broad;\n\t}\n      if ((size_t) inlen < sizeof (u_long))\n\tgoto recv_again;\n      /*\n       * see if reply transaction id matches sent id.\n       * If so, decode the results.\n       */\n      xdrmem_create (xdrs, inbuf, (u_int) inlen, XDR_DECODE);\n      if (xdr_replymsg (xdrs, &msg))\n\t{\n\t  if (((uint32_t) msg.rm_xid == (uint32_t) xid) &&\n\t      (msg.rm_reply.rp_stat == MSG_ACCEPTED) &&\n\t      (msg.acpted_rply.ar_stat == SUCCESS))\n\t    {\n\t      raddr.sin_port = htons ((u_short) port);\n\t      done = (*eachresult) (resultsp, &raddr);\n\t    }\n\t  /* otherwise, we just ignore the errors ... */\n\t}\n      else\n\t{\n#ifdef notdef\n\t  /* some kind of deserialization problem ... */\n\t  if ((uint32_t) msg.rm_xid == (uint32_t) xid)\n\t    fprintf (stderr, \"Broadcast deserialization problem\");\n\t  /* otherwise, just random garbage */\n#endif\n\t}\n      xdrs->x_op = XDR_FREE;\n      msg.acpted_rply.ar_results.proc = (xdrproc_t)xdr_void;\n      (void) xdr_replymsg (xdrs, &msg);\n      (void) (*xresults) (xdrs, resultsp);\n      xdr_destroy (xdrs);\n      if (done)\n\t{\n\t  stat = RPC_SUCCESS;\n\t  goto done_broad;\n\t}\n      else\n\t{\n\t  goto recv_again;\n\t}\n    }\ndone_broad:\n  (void) __close (sock);\n  AUTH_DESTROY (unix_auth);\n  return stat;\n}",
    "getpublickey": "getpublickey (const char *name, char *key){\n  nss_action_list nip;\n  union\n  {\n    public_function f;\n    void *ptr;\n  } fct;\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n  int no_more;\n\n  no_more = __nss_publickey_lookup2 (&nip, \"getpublickey\", NULL, &fct.ptr);\n\n  while (! no_more)\n    {\n      status = (*fct.f) (name, key, &errno);\n\n      no_more = __nss_next2 (&nip, \"getpublickey\", NULL, &fct.ptr, status, 0);\n    }\n\n  return status == NSS_STATUS_SUCCESS;\n}",
    "getsecretkey": "getsecretkey (const char *name, char *key, const char *passwd){\n  nss_action_list nip;\n  union\n  {\n    secret_function f;\n    void *ptr;\n  } fct;\n  enum nss_status status = NSS_STATUS_UNAVAIL;\n  int no_more;\n\n  no_more = __nss_publickey_lookup2 (&nip, \"getsecretkey\", NULL, &fct.ptr);\n\n  while (! no_more)\n    {\n      status = (*fct.f) (name, key, passwd, &errno);\n\n      no_more = __nss_next2 (&nip, \"getsecretkey\", NULL, &fct.ptr, status, 0);\n    }\n\n  return status == NSS_STATUS_SUCCESS;\n}",
    "xdr_callmsg": "xdr_callmsg (XDR *xdrs, struct rpc_msg *cmsg){\n  int32_t *buf;\n  struct opaque_auth *oa;\n\n  if (xdrs->x_op == XDR_ENCODE)\n    {\n      if (cmsg->rm_call.cb_cred.oa_length > MAX_AUTH_BYTES)\n\t{\n\t  return (FALSE);\n\t}\n      if (cmsg->rm_call.cb_verf.oa_length > MAX_AUTH_BYTES)\n\t{\n\t  return (FALSE);\n\t}\n      buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT\n\t\t\t+ RNDUP (cmsg->rm_call.cb_cred.oa_length)\n\t\t\t+ 2 * BYTES_PER_XDR_UNIT\n\t\t\t+ RNDUP (cmsg->rm_call.cb_verf.oa_length));\n      if (buf != NULL)\n\t{\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_xid);\n\t  (void) IXDR_PUT_ENUM (buf, cmsg->rm_direction);\n\t  if (cmsg->rm_direction != CALL)\n\t    return FALSE;\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_rpcvers);\n\t  if (cmsg->rm_call.cb_rpcvers != RPC_MSG_VERSION)\n\t    return FALSE;\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_prog);\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_vers);\n\t  (void) IXDR_PUT_LONG (buf, cmsg->rm_call.cb_proc);\n\t  oa = &cmsg->rm_call.cb_cred;\n\t  (void) IXDR_PUT_ENUM (buf, oa->oa_flavor);\n\t  (void) IXDR_PUT_INT32 (buf, oa->oa_length);\n\t  if (oa->oa_length)\n\t    {\n\t      memcpy ((caddr_t) buf, oa->oa_base, oa->oa_length);\n\t      buf = (int32_t *) ((char *) buf + RNDUP (oa->oa_length));\n\t    }\n\t  oa = &cmsg->rm_call.cb_verf;\n\t  (void) IXDR_PUT_ENUM (buf, oa->oa_flavor);\n\t  (void) IXDR_PUT_INT32 (buf, oa->oa_length);\n\t  if (oa->oa_length)\n\t    {\n\t      memcpy ((caddr_t) buf, oa->oa_base, oa->oa_length);\n\t      /* no real need....\n\t\t buf = (long *) ((char *) buf + RNDUP(oa->oa_length));\n\t       */\n\t    }\n\t  return TRUE;\n\t}\n    }\n  if (xdrs->x_op == XDR_DECODE)\n    {\n      buf = XDR_INLINE (xdrs, 8 * BYTES_PER_XDR_UNIT);\n      if (buf != NULL)\n\t{\n\t  cmsg->rm_xid = IXDR_GET_LONG (buf);\n\t  cmsg->rm_direction = IXDR_GET_ENUM (buf, enum msg_type);\n\t  if (cmsg->rm_direction != CALL)\n\t    {\n\t      return FALSE;\n\t    }\n\t  cmsg->rm_call.cb_rpcvers = IXDR_GET_LONG (buf);\n\t  if (cmsg->rm_call.cb_rpcvers != RPC_MSG_VERSION)\n\t    {\n\t      return FALSE;\n\t    }\n\t  cmsg->rm_call.cb_prog = IXDR_GET_LONG (buf);\n\t  cmsg->rm_call.cb_vers = IXDR_GET_LONG (buf);\n\t  cmsg->rm_call.cb_proc = IXDR_GET_LONG (buf);\n\t  oa = &cmsg->rm_call.cb_cred;\n\t  oa->oa_flavor = IXDR_GET_ENUM (buf, enum_t);\n\t  oa->oa_length = IXDR_GET_INT32 (buf);\n\t  if (oa->oa_length)\n\t    {\n\t      if (oa->oa_length > MAX_AUTH_BYTES)\n\t\treturn FALSE;\n\t      if (oa->oa_base == NULL)\n\t\t{\n\t\t  oa->oa_base = (caddr_t)\n\t\t    mem_alloc (oa->oa_length);\n\t\t}\n\t      buf = XDR_INLINE (xdrs, RNDUP (oa->oa_length));\n\t      if (buf == NULL)\n\t\t{\n\t\t  if (xdr_opaque (xdrs, oa->oa_base,\n\t\t\t\t  oa->oa_length) == FALSE)\n\t\t    return FALSE;\n\t\t}\n\t      else\n\t\t{\n\t\t  memcpy (oa->oa_base, (caddr_t) buf, oa->oa_length);\n\t\t  /* no real need....\n\t\t     buf = (long *) ((char *) buf\n\t\t     + RNDUP(oa->oa_length));\n\t\t   */\n\t\t}\n\t    }\n\t  oa = &cmsg->rm_call.cb_verf;\n\t  buf = XDR_INLINE (xdrs, 2 * BYTES_PER_XDR_UNIT);\n\t  if (buf == NULL)\n\t    {\n\t      if (xdr_enum (xdrs, &oa->oa_flavor) == FALSE ||\n\t\t  xdr_u_int (xdrs, &oa->oa_length) == FALSE)\n\t\t{\n\t\t  return FALSE;\n\t\t}\n\t    }\n\t  else\n\t    {\n\t      oa->oa_flavor = IXDR_GET_ENUM (buf, enum_t);\n\t      oa->oa_length = IXDR_GET_INT32 (buf);\n\t    }\n\t  if (oa->oa_length)\n\t    {\n\t      if (oa->oa_length > MAX_AUTH_BYTES)\n\t\treturn FALSE;\n\t      if (oa->oa_base == NULL)\n\t\t{\n\t\t  oa->oa_base = (caddr_t)\n\t\t    mem_alloc (oa->oa_length);\n\t\t}\n\t      buf = XDR_INLINE (xdrs, RNDUP (oa->oa_length));\n\t      if (buf == NULL)\n\t\t{\n\t\t  if (xdr_opaque (xdrs, oa->oa_base,\n\t\t\t\t  oa->oa_length) == FALSE)\n\t\t    return FALSE;\n\t\t}\n\t      else\n\t\t{\n\t\t  memcpy (oa->oa_base, (caddr_t) buf, oa->oa_length);\n\t\t  /* no real need...\n\t\t     buf = (long *) ((char *) buf\n\t\t     + RNDUP(oa->oa_length));\n\t\t   */\n\t\t}\n\t    }\n\t  return TRUE;\n\t}\n    }\n  if (\n       xdr_u_long (xdrs, &(cmsg->rm_xid)) &&\n       xdr_enum (xdrs, (enum_t *) & (cmsg->rm_direction)) &&\n       (cmsg->rm_direction == CALL) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_rpcvers)) &&\n       (cmsg->rm_call.cb_rpcvers == RPC_MSG_VERSION) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_prog)) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_vers)) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_proc)) &&\n       xdr_opaque_auth (xdrs, &(cmsg->rm_call.cb_cred)))\n    return xdr_opaque_auth (xdrs, &(cmsg->rm_call.cb_verf));\n  return FALSE;\n}",
    "_rpc_dtablesize": "_rpc_dtablesize (void){\n  static int size;\n\n  if (size == 0)\n    size = __getdtablesize ();\n\n  return size;\n}",
    "xdr_opaque_auth": "xdr_opaque_auth (XDR *xdrs, struct opaque_auth *ap){\n\n  if (xdr_enum (xdrs, &(ap->oa_flavor)))\n    return xdr_bytes (xdrs, &ap->oa_base,\n\t\t      &ap->oa_length, MAX_AUTH_BYTES);\n  return FALSE;\n}",
    "xdr_des_block": "xdr_des_block (XDR *xdrs, des_block *blkp){\n  return xdr_opaque (xdrs, (caddr_t) blkp, sizeof (des_block));\n}",
    "xdr_accepted_reply": "xdr_accepted_reply (XDR *xdrs, struct accepted_reply *ar){\n  /* personalized union, rather than calling xdr_union */\n  if (!xdr_opaque_auth (xdrs, &(ar->ar_verf)))\n    return FALSE;\n  if (!xdr_enum (xdrs, (enum_t *) & (ar->ar_stat)))\n    return FALSE;\n  switch (ar->ar_stat)\n    {\n    case SUCCESS:\n      return ((*(ar->ar_results.proc)) (xdrs, ar->ar_results.where));\n    case PROG_MISMATCH:\n      if (!xdr_u_long (xdrs, &(ar->ar_vers.low)))\n\treturn FALSE;\n      return (xdr_u_long (xdrs, &(ar->ar_vers.high)));\n    default:\n      return TRUE;\n    }\n  return TRUE;\t\t/* TRUE => open ended set of problems */\n}",
    "xdr_rejected_reply": "xdr_rejected_reply (XDR *xdrs, struct rejected_reply *rr){\n  /* personalized union, rather than calling xdr_union */\n  if (!xdr_enum (xdrs, (enum_t *) & (rr->rj_stat)))\n    return FALSE;\n  switch (rr->rj_stat)\n    {\n    case RPC_MISMATCH:\n      if (!xdr_u_long (xdrs, &(rr->rj_vers.low)))\n\treturn FALSE;\n      return xdr_u_long (xdrs, &(rr->rj_vers.high));\n\n    case AUTH_ERROR:\n      return xdr_enum (xdrs, (enum_t *) & (rr->rj_why));\n    }\n  return FALSE;\n}",
    "xdr_replymsg": "xdr_replymsg (XDR *xdrs, struct rpc_msg *rmsg){\n  if (xdr_u_long (xdrs, &(rmsg->rm_xid)) &&\n      xdr_enum (xdrs, (enum_t *) & (rmsg->rm_direction)) &&\n      (rmsg->rm_direction == REPLY))\n    return xdr_union (xdrs, (enum_t *) & (rmsg->rm_reply.rp_stat),\n\t\t      (caddr_t) & (rmsg->rm_reply.ru), reply_dscrm,\n\t\t      NULL_xdrproc_t);\n  return FALSE;\n}",
    "xdr_callhdr": "xdr_callhdr (XDR *xdrs, struct rpc_msg *cmsg){\n\n  cmsg->rm_direction = CALL;\n  cmsg->rm_call.cb_rpcvers = RPC_MSG_VERSION;\n  if (\n       (xdrs->x_op == XDR_ENCODE) &&\n       xdr_u_long (xdrs, &(cmsg->rm_xid)) &&\n       xdr_enum (xdrs, (enum_t *) & (cmsg->rm_direction)) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_rpcvers)) &&\n       xdr_u_long (xdrs, &(cmsg->rm_call.cb_prog)))\n    return xdr_u_long (xdrs, &(cmsg->rm_call.cb_vers));\n  return FALSE;\n}",
    "_seterr_reply": "_seterr_reply (struct rpc_msg *msg,\n\t       struct rpc_err *error){\n  /* optimized for normal, SUCCESSful case */\n  switch (msg->rm_reply.rp_stat)\n    {\n    case MSG_ACCEPTED:\n      if (msg->acpted_rply.ar_stat == SUCCESS)\n\t{\n\t  error->re_status = RPC_SUCCESS;\n\t  return;\n\t};\n      accepted (msg->acpted_rply.ar_stat, error);\n      break;\n\n    case MSG_DENIED:\n      rejected (msg->rjcted_rply.rj_stat, error);\n      break;\n\n    default:\n      error->re_status = RPC_FAILED;\n      error->re_lb.s1 = (long) (msg->rm_reply.rp_stat);\n      break;\n    }\n  switch (error->re_status)\n    {\n\n    case RPC_VERSMISMATCH:\n      error->re_vers.low = msg->rjcted_rply.rj_vers.low;\n      error->re_vers.high = msg->rjcted_rply.rj_vers.high;\n      break;\n\n    case RPC_AUTHERROR:\n      error->re_why = msg->rjcted_rply.rj_why;\n      break;\n\n    case RPC_PROGVERSMISMATCH:\n      error->re_vers.low = msg->acpted_rply.ar_vers.low;\n      error->re_vers.high = msg->acpted_rply.ar_vers.high;\n      break;\n    default:\n      break;\n    }\n}",
    "__rpc_thread_svc_fdset": "*\n__rpc_thread_svc_fdset (void){\n\tstruct rpc_thread_variables *tvp;\n\n\ttvp = __rpc_thread_variables ();\n\tif (tvp == &__libc_tsd_RPC_VARS_mem)\n\t\treturn &svc_fdset;\n\treturn &tvp->svc_fdset_s;\n}",
    "__rpc_thread_createerr": "*\n__rpc_thread_createerr (void){\n\tstruct rpc_thread_variables *tvp;\n\n\ttvp = __rpc_thread_variables ();\n\tif (tvp == &__libc_tsd_RPC_VARS_mem)\n\t\treturn &rpc_createerr;\n\treturn &tvp->rpc_createerr_s;\n}",
    "__rpc_thread_svc_pollfd": "**\n__rpc_thread_svc_pollfd (void){\n\tstruct rpc_thread_variables *tvp;\n\n\ttvp = __rpc_thread_variables ();\n\tif (tvp == &__libc_tsd_RPC_VARS_mem)\n\t\treturn &svc_pollfd;\n\treturn &tvp->svc_pollfd_s;\n}",
    "__rpc_thread_svc_max_pollfd": "#endif\n\nint *\n__rpc_thread_svc_max_pollfd (void){\n\tstruct rpc_thread_variables *tvp;\n\n\ttvp = __rpc_thread_variables ();\n\tif (tvp == &__libc_tsd_RPC_VARS_mem)\n\t\treturn &svc_max_pollfd;\n\treturn &tvp->svc_max_pollfd_s;\n}",
    "rtime": "rtime (struct sockaddr_in *addrp, struct rpc_timeval *timep,\n       struct rpc_timeval *timeout){\n  int s;\n  struct pollfd fd;\n  int milliseconds;\n  int res;\n  /* RFC 868 says the time is transmitted as a 32-bit value.  */\n  uint32_t thetime;\n  struct sockaddr_in from;\n  socklen_t fromlen;\n  int type;\n\n  if (timeout == NULL)\n    type = SOCK_STREAM;\n  else\n    type = SOCK_DGRAM;\n\n  s = __socket (AF_INET, type, 0);\n  if (s < 0)\n    return (-1);\n\n  addrp->sin_family = AF_INET;\n  addrp->sin_port = htons (IPPORT_TIMESERVER);\n  if (type == SOCK_DGRAM)\n    {\n      res = __sendto (s, (char *) &thetime, sizeof (thetime), 0,\n\t\t      (struct sockaddr *) addrp, sizeof (*addrp));\n      if (res < 0)\n\t{\n\t  do_close (s);\n\t  return -1;\n\t}\n      milliseconds = (timeout->tv_sec * 1000) + (timeout->tv_usec / 1000);\n      fd.fd = s;\n      fd.events = POLLIN;\n      do\n\tres = __poll (&fd, 1, milliseconds);\n      while (res < 0 && errno == EINTR);\n      if (res <= 0)\n\t{\n\t  if (res == 0)\n\t    __set_errno (ETIMEDOUT);\n\t  do_close (s);\n\t  return (-1);\n\t}\n      fromlen = sizeof (from);\n      res = __recvfrom (s, (char *) &thetime, sizeof (thetime), 0,\n\t\t\t(struct sockaddr *) &from, &fromlen);\n      do_close (s);\n      if (res < 0)\n\treturn -1;\n    }\n  else\n    {\n      if (__connect (s, (struct sockaddr *) addrp, sizeof (*addrp)) < 0)\n\t{\n\t  do_close (s);\n\t  return -1;\n\t}\n      res = __read (s, (char *) &thetime, sizeof (thetime));\n      do_close (s);\n      if (res < 0)\n\treturn (-1);\n    }\n  if (res != sizeof (thetime))\n    {\n      __set_errno (EIO);\n      return -1;\n    }\n  thetime = ntohl (thetime);\n  timep->tv_sec = thetime - TOFFSET;\n  timep->tv_usec = 0;\n  return 0;\n}",
    "xprt_register": "xprt_register (SVCXPRT *xprt){\n  register int sock = xprt->xp_sock;\n  register int i;\n\n  if (xports == NULL)\n    {\n      xports = (SVCXPRT **) calloc (_rpc_dtablesize (), sizeof (SVCXPRT *));\n      if (xports == NULL) /* Don't add handle */\n\treturn;\n    }\n\n  if (sock < _rpc_dtablesize ())\n    {\n      struct pollfd *new_svc_pollfd;\n\n      xports[sock] = xprt;\n      if (sock < FD_SETSIZE)\n\tFD_SET (sock, &svc_fdset);\n\n      /* Check if we have an empty slot */\n      for (i = 0; i < svc_max_pollfd; ++i)\n\tif (svc_pollfd[i].fd == -1)\n\t  {\n\t    svc_pollfd[i].fd = sock;\n\t    svc_pollfd[i].events = (POLLIN | POLLPRI |\n\t\t\t\t    POLLRDNORM | POLLRDBAND);\n\t    return;\n\t  }\n\n      new_svc_pollfd = (struct pollfd *) realloc (svc_pollfd,\n\t\t\t\t\t\t  sizeof (struct pollfd)\n\t\t\t\t\t\t  * (svc_max_pollfd + 1));\n      if (new_svc_pollfd == NULL) /* Out of memory */\n\treturn;\n      svc_pollfd = new_svc_pollfd;\n      ++svc_max_pollfd;\n\n      svc_pollfd[svc_max_pollfd - 1].fd = sock;\n      svc_pollfd[svc_max_pollfd - 1].events = (POLLIN | POLLPRI |\n\t\t\t\t\t       POLLRDNORM | POLLRDBAND);\n    }\n}",
    "xprt_unregister": "xprt_unregister (SVCXPRT *xprt){\n  register int sock = xprt->xp_sock;\n  register int i;\n\n  if ((sock < _rpc_dtablesize ()) && (xports[sock] == xprt))\n    {\n      xports[sock] = (SVCXPRT *) 0;\n\n      if (sock < FD_SETSIZE)\n\tFD_CLR (sock, &svc_fdset);\n\n      for (i = 0; i < svc_max_pollfd; ++i)\n\tif (svc_pollfd[i].fd == sock)\n\t  svc_pollfd[i].fd = -1;\n    }\n}",
    "svc_register": "svc_register (SVCXPRT * xprt, rpcprog_t prog, rpcvers_t vers,\n\t      void (*dispatch) (struct svc_req *, SVCXPRT *),\n\t      rpcproc_t protocol){\n  struct svc_callout *prev;\n  register struct svc_callout *s;\n\n  if ((s = svc_find (prog, vers, &prev)) != NULL_SVC)\n    {\n      if (s->sc_dispatch == dispatch)\n\tgoto pmap_it;\t\t/* he is registering another xptr */\n      return FALSE;\n    }\n  s = (struct svc_callout *) mem_alloc (sizeof (struct svc_callout));\n  if (s == (struct svc_callout *) 0)\n    return FALSE;\n\n  s->sc_prog = prog;\n  s->sc_vers = vers;\n  s->sc_dispatch = dispatch;\n  s->sc_next = svc_head;\n  s->sc_mapped = FALSE;\n  svc_head = s;\n\npmap_it:\n  /* now register the information with the local binder service */\n  if (protocol)\n    {\n      if (! pmap_set (prog, vers, protocol, xprt->xp_port))\n\treturn FALSE;\n\n      s->sc_mapped = TRUE;\n    }\n\n  return TRUE;\n}",
    "svc_unregister": "void\nsvc_unregister (rpcprog_t prog, rpcvers_t vers){\n  struct svc_callout *prev;\n  register struct svc_callout *s;\n\n  if ((s = svc_find (prog, vers, &prev)) == NULL_SVC)\n    return;\n  bool is_mapped = s->sc_mapped;\n\n  if (prev == NULL_SVC)\n    svc_head = s->sc_next;\n  else\n    prev->sc_next = s->sc_next;\n\n  s->sc_next = NULL_SVC;\n  mem_free ((char *) s, (u_int) sizeof (struct svc_callout));\n  /* now unregister the information with the local binder service */\n  if (is_mapped)\n    pmap_unset (prog, vers);\n}",
    "svc_sendreply": "svc_sendreply (register SVCXPRT *xprt, xdrproc_t xdr_results,\n\t       caddr_t xdr_location){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_ACCEPTED;\n  rply.acpted_rply.ar_verf = xprt->xp_verf;\n  rply.acpted_rply.ar_stat = SUCCESS;\n  rply.acpted_rply.ar_results.where = xdr_location;\n  rply.acpted_rply.ar_results.proc = xdr_results;\n  return SVC_REPLY (xprt, &rply);\n}",
    "svcerr_noproc": "void\nsvcerr_noproc (register SVCXPRT *xprt){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_ACCEPTED;\n  rply.acpted_rply.ar_verf = xprt->xp_verf;\n  rply.acpted_rply.ar_stat = PROC_UNAVAIL;\n  SVC_REPLY (xprt, &rply);\n}",
    "svcerr_decode": "void\nsvcerr_decode (register SVCXPRT *xprt){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_ACCEPTED;\n  rply.acpted_rply.ar_verf = xprt->xp_verf;\n  rply.acpted_rply.ar_stat = GARBAGE_ARGS;\n  SVC_REPLY (xprt, &rply);\n}",
    "svcerr_systemerr": "void\nsvcerr_systemerr (register SVCXPRT *xprt){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_ACCEPTED;\n  rply.acpted_rply.ar_verf = xprt->xp_verf;\n  rply.acpted_rply.ar_stat = SYSTEM_ERR;\n  SVC_REPLY (xprt, &rply);\n}",
    "svcerr_auth": "void\nsvcerr_auth (SVCXPRT *xprt, enum auth_stat why){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_DENIED;\n  rply.rjcted_rply.rj_stat = AUTH_ERROR;\n  rply.rjcted_rply.rj_why = why;\n  SVC_REPLY (xprt, &rply);\n}",
    "svcerr_weakauth": "svcerr_weakauth (SVCXPRT *xprt){\n  svcerr_auth (xprt, AUTH_TOOWEAK);\n}",
    "svcerr_noprog": "svcerr_noprog (register SVCXPRT *xprt){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_ACCEPTED;\n  rply.acpted_rply.ar_verf = xprt->xp_verf;\n  rply.acpted_rply.ar_stat = PROG_UNAVAIL;\n  SVC_REPLY (xprt, &rply);\n}",
    "svcerr_progvers": "svcerr_progvers (register SVCXPRT *xprt, rpcvers_t low_vers,\n\t\t rpcvers_t high_vers){\n  struct rpc_msg rply;\n\n  rply.rm_direction = REPLY;\n  rply.rm_reply.rp_stat = MSG_ACCEPTED;\n  rply.acpted_rply.ar_verf = xprt->xp_verf;\n  rply.acpted_rply.ar_stat = PROG_MISMATCH;\n  rply.acpted_rply.ar_vers.low = low_vers;\n  rply.acpted_rply.ar_vers.high = high_vers;\n  SVC_REPLY (xprt, &rply);\n}",
    "svc_getreq": "svc_getreq (int rdfds){\n  fd_set readfds;\n\n  FD_ZERO (&readfds);\n  readfds.fds_bits[0] = rdfds;\n  svc_getreqset (&readfds);\n}",
    "svc_getreqset": "svc_getreqset (fd_set *readfds){\n  register fd_mask mask;\n  register fd_mask *maskp;\n  register int setsize;\n  register int sock;\n  register int bit;\n\n  setsize = _rpc_dtablesize ();\n  if (setsize > FD_SETSIZE)\n    setsize = FD_SETSIZE;\n  maskp = readfds->fds_bits;\n  for (sock = 0; sock < setsize; sock += NFDBITS)\n    for (mask = *maskp++; (bit = ffsl (mask)); mask ^= (1L << (bit - 1)))\n      svc_getreq_common (sock + bit - 1);\n}",
    "svc_getreq_poll": "svc_getreq_poll (struct pollfd *pfdp, int pollretval){\n  if (pollretval == 0)\n    return;\n\n  register int fds_found;\n  for (int i = fds_found = 0; i < svc_max_pollfd; ++i)\n    {\n      register struct pollfd *p = &pfdp[i];\n\n      if (p->fd != -1 && p->revents)\n\t{\n\t  /* fd has input waiting */\n\t  if (p->revents & POLLNVAL)\n\t    xprt_unregister (xports[p->fd]);\n\t  else\n\t    svc_getreq_common (p->fd);\n\n\t  if (++fds_found >= pollretval)\n\t    break;\n\t}\n    }\n}",
    "svc_getreq_common": "#endif\n\n\nvoid\nsvc_getreq_common (const int fd){\n  enum xprt_stat stat;\n  struct rpc_msg msg;\n  register SVCXPRT *xprt;\n  char cred_area[2 * MAX_AUTH_BYTES + RQCRED_SIZE];\n  msg.rm_call.cb_cred.oa_base = cred_area;\n  msg.rm_call.cb_verf.oa_base = &(cred_area[MAX_AUTH_BYTES]);\n\n  xprt = xports[fd];\n  /* Do we control fd? */\n  if (xprt == NULL)\n     return;\n\n  /* now receive msgs from xprtprt (support batch calls) */\n  do\n    {\n      if (SVC_RECV (xprt, &msg))\n\t{\n\t  /* now find the exported program and call it */\n\t  struct svc_callout *s;\n\t  struct svc_req r;\n\t  enum auth_stat why;\n\t  rpcvers_t low_vers;\n\t  rpcvers_t high_vers;\n\t  int prog_found;\n\n\t  r.rq_clntcred = &(cred_area[2 * MAX_AUTH_BYTES]);\n\t  r.rq_xprt = xprt;\n\t  r.rq_prog = msg.rm_call.cb_prog;\n\t  r.rq_vers = msg.rm_call.cb_vers;\n\t  r.rq_proc = msg.rm_call.cb_proc;\n\t  r.rq_cred = msg.rm_call.cb_cred;\n\n\t  /* first authenticate the message */\n\t  /* Check for null flavor and bypass these calls if possible */\n\n\t  if (msg.rm_call.cb_cred.oa_flavor == AUTH_NULL)\n\t    {\n\t      r.rq_xprt->xp_verf.oa_flavor = _null_auth.oa_flavor;\n\t      r.rq_xprt->xp_verf.oa_length = 0;\n\t    }\n\t  else if ((why = _authenticate (&r, &msg)) != AUTH_OK)\n\t    {\n\t      svcerr_auth (xprt, why);\n\t      goto call_done;\n\t    }\n\n\t  /* now match message with a registered service */\n\t  prog_found = FALSE;\n\t  low_vers = 0 - 1;\n\t  high_vers = 0;\n\n\t  for (s = svc_head; s != NULL_SVC; s = s->sc_next)\n\t    {\n\t      if (s->sc_prog == r.rq_prog)\n\t\t{\n\t\t  if (s->sc_vers == r.rq_vers)\n\t\t    {\n\t\t      (*s->sc_dispatch) (&r, xprt);\n\t\t      goto call_done;\n\t\t    }\n\t\t  /* found correct version */\n\t\t  prog_found = TRUE;\n\t\t  if (s->sc_vers < low_vers)\n\t\t    low_vers = s->sc_vers;\n\t\t  if (s->sc_vers > high_vers)\n\t\t    high_vers = s->sc_vers;\n\t\t}\n\t      /* found correct program */\n\t    }\n\t  /* if we got here, the program or version\n\t     is not served ... */\n\t  if (prog_found)\n\t    svcerr_progvers (xprt, low_vers, high_vers);\n\t  else\n\t    svcerr_noprog (xprt);\n\t  /* Fall through to ... */\n\t}\n    call_done:\n      if ((stat = SVC_STAT (xprt)) == XPRT_DIED)\n\t{\n\t  SVC_DESTROY (xprt);\n\t  break;\n\t}\n    }\n  while (stat == XPRT_MOREREQS);\n}",
    "_authenticate": "_authenticate (register struct svc_req *rqst, struct rpc_msg *msg){\n  register int cred_flavor;\n\n  rqst->rq_cred = msg->rm_call.cb_cred;\n  rqst->rq_xprt->xp_verf.oa_flavor = _null_auth.oa_flavor;\n  rqst->rq_xprt->xp_verf.oa_length = 0;\n  cred_flavor = rqst->rq_cred.oa_flavor;\n  if ((cred_flavor <= AUTH_MAX) && (cred_flavor >= AUTH_NULL))\n    return (*(svcauthsw[cred_flavor].authenticator)) (rqst, msg);\n\n  return AUTH_REJECTEDCRED;\n}",
    "svcraw_create": "*\nsvcraw_create (void){\n  struct svcraw_private_s *srp = svcraw_private;\n\n  if (srp == 0)\n    {\n      srp = (struct svcraw_private_s *) calloc (1, sizeof (*srp));\n      if (srp == 0)\n\treturn NULL;\n    }\n  srp->server.xp_sock = 0;\n  srp->server.xp_port = 0;\n  srp->server.xp_ops = (struct xp_ops *) &server_ops;\n  srp->server.xp_verf.oa_base = srp->verf_body;\n  xdrmem_create (&srp->xdr_stream, srp->_raw_buf, UDPMSGSIZE, XDR_FREE);\n  return &srp->server;\n}",
    "svc_exit": "svc_exit (void){\n  free (svc_pollfd);\n  svc_pollfd = NULL;\n  svc_max_pollfd = 0;\n}",
    "svc_run": "svc_run (void){\n  int i;\n  struct pollfd *my_pollfd = NULL;\n  int last_max_pollfd = 0;\n\n  for (;;)\n    {\n      int max_pollfd = svc_max_pollfd;\n      if (max_pollfd == 0 && svc_pollfd == NULL)\n\tbreak;\n\n      if (last_max_pollfd != max_pollfd)\n\t{\n\t  struct pollfd *new_pollfd\n\t    = realloc (my_pollfd, sizeof (struct pollfd) * max_pollfd);\n\n\t  if (new_pollfd == NULL)\n\t    {\n\t      perror (_(\"svc_run: - out of memory\"));\n\t      break;\n\t    }\n\n\t  my_pollfd = new_pollfd;\n\t  last_max_pollfd = max_pollfd;\n\t}\n\n      for (i = 0; i < max_pollfd; ++i)\n\t{\n\t  my_pollfd[i].fd = svc_pollfd[i].fd;\n\t  my_pollfd[i].events = svc_pollfd[i].events;\n\t  my_pollfd[i].revents = 0;\n\t}\n\n      switch (i = __poll (my_pollfd, max_pollfd, -1))\n\t{\n\tcase -1:\n\t  if (errno == EINTR)\n\t    continue;\n\t  perror (_(\"svc_run: - poll failed\"));\n\t  break;\n\tcase 0:\n\t  continue;\n\tdefault:\n\t  svc_getreq_poll (my_pollfd, i);\n\t  continue;\n\t}\n      break;\n    }\n\n  free (my_pollfd);\n}",
    "svctcp_create": "*\nsvctcp_create (int sock, u_int sendsize, u_int recvsize){\n  bool_t madesock = FALSE;\n  SVCXPRT *xprt;\n  struct tcp_rendezvous *r;\n  struct sockaddr_in addr;\n  socklen_t len = sizeof (struct sockaddr_in);\n\n  if (sock == RPC_ANYSOCK)\n    {\n      if ((sock = __socket (AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)\n\t{\n\t  perror (_(\"svc_tcp.c - tcp socket creation problem\"));\n\t  return (SVCXPRT *) NULL;\n\t}\n      madesock = TRUE;\n    }\n  memset ((char *) &addr, 0, sizeof (addr));\n  addr.sin_family = AF_INET;\n  if (bindresvport (sock, &addr))\n    {\n      addr.sin_port = 0;\n      (void) __bind (sock, (struct sockaddr *) &addr, len);\n    }\n  if ((__getsockname (sock, (struct sockaddr *) &addr, &len) != 0) ||\n      (__listen (sock, SOMAXCONN) != 0))\n    {\n      perror (_(\"svc_tcp.c - cannot getsockname or listen\"));\n      if (madesock)\n\t(void) __close (sock);\n      return (SVCXPRT *) NULL;\n    }\n  r = (struct tcp_rendezvous *) mem_alloc (sizeof (*r));\n  xprt = (SVCXPRT *) mem_alloc (sizeof (SVCXPRT));\n  if (r == NULL || xprt == NULL)\n    {\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (r, sizeof (*r));\n      mem_free (xprt, sizeof (SVCXPRT));\n      return NULL;\n    }\n  r->sendsize = sendsize;\n  r->recvsize = recvsize;\n  xprt->xp_p2 = NULL;\n  xprt->xp_p1 = (caddr_t) r;\n  xprt->xp_verf = _null_auth;\n  xprt->xp_ops = &svctcp_rendezvous_op;\n  xprt->xp_port = ntohs (addr.sin_port);\n  xprt->xp_sock = sock;\n  xprt_register (xprt);\n  return xprt;\n}",
    "svcfd_create": "SVCXPRT *\nsvcfd_create (int fd, u_int sendsize, u_int recvsize){\n  return makefd_xprt (fd, sendsize, recvsize);\n}",
    "svcudp_bufcreate": "*\nsvcudp_bufcreate (int sock, u_int sendsz, u_int recvsz){\n  bool_t madesock = FALSE;\n  SVCXPRT *xprt;\n  struct svcudp_data *su;\n  struct sockaddr_in addr;\n  socklen_t len = sizeof (struct sockaddr_in);\n  int pad;\n  void *buf;\n\n  if (sock == RPC_ANYSOCK)\n    {\n      if ((sock = __socket (AF_INET, SOCK_DGRAM, IPPROTO_UDP)) < 0)\n\t{\n\t  perror (_(\"svcudp_create: socket creation problem\"));\n\t  return (SVCXPRT *) NULL;\n\t}\n      madesock = TRUE;\n    }\n  memset ((char *) &addr, 0, sizeof (addr));\n  addr.sin_family = AF_INET;\n  if (bindresvport (sock, &addr))\n    {\n      addr.sin_port = 0;\n      (void) __bind (sock, (struct sockaddr *) &addr, len);\n    }\n  if (__getsockname (sock, (struct sockaddr *) &addr, &len) != 0)\n    {\n      perror (_(\"svcudp_create - cannot getsockname\"));\n      if (madesock)\n\t(void) __close (sock);\n      return (SVCXPRT *) NULL;\n    }\n  xprt = (SVCXPRT *) mem_alloc (sizeof (SVCXPRT));\n  su = (struct svcudp_data *) mem_alloc (sizeof (*su));\n  buf = mem_alloc (((MAX (sendsz, recvsz) + 3) / 4) * 4);\n  if (xprt == NULL || su == NULL || buf == NULL)\n    {\n      (void) __fxprintf (NULL, \"%s: %s\",\n\t\t\t \"svcudp_create\",  _(\"out of memory\\n\"));\n      mem_free (xprt, sizeof (SVCXPRT));\n      mem_free (su, sizeof (*su));\n      mem_free (buf, ((MAX (sendsz, recvsz) + 3) / 4) * 4);\n      return NULL;\n    }\n  su->su_iosz = ((MAX (sendsz, recvsz) + 3) / 4) * 4;\n  rpc_buffer (xprt) = buf;\n  xdrmem_create (&(su->su_xdrs), rpc_buffer (xprt), su->su_iosz, XDR_DECODE);\n  su->su_cache = NULL;\n  xprt->xp_p2 = (caddr_t) su;\n  xprt->xp_verf.oa_base = su->su_verfbody;\n  xprt->xp_ops = &svcudp_op;\n  xprt->xp_port = ntohs (addr.sin_port);\n  xprt->xp_sock = sock;\n\n#ifdef IP_PKTINFO\n  if ((sizeof (struct iovec) + sizeof (struct msghdr)\n       + sizeof(struct cmsghdr) + sizeof (struct in_pktinfo))\n      > sizeof (xprt->xp_pad))\n    {\n      (void) __fxprintf (NULL,\"%s\", _(\"\\\nsvcudp_create: xp_pad is too small for IP_PKTINFO\\n\"));\n      return NULL;\n    }\n  pad = 1;\n  if (__setsockopt (sock, SOL_IP, IP_PKTINFO, (void *) &pad,\n\t\t    sizeof (pad)) == 0)\n    /* Set the padding to all 1s. */\n    pad = 0xff;\n  else\n#endif\n    /* Clear the padding. */\n    pad = 0;\n  memset (&xprt->xp_pad [0], pad, sizeof (xprt->xp_pad));\n\n  xprt_register (xprt);\n  return xprt;\n}",
    "svcudp_create": "*\nsvcudp_create (int sock){\n  return svcudp_bufcreate (sock, UDPMSGSIZE, UDPMSGSIZE);\n}",
    "svcudp_enablecache": "svcudp_enablecache (SVCXPRT *transp, u_long size){\n  struct svcudp_data *su = su_data (transp);\n  struct udp_cache *uc;\n\n  if (su->su_cache != NULL)\n    {\n      CACHE_PERROR (_(\"enablecache: cache already enabled\"));\n      return 0;\n    }\n  uc = ALLOC (struct udp_cache, 1);\n  if (uc == NULL)\n    {\n      CACHE_PERROR (_(\"enablecache: could not allocate cache\"));\n      return 0;\n    }\n  uc->uc_size = size;\n  uc->uc_nextvictim = 0;\n  uc->uc_entries = CALLOC (cache_ptr, size * SPARSENESS);\n  if (uc->uc_entries == NULL)\n    {\n      mem_free (uc, sizeof (struct udp_cache));\n      CACHE_PERROR (_(\"enablecache: could not allocate cache data\"));\n      return 0;\n    }\n  uc->uc_fifo = CALLOC (cache_ptr, size);\n  if (uc->uc_fifo == NULL)\n    {\n      mem_free (uc->uc_entries, size * SPARSENESS);\n      mem_free (uc, sizeof (struct udp_cache));\n      CACHE_PERROR (_(\"enablecache: could not allocate cache fifo\"));\n      return 0;\n    }\n  su->su_cache = (char *) uc;\n  return 1;\n}",
    "svcunix_create": "*\nsvcunix_create (int sock, u_int sendsize, u_int recvsize, char *path){\n  bool_t madesock = FALSE;\n  SVCXPRT *xprt;\n  struct unix_rendezvous *r;\n  struct sockaddr_un addr;\n  socklen_t len = sizeof (addr);\n\n  if (__sockaddr_un_set (&addr, path) < 0)\n    return NULL;\n\n  if (sock == RPC_ANYSOCK)\n    {\n      if ((sock = __socket (AF_UNIX, SOCK_STREAM, 0)) < 0)\n\t{\n\t  perror (_(\"svc_unix.c - AF_UNIX socket creation problem\"));\n\t  return (SVCXPRT *) NULL;\n\t}\n      madesock = TRUE;\n    }\n  __bind (sock, (struct sockaddr *) &addr, len);\n\n  if (__getsockname (sock, (struct sockaddr *) &addr, &len) != 0\n      || __listen (sock, SOMAXCONN) != 0)\n    {\n      perror (_(\"svc_unix.c - cannot getsockname or listen\"));\n      if (madesock)\n\t__close (sock);\n      return (SVCXPRT *) NULL;\n    }\n\n  r = (struct unix_rendezvous *) mem_alloc (sizeof (*r));\n  xprt = (SVCXPRT *) mem_alloc (sizeof (SVCXPRT));\n  if (r == NULL || xprt == NULL)\n    {\n      __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (r, sizeof (*r));\n      mem_free (xprt, sizeof (SVCXPRT));\n      return NULL;\n    }\n  r->sendsize = sendsize;\n  r->recvsize = recvsize;\n  xprt->xp_p2 = NULL;\n  xprt->xp_p1 = (caddr_t) r;\n  xprt->xp_verf = _null_auth;\n  xprt->xp_ops = &svcunix_rendezvous_op;\n  xprt->xp_port = -1;\n  xprt->xp_sock = sock;\n  xprt_register (xprt);\n  return xprt;\n}",
    "svcunixfd_create": "*\nsvcunixfd_create (int fd, u_int sendsize, u_int recvsize){\n  return makefd_xprt (fd, sendsize, recvsize);\n}",
    "authdes_getucred": "authdes_getucred (const struct authdes_cred *adc, uid_t * uid, gid_t * gid,\n\t\t  short *grouplen, gid_t * groups){\n  unsigned sid;\n  register int i;\n  uid_t i_uid;\n  gid_t i_gid;\n  int i_grouplen;\n  struct bsdcred *cred;\n\n  sid = adc->adc_nickname;\n  if (sid >= AUTHDES_CACHESZ)\n    {\n      debug (\"invalid nickname\");\n      return 0;\n    }\n  cred = (struct bsdcred *) authdes_cache[sid].localcred;\n  if (cred == NULL || cred->grouplen == INVALID)\n    {\n      /*\n       * not in cache: lookup\n       */\n      if (!netname2user (adc->adc_fullname.name, &i_uid, &i_gid,\n\t\t\t &i_grouplen, groups))\n\t{\n\t  debug (\"unknown netname\");\n\t  if (cred != NULL)\n\t    cred->grouplen = UNKNOWN;\t/* mark as lookup up, but not found */\n\t  return 0;\n\t}\n\n      if (cred != NULL && cred->grouplen_max < i_grouplen)\n\t{\n\t  /* We already have an allocated data structure.  But it is\n\t     too small.  */\n\t  free (cred);\n\t  authdes_cache[sid].localcred = NULL;\n\t  cred = NULL;\n\t}\n\n      if (cred == NULL)\n\t{\n\t  /* We should allocate room for at least NGROUPS groups.  */\n\t  int ngroups_max = MAX (i_grouplen, NGROUPS);\n\n\t  cred = (struct bsdcred *) mem_alloc (sizeof (struct bsdcred)\n\t\t\t\t\t       + ngroups_max * sizeof (gid_t));\n\t  if (cred == NULL)\n\t    return 0;\n\n\t  authdes_cache[sid].localcred = (char *) cred;\n\t  cred->grouplen = INVALID;\n\t  cred->grouplen_max = ngroups_max;\n\t}\n\n      debug (\"missed ucred cache\");\n      *uid = cred->uid = i_uid;\n      *gid = cred->gid = i_gid;\n      cred->grouplen = i_grouplen;\n      for (i = i_grouplen - 1; i >= 0; --i)\n\tcred->groups[i] = groups[i];\n      /* Make sure no too large values are reported.  */\n      *grouplen = MIN (SHRT_MAX, i_grouplen);\n      return 1;\n    }\n  else if (cred->grouplen == UNKNOWN)\n    {\n      /*\n       * Already lookup up, but no match found\n       */\n      return 0;\n    }\n\n  /*\n   * cached credentials\n   */\n  *uid = cred->uid;\n  *gid = cred->gid;\n\n  /* Another stupidity in the interface: *grouplen is of type short.\n     So we might have to cut the information passed up short.  */\n  int grouplen_copy = MIN (SHRT_MAX, cred->grouplen);\n  *grouplen = grouplen_copy;\n  for (i = grouplen_copy - 1; i >= 0; --i)\n    groups[i] = cred->groups[i];\n  return 1;\n}",
    "xencrypt": "xencrypt (char *secret, char *passwd){\n  char key[8];\n  char ivec[8];\n  char *buf;\n  int err;\n  int len;\n\n  len = strlen (secret) / 2;\n  buf = malloc ((unsigned) len);\n  hex2bin (len, secret, buf);\n  passwd2des_internal (passwd, key);\n  memset (ivec, 0, 8);\n\n  err = cbc_crypt (key, buf, len, DES_ENCRYPT | DES_HW, ivec);\n  if (DES_FAILED (err))\n    {\n      free (buf);\n      return 0;\n    }\n  bin2hex (len, (unsigned char *) buf, secret);\n  free (buf);\n  return 1;\n}",
    "xdecrypt": "xdecrypt (char *secret, char *passwd){\n  char key[8];\n  char ivec[8];\n  char *buf;\n  int err;\n  int len;\n\n  len = strlen (secret) / 2;\n  buf = malloc ((unsigned) len);\n\n  hex2bin (len, secret, buf);\n  passwd2des_internal (passwd, key);\n  memset (ivec, 0, 8);\n\n  err = cbc_crypt (key, buf, len, DES_DECRYPT | DES_HW, ivec);\n  if (DES_FAILED (err))\n    {\n      free (buf);\n      return 0;\n    }\n  bin2hex (len, (unsigned char *) buf, secret);\n  free (buf);\n  return 1;\n}",
    "xdr_free": "xdr_free (xdrproc_t proc, char *objp){\n  XDR x;\n\n  x.x_op = XDR_FREE;\n  (*proc) (&x, objp);\n}",
    "xdr_void": "bool_t\nxdr_void (void){\n  return TRUE;\n}",
    "xdr_int": "bool_t\nxdr_int (XDR *xdrs, int *ip){\n\n#if INT_MAX < LONG_MAX\n  long l;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      l = (long) *ip;\n      return XDR_PUTLONG (xdrs, &l);\n\n    case XDR_DECODE:\n      if (!XDR_GETLONG (xdrs, &l))\n\t{\n\t  return FALSE;\n\t}\n      *ip = (int) l;\n      /* Fall through.  */\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n#elif INT_MAX == LONG_MAX\n  return xdr_long (xdrs, (long *) ip);\n#elif INT_MAX == SHRT_MAX\n  return xdr_short (xdrs, (short *) ip);\n#else\n#error unexpected integer sizes in_xdr_int()\n#endif\n}",
    "xdr_u_int": "bool_t\nxdr_u_int (XDR *xdrs, u_int *up){\n#if UINT_MAX < ULONG_MAX\n  long l;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      l = (u_long) * up;\n      return XDR_PUTLONG (xdrs, &l);\n\n    case XDR_DECODE:\n      if (!XDR_GETLONG (xdrs, &l))\n\t{\n\t  return FALSE;\n\t}\n      *up = (u_int) (u_long) l;\n      /* Fall through.  */\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n#elif UINT_MAX == ULONG_MAX\n  return xdr_u_long (xdrs, (u_long *) up);\n#elif UINT_MAX == USHRT_MAX\n  return xdr_short (xdrs, (short *) up);\n#else\n#error unexpected integer sizes in_xdr_u_int()\n#endif\n}",
    "xdr_long": "bool_t\nxdr_long (XDR *xdrs, long *lp){\n\n  if (xdrs->x_op == XDR_ENCODE\n      && (sizeof (int32_t) == sizeof (long)\n\t  || (int32_t) *lp == *lp))\n    return XDR_PUTLONG (xdrs, lp);\n\n  if (xdrs->x_op == XDR_DECODE)\n    return XDR_GETLONG (xdrs, lp);\n\n  if (xdrs->x_op == XDR_FREE)\n    return TRUE;\n\n  return FALSE;\n}",
    "xdr_u_long": "bool_t\nxdr_u_long (XDR *xdrs, u_long *ulp){\n  switch (xdrs->x_op)\n    {\n    case XDR_DECODE:\n      {\n\tlong int tmp;\n\n\tif (XDR_GETLONG (xdrs, &tmp) == FALSE)\n\t  return FALSE;\n\n\t*ulp = (uint32_t) tmp;\n\treturn TRUE;\n      }\n\n    case XDR_ENCODE:\n      if (sizeof (uint32_t) != sizeof (u_long)\n\t  && (uint32_t) *ulp != *ulp)\n\treturn FALSE;\n\n      return XDR_PUTLONG (xdrs, (long *) ulp);\n\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_hyper": "bool_t\nxdr_hyper (XDR *xdrs, quad_t *llp){\n  long int t1, t2;\n\n  if (xdrs->x_op == XDR_ENCODE)\n    {\n      t1 = (long) ((*llp) >> 32);\n      t2 = (long) (*llp);\n      return (XDR_PUTLONG(xdrs, &t1) && XDR_PUTLONG(xdrs, &t2));\n    }\n\n  if (xdrs->x_op == XDR_DECODE)\n    {\n      if (!XDR_GETLONG(xdrs, &t1) || !XDR_GETLONG(xdrs, &t2))\n\treturn FALSE;\n      *llp = ((quad_t) t1) << 32;\n      *llp |= (uint32_t) t2;\n      return TRUE;\n    }\n\n  if (xdrs->x_op == XDR_FREE)\n    return TRUE;\n\n  return FALSE;\n}",
    "xdr_u_hyper": "bool_t\nxdr_u_hyper (XDR *xdrs, u_quad_t *ullp){\n  long int t1, t2;\n\n  if (xdrs->x_op == XDR_ENCODE)\n    {\n      t1 = (unsigned long) ((*ullp) >> 32);\n      t2 = (unsigned long) (*ullp);\n      return (XDR_PUTLONG(xdrs, &t1) && XDR_PUTLONG(xdrs, &t2));\n    }\n\n  if (xdrs->x_op == XDR_DECODE)\n    {\n      if (!XDR_GETLONG(xdrs, &t1) || !XDR_GETLONG(xdrs, &t2))\n\treturn FALSE;\n      *ullp = ((u_quad_t) t1) << 32;\n      *ullp |= (uint32_t) t2;\n      return TRUE;\n    }\n\n  if (xdrs->x_op == XDR_FREE)\n    return TRUE;\n\n  return FALSE;\n}",
    "xdr_longlong_t": "#endif\n\nbool_t\nxdr_longlong_t (XDR *xdrs, quad_t *llp){\n  return xdr_hyper (xdrs, llp);\n}",
    "xdr_u_longlong_t": "#endif\n\nbool_t\nxdr_u_longlong_t (XDR *xdrs, u_quad_t *ullp){\n  return xdr_u_hyper (xdrs, ullp);\n}",
    "xdr_short": "bool_t\nxdr_short (XDR *xdrs, short *sp){\n  long l;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      l = (long) *sp;\n      return XDR_PUTLONG (xdrs, &l);\n\n    case XDR_DECODE:\n      if (!XDR_GETLONG (xdrs, &l))\n\t{\n\t  return FALSE;\n\t}\n      *sp = (short) l;\n      return TRUE;\n\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_u_short": "bool_t\nxdr_u_short (XDR *xdrs, u_short *usp){\n  long l;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      l = (u_long) * usp;\n      return XDR_PUTLONG (xdrs, &l);\n\n    case XDR_DECODE:\n      if (!XDR_GETLONG (xdrs, &l))\n\t{\n\t  return FALSE;\n\t}\n      *usp = (u_short) (u_long) l;\n      return TRUE;\n\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_char": "bool_t\nxdr_char (XDR *xdrs, char *cp){\n  int i;\n\n  i = (*cp);\n  if (!xdr_int (xdrs, &i))\n    {\n      return FALSE;\n    }\n  *cp = i;\n  return TRUE;\n}",
    "xdr_u_char": "bool_t\nxdr_u_char (XDR *xdrs, u_char *cp){\n  u_int u;\n\n  u = (*cp);\n  if (!xdr_u_int (xdrs, &u))\n    {\n      return FALSE;\n    }\n  *cp = u;\n  return TRUE;\n}",
    "xdr_bool": "bool_t\nxdr_bool (XDR *xdrs, bool_t *bp){\n  long lb;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      lb = *bp ? XDR_TRUE : XDR_FALSE;\n      return XDR_PUTLONG (xdrs, &lb);\n\n    case XDR_DECODE:\n      if (!XDR_GETLONG (xdrs, &lb))\n\t{\n\t  return FALSE;\n\t}\n      *bp = (lb == XDR_FALSE) ? FALSE : TRUE;\n      return TRUE;\n\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_enum": "bool_t\nxdr_enum (XDR *xdrs, enum_t *ep){\n  enum sizecheck\n    {\n      SIZEVAL\n    };\t\t\t\t/* used to find the size of an enum */\n\n  /*\n   * enums are treated as ints\n   */\n  if (sizeof (enum sizecheck) == 4)\n    {\n#if INT_MAX < LONG_MAX\n      long l;\n\n      switch (xdrs->x_op)\n\t{\n\tcase XDR_ENCODE:\n\t  l = *ep;\n\t  return XDR_PUTLONG (xdrs, &l);\n\n\tcase XDR_DECODE:\n\t  if (!XDR_GETLONG (xdrs, &l))\n\t    {\n\t      return FALSE;\n\t    }\n\t  *ep = l;\n\t  /* Fall through.  */\n\tcase XDR_FREE:\n\t  return TRUE;\n\n\t}\n      return FALSE;\n#else\n      return xdr_long (xdrs, (long *) ep);\n#endif\n    }\n  else if (sizeof (enum sizecheck) == sizeof (short))\n    {\n      return xdr_short (xdrs, (short *) ep);\n    }\n  else\n    {\n      return FALSE;\n    }\n}",
    "xdr_opaque": "bool_t\nxdr_opaque (XDR *xdrs, caddr_t cp, u_int cnt){\n  u_int rndup;\n  static char crud[BYTES_PER_XDR_UNIT];\n\n  /*\n   * if no data we are done\n   */\n  if (cnt == 0)\n    return TRUE;\n\n  /*\n   * round byte count to full xdr units\n   */\n  rndup = cnt % BYTES_PER_XDR_UNIT;\n  if (rndup > 0)\n    rndup = BYTES_PER_XDR_UNIT - rndup;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_DECODE:\n      if (!XDR_GETBYTES (xdrs, cp, cnt))\n\t{\n\t  return FALSE;\n\t}\n      if (rndup == 0)\n\treturn TRUE;\n      return XDR_GETBYTES (xdrs, (caddr_t)crud, rndup);\n\n    case XDR_ENCODE:\n      if (!XDR_PUTBYTES (xdrs, cp, cnt))\n\t{\n\t  return FALSE;\n\t}\n      if (rndup == 0)\n\treturn TRUE;\n      return XDR_PUTBYTES (xdrs, xdr_zero, rndup);\n\n    case XDR_FREE:\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_bytes": "bool_t\nxdr_bytes (XDR *xdrs, char **cpp, u_int *sizep, u_int maxsize){\n  char *sp = *cpp;\t/* sp is the actual string pointer */\n  u_int nodesize;\n\n  /*\n   * first deal with the length since xdr bytes are counted\n   */\n  if (!xdr_u_int (xdrs, sizep))\n    {\n      return FALSE;\n    }\n  nodesize = *sizep;\n  if ((nodesize > maxsize) && (xdrs->x_op != XDR_FREE))\n    {\n      return FALSE;\n    }\n\n  /*\n   * now deal with the actual bytes\n   */\n  switch (xdrs->x_op)\n    {\n    case XDR_DECODE:\n      if (nodesize == 0)\n\t{\n\t  return TRUE;\n\t}\n      if (sp == NULL)\n\t{\n\t  *cpp = sp = (char *) mem_alloc (nodesize);\n\t}\n      if (sp == NULL)\n\t{\n\t  (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n\t  return FALSE;\n\t}\n      /* Fall through.  */\n\n    case XDR_ENCODE:\n      return xdr_opaque (xdrs, sp, nodesize);\n\n    case XDR_FREE:\n      if (sp != NULL)\n\t{\n\t  mem_free (sp, nodesize);\n\t  *cpp = NULL;\n\t}\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_netobj": "bool_t\nxdr_netobj (XDR *xdrs, struct netobj *np){\n\n  return xdr_bytes (xdrs, &np->n_bytes, &np->n_len, MAX_NETOBJ_SZ);\n}",
    "xdr_union": "xdr_union (XDR *xdrs,\n\t   /* enum to decide which arm to work on */\n\t   enum_t *dscmp,\n\t   /* the union itself */\n\t   char *unp,\n\t   /* [value, xdr proc] for each arm */\n\t   const struct xdr_discrim *choices,\n\t   /* default xdr routine */\n\t   xdrproc_t dfault){\n  enum_t dscm;\n\n  /*\n   * we deal with the discriminator;  it's an enum\n   */\n  if (!xdr_enum (xdrs, dscmp))\n    {\n      return FALSE;\n    }\n  dscm = *dscmp;\n\n  /*\n   * search choices for a value that matches the discriminator.\n   * if we find one, execute the xdr routine for that value.\n   */\n  for (; choices->proc != NULL_xdrproc_t; choices++)\n    {\n      if (choices->value == dscm)\n\treturn (*(choices->proc)) (xdrs, unp, LASTUNSIGNED);\n    }\n\n  /*\n   * no match - execute the default xdr routine if there is one\n   */\n  return ((dfault == NULL_xdrproc_t) ? FALSE :\n\t  (*dfault) (xdrs, unp, LASTUNSIGNED));\n}",
    "xdr_string": "xdr_string (XDR *xdrs, char **cpp, u_int maxsize){\n  char *sp = *cpp;\t/* sp is the actual string pointer */\n  /* Initialize to silence the compiler.  It is not really needed because SIZE\n     never actually gets used without being initialized.  */\n  u_int size = 0;\n  u_int nodesize;\n\n  /*\n   * first deal with the length since xdr strings are counted-strings\n   */\n  switch (xdrs->x_op)\n    {\n    case XDR_FREE:\n      if (sp == NULL)\n\t{\n\t  return TRUE;\t\t/* already free */\n\t}\n      /* fall through... */\n    case XDR_ENCODE:\n      if (sp == NULL)\n\treturn FALSE;\n      size = strlen (sp);\n      break;\n    case XDR_DECODE:\n      break;\n    }\n  if (!xdr_u_int (xdrs, &size))\n    {\n      return FALSE;\n    }\n  if (size > maxsize)\n    {\n      return FALSE;\n    }\n  nodesize = size + 1;\n  if (nodesize == 0)\n    {\n      /* This means an overflow.  It a bug in the caller which\n\t provided a too large maxsize but nevertheless catch it\n\t here.  */\n      return FALSE;\n    }\n\n  /*\n   * now deal with the actual bytes\n   */\n  switch (xdrs->x_op)\n    {\n    case XDR_DECODE:\n      if (sp == NULL)\n\t*cpp = sp = (char *) mem_alloc (nodesize);\n      if (sp == NULL)\n\t{\n\t  (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n\t  return FALSE;\n\t}\n      sp[size] = 0;\n      /* Fall through.  */\n\n    case XDR_ENCODE:\n      return xdr_opaque (xdrs, sp, size);\n\n    case XDR_FREE:\n      mem_free (sp, nodesize);\n      *cpp = NULL;\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_wrapstring": "bool_t\nxdr_wrapstring (XDR *xdrs, char **cpp){\n  if (xdr_string (xdrs, cpp, LASTUNSIGNED))\n    {\n      return TRUE;\n    }\n  return FALSE;\n}",
    "xdr_array": "xdr_array (XDR *xdrs,\n\t   /* array pointer */\n\t   caddr_t *addrp,\n\t   /* number of elements */\n\t   u_int *sizep,\n\t   /* max numberof elements */\n\t   u_int maxsize,\n\t   /* size in bytes of each element */\n\t   u_int elsize,\n\t   /* xdr routine to handle each element */\n\t   xdrproc_t elproc){\n  u_int i;\n  caddr_t target = *addrp;\n  u_int c;\t\t/* the actual element count */\n  bool_t stat = TRUE;\n\n  /* like strings, arrays are really counted arrays */\n  if (!xdr_u_int (xdrs, sizep))\n    {\n      return FALSE;\n    }\n  c = *sizep;\n  /*\n   * XXX: Let the overflow possibly happen with XDR_FREE because mem_free()\n   * doesn't actually use its second argument anyway.\n   */\n  if ((c > maxsize || c > UINT_MAX / elsize) && (xdrs->x_op != XDR_FREE))\n    {\n      return FALSE;\n    }\n\n  /*\n   * if we are deserializing, we may need to allocate an array.\n   * We also save time by checking for a null array if we are freeing.\n   */\n  if (target == NULL)\n    switch (xdrs->x_op)\n      {\n      case XDR_DECODE:\n\tif (c == 0)\n\t  return TRUE;\n\t*addrp = target = calloc (c, elsize);\n\tif (target == NULL)\n\t  {\n\t    (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n\t    return FALSE;\n\t  }\n\tbreak;\n\n      case XDR_FREE:\n\treturn TRUE;\n      default:\n\tbreak;\n      }\n\n  /*\n   * now we xdr each element of array\n   */\n  for (i = 0; (i < c) && stat; i++)\n    {\n      stat = (*elproc) (xdrs, target, LASTUNSIGNED);\n      target += elsize;\n    }\n\n  /*\n   * the array may need freeing\n   */\n  if (xdrs->x_op == XDR_FREE)\n    {\n      mem_free (*addrp, c * elsize);\n      *addrp = NULL;\n    }\n  return stat;\n}",
    "xdr_vector": "xdr_vector (XDR *xdrs, char *basep, u_int nelem, u_int elemsize,\n\t    xdrproc_t xdr_elem){\n  u_int i;\n  char *elptr;\n\n  elptr = basep;\n  for (i = 0; i < nelem; i++)\n    {\n      if (!(*xdr_elem) (xdrs, elptr, LASTUNSIGNED))\n\t{\n\t  return FALSE;\n\t}\n      elptr += elemsize;\n    }\n  return TRUE;\n}",
    "xdr_float": "xdr_float (XDR *xdrs, float *fp){\n#ifdef vax\n\tstruct ieee_single is;\n\tstruct vax_single vs, *vsp;\n\tstruct sgl_limits *lim;\n\tint i;\n#endif\n\tswitch (xdrs->x_op) {\n\n\tcase XDR_ENCODE:\n#ifdef vax\n\t\tvs = *((struct vax_single *)fp);\n\t\tfor (i = 0, lim = sgl_limits;\n\t\t\ti < sizeof(sgl_limits)/sizeof(struct sgl_limits);\n\t\t\ti++, lim++) {\n\t\t\tif ((vs.mantissa2 == lim->s.mantissa2) &&\n\t\t\t\t(vs.exp == lim->s.exp) &&\n\t\t\t\t(vs.mantissa1 == lim->s.mantissa1)) {\n\t\t\t\tis = lim->ieee;\n\t\t\t\tgoto shipit;\n\t\t\t}\n\t\t}\n\t\tis.exp = vs.exp - VAX_SNG_BIAS + IEEE_SNG_BIAS;\n\t\tis.mantissa = (vs.mantissa1 << 16) | vs.mantissa2;\n\tshipit:\n\t\tis.sign = vs.sign;\n\t\treturn (XDR_PUTLONG(xdrs, (long *)&is));\n#else\n\t\tif (sizeof(float) == sizeof(long))\n\t\t\treturn (XDR_PUTLONG(xdrs, (long *)fp));\n\t\telse if (sizeof(float) == sizeof(int)) {\n\t\t\tlong tmp = *(int *)fp;\n\t\t\treturn (XDR_PUTLONG(xdrs, &tmp));\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase XDR_DECODE:\n#ifdef vax\n\t\tvsp = (struct vax_single *)fp;\n\t\tif (!XDR_GETLONG(xdrs, (long *)&is))\n\t\t\treturn (FALSE);\n\t\tfor (i = 0, lim = sgl_limits;\n\t\t\ti < sizeof(sgl_limits)/sizeof(struct sgl_limits);\n\t\t\ti++, lim++) {\n\t\t\tif ((is.exp == lim->ieee.exp) &&\n\t\t\t\t(is.mantissa == lim->ieee.mantissa)) {\n\t\t\t\t*vsp = lim->s;\n\t\t\t\tgoto doneit;\n\t\t\t}\n\t\t}\n\t\tvsp->exp = is.exp - IEEE_SNG_BIAS + VAX_SNG_BIAS;\n\t\tvsp->mantissa2 = is.mantissa;\n\t\tvsp->mantissa1 = (is.mantissa >> 16);\n\tdoneit:\n\t\tvsp->sign = is.sign;\n\t\treturn (TRUE);\n#else\n\t\tif (sizeof(float) == sizeof(long))\n\t\t\treturn (XDR_GETLONG(xdrs, (long *)fp));\n\t\telse if (sizeof(float) == sizeof(int)) {\n\t\t\tlong tmp;\n\t\t\tif (XDR_GETLONG(xdrs, &tmp)) {\n\t\t\t\t*(int *)fp = tmp;\n\t\t\t\treturn (TRUE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase XDR_FREE:\n\t\treturn (TRUE);\n\t}\n\treturn (FALSE);\n}",
    "xdr_double": "xdr_double (XDR *xdrs, double *dp){\n#ifdef vax\n\tstruct\tieee_double id;\n\tstruct\tvax_double vd;\n\tregister struct dbl_limits *lim;\n\tint i;\n#endif\n\n\tswitch (xdrs->x_op) {\n\n\tcase XDR_ENCODE:\n#ifdef vax\n\t\tvd = *((struct vax_double *)dp);\n\t\tfor (i = 0, lim = dbl_limits;\n\t\t\ti < sizeof(dbl_limits)/sizeof(struct dbl_limits);\n\t\t\ti++, lim++) {\n\t\t\tif ((vd.mantissa4 == lim->d.mantissa4) &&\n\t\t\t\t(vd.mantissa3 == lim->d.mantissa3) &&\n\t\t\t\t(vd.mantissa2 == lim->d.mantissa2) &&\n\t\t\t\t(vd.mantissa1 == lim->d.mantissa1) &&\n\t\t\t\t(vd.exp == lim->d.exp)) {\n\t\t\t\tid = lim->ieee;\n\t\t\t\tgoto shipit;\n\t\t\t}\n\t\t}\n\t\tid.exp = vd.exp - VAX_DBL_BIAS + IEEE_DBL_BIAS;\n\t\tid.mantissa1 = (vd.mantissa1 << 13) | (vd.mantissa2 >> 3);\n\t\tid.mantissa2 = ((vd.mantissa2 & MASK(3)) << 29) |\n\t\t\t\t(vd.mantissa3 << 13) |\n\t\t\t\t((vd.mantissa4 >> 3) & MASK(13));\n\tshipit:\n\t\tid.sign = vd.sign;\n\t\tdp = (double *)&id;\n#endif\n\t\tif (2*sizeof(long) == sizeof(double)) {\n\t\t\tlong *lp = (long *)dp;\n\t\t\treturn (XDR_PUTLONG(xdrs, lp+!LSW) &&\n\t\t\t\tXDR_PUTLONG(xdrs, lp+LSW));\n\t\t} else if (2*sizeof(int) == sizeof(double)) {\n\t\t\tint *ip = (int *)dp;\n\t\t\tlong tmp[2];\n\t\t\ttmp[0] = ip[!LSW];\n\t\t\ttmp[1] = ip[LSW];\n\t\t\treturn (XDR_PUTLONG(xdrs, tmp) &&\n\t\t\t\tXDR_PUTLONG(xdrs, tmp+1));\n\t\t}\n\t\tbreak;\n\n\tcase XDR_DECODE:\n#ifdef vax\n\t\tlp = (long *)&id;\n\t\tif (!XDR_GETLONG(xdrs, lp++) || !XDR_GETLONG(xdrs, lp))\n\t\t\treturn (FALSE);\n\t\tfor (i = 0, lim = dbl_limits;\n\t\t\ti < sizeof(dbl_limits)/sizeof(struct dbl_limits);\n\t\t\ti++, lim++) {\n\t\t\tif ((id.mantissa2 == lim->ieee.mantissa2) &&\n\t\t\t\t(id.mantissa1 == lim->ieee.mantissa1) &&\n\t\t\t\t(id.exp == lim->ieee.exp)) {\n\t\t\t\tvd = lim->d;\n\t\t\t\tgoto doneit;\n\t\t\t}\n\t\t}\n\t\tvd.exp = id.exp - IEEE_DBL_BIAS + VAX_DBL_BIAS;\n\t\tvd.mantissa1 = (id.mantissa1 >> 13);\n\t\tvd.mantissa2 = ((id.mantissa1 & MASK(13)) << 3) |\n\t\t\t\t(id.mantissa2 >> 29);\n\t\tvd.mantissa3 = (id.mantissa2 >> 13);\n\t\tvd.mantissa4 = (id.mantissa2 << 3);\n\tdoneit:\n\t\tvd.sign = id.sign;\n\t\t*dp = *((double *)&vd);\n\t\treturn (TRUE);\n#else\n\t\tif (2*sizeof(long) == sizeof(double)) {\n\t\t\tlong *lp = (long *)dp;\n\t\t\treturn (XDR_GETLONG(xdrs, lp+!LSW) &&\n\t\t\t\tXDR_GETLONG(xdrs, lp+LSW));\n\t\t} else if (2*sizeof(int) == sizeof(double)) {\n\t\t\tint *ip = (int *)dp;\n\t\t\tlong tmp[2];\n\t\t\tif (XDR_GETLONG(xdrs, tmp+!LSW) &&\n\t\t\t    XDR_GETLONG(xdrs, tmp+LSW)) {\n\t\t\t\tip[0] = tmp[0];\n\t\t\t\tip[1] = tmp[1];\n\t\t\t\treturn (TRUE);\n\t\t\t}\n\t\t}\n\t\tbreak;\n#endif\n\n\tcase XDR_FREE:\n\t\treturn (TRUE);\n\t}\n\treturn (FALSE);\n}",
    "xdr_int64_t": "xdr_int64_t (XDR *xdrs, int64_t *ip){\n  int32_t t1, t2;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      t1 = (int32_t) ((*ip) >> 32);\n      t2 = (int32_t) (*ip);\n      return (XDR_PUTINT32(xdrs, &t1) && XDR_PUTINT32(xdrs, &t2));\n    case XDR_DECODE:\n      if (!XDR_GETINT32(xdrs, &t1) || !XDR_GETINT32(xdrs, &t2))\n\treturn FALSE;\n      *ip = ((int64_t) t1) << 32;\n      *ip |= (uint32_t) t2;\t/* Avoid sign extension.  */\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_quad_t": "xdr_quad_t (XDR *xdrs, quad_t *ip){\n  return xdr_int64_t (xdrs, (int64_t *) ip);\n}",
    "xdr_uint64_t": "xdr_uint64_t (XDR *xdrs, uint64_t *uip){\n  uint32_t t1;\n  uint32_t t2;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      t1 = (uint32_t) ((*uip) >> 32);\n      t2 = (uint32_t) (*uip);\n      return (XDR_PUTINT32 (xdrs, (int32_t *) &t1) &&\n\t      XDR_PUTINT32(xdrs, (int32_t *) &t2));\n    case XDR_DECODE:\n      if (!XDR_GETINT32(xdrs, (int32_t *) &t1) ||\n\t  !XDR_GETINT32(xdrs, (int32_t *) &t2))\n\treturn FALSE;\n      *uip = ((uint64_t) t1) << 32;\n      *uip |= t2;\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_u_quad_t": "xdr_u_quad_t (XDR *xdrs, u_quad_t *ip){\n  return xdr_uint64_t (xdrs, (uint64_t *) ip);\n}",
    "xdr_int32_t": "xdr_int32_t (XDR *xdrs, int32_t *lp){\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      return XDR_PUTINT32 (xdrs, lp);\n    case XDR_DECODE:\n      return XDR_GETINT32 (xdrs, lp);\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_uint32_t": "xdr_uint32_t (XDR *xdrs, uint32_t *ulp){\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      return XDR_PUTINT32 (xdrs, (int32_t *) ulp);\n    case XDR_DECODE:\n      return XDR_GETINT32 (xdrs, (int32_t *) ulp);\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_int16_t": "bool_t\nxdr_int16_t (XDR *xdrs, int16_t *ip){\n  int32_t t;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      t = (int32_t) *ip;\n      return XDR_PUTINT32 (xdrs, &t);\n    case XDR_DECODE:\n      if (!XDR_GETINT32 (xdrs, &t))\n\treturn FALSE;\n      *ip = (int16_t) t;\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_uint16_t": "xdr_uint16_t (XDR *xdrs, uint16_t *uip){\n  uint32_t ut;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      ut = (uint32_t) *uip;\n      return XDR_PUTINT32 (xdrs, (int32_t *) &ut);\n    case XDR_DECODE:\n      if (!XDR_GETINT32 (xdrs, (int32_t *) &ut))\n\treturn FALSE;\n      *uip = (uint16_t) ut;\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_int8_t": "xdr_int8_t (XDR *xdrs, int8_t *ip){\n  int32_t t;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      t = (int32_t) *ip;\n      return XDR_PUTINT32 (xdrs, &t);\n    case XDR_DECODE:\n      if (!XDR_GETINT32 (xdrs, &t))\n\treturn FALSE;\n      *ip = (int8_t) t;\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdr_uint8_t": "xdr_uint8_t (XDR *xdrs, uint8_t *uip){\n  uint32_t ut;\n\n  switch (xdrs->x_op)\n    {\n    case XDR_ENCODE:\n      ut = (uint32_t) *uip;\n      return XDR_PUTINT32 (xdrs, (int32_t *) &ut);\n    case XDR_DECODE:\n      if (!XDR_GETINT32 (xdrs, (int32_t *) &ut))\n\treturn FALSE;\n      *uip = (uint8_t) ut;\n      return TRUE;\n    case XDR_FREE:\n      return TRUE;\n    default:\n      return FALSE;\n    }\n}",
    "xdrmem_create": "xdrmem_create (XDR *xdrs, const caddr_t addr, u_int size, enum xdr_op op){\n  xdrs->x_op = op;\n  /* We have to add the const since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */\n  xdrs->x_ops = (struct xdr_ops *) &xdrmem_ops;\n  xdrs->x_private = xdrs->x_base = addr;\n  xdrs->x_handy = size;\n}",
    "xdrrec_create": "xdrrec_create (XDR *xdrs, u_int sendsize,\n\t       u_int recvsize, caddr_t tcp_handle,\n\t       int (*readit) (char *, char *, int),\n\t       int (*writeit) (char *, char *, int)){\n  RECSTREAM *rstrm = (RECSTREAM *) mem_alloc (sizeof (RECSTREAM));\n  caddr_t tmp;\n  char *buf;\n\n  sendsize = fix_buf_size (sendsize);\n  recvsize = fix_buf_size (recvsize);\n  buf = mem_alloc (sendsize + recvsize + BYTES_PER_XDR_UNIT);\n\n  if (rstrm == NULL || buf == NULL)\n    {\n      (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n      mem_free (rstrm, sizeof (RECSTREAM));\n      mem_free (buf, sendsize + recvsize + BYTES_PER_XDR_UNIT);\n      /*\n       *  This is bad.  Should rework xdrrec_create to\n       *  return a handle, and in this case return NULL\n       */\n      return;\n    }\n  /*\n   * adjust sizes and allocate buffer quad byte aligned\n   */\n  rstrm->sendsize = sendsize;\n  rstrm->recvsize = recvsize;\n  rstrm->the_buffer = buf;\n  tmp = rstrm->the_buffer;\n  if ((size_t)tmp % BYTES_PER_XDR_UNIT)\n    tmp += BYTES_PER_XDR_UNIT - (size_t)tmp % BYTES_PER_XDR_UNIT;\n  rstrm->out_base = tmp;\n  rstrm->in_base = tmp + sendsize;\n  /*\n   * now the rest ...\n   */\n  /* We have to add the cast since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */\n  xdrs->x_ops = (struct xdr_ops *) &xdrrec_ops;\n  xdrs->x_private = (caddr_t) rstrm;\n  rstrm->tcp_handle = tcp_handle;\n  rstrm->readit = readit;\n  rstrm->writeit = writeit;\n  rstrm->out_finger = rstrm->out_boundry = rstrm->out_base;\n  rstrm->frag_header = (uint32_t *) rstrm->out_base;\n  rstrm->out_finger += 4;\n  rstrm->out_boundry += sendsize;\n  rstrm->frag_sent = FALSE;\n  rstrm->in_size = recvsize;\n  rstrm->in_boundry = rstrm->in_base;\n  rstrm->in_finger = (rstrm->in_boundry += recvsize);\n  rstrm->fbtbc = 0;\n  rstrm->last_frag = TRUE;\n}",
    "xdrrec_skiprecord": "xdrrec_skiprecord (XDR *xdrs){\n  RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;\n\n  while (rstrm->fbtbc > 0 || (!rstrm->last_frag))\n    {\n      if (!skip_input_bytes (rstrm, rstrm->fbtbc))\n\treturn FALSE;\n      rstrm->fbtbc = 0;\n      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm)))\n\treturn FALSE;\n    }\n  rstrm->last_frag = FALSE;\n  return TRUE;\n}",
    "xdrrec_eof": "xdrrec_eof (XDR *xdrs){\n  RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;\n\n  while (rstrm->fbtbc > 0 || (!rstrm->last_frag))\n    {\n      if (!skip_input_bytes (rstrm, rstrm->fbtbc))\n\treturn TRUE;\n      rstrm->fbtbc = 0;\n      if ((!rstrm->last_frag) && (!set_input_fragment (rstrm)))\n\treturn TRUE;\n    }\n  if (rstrm->in_finger == rstrm->in_boundry)\n    return TRUE;\n  return FALSE;\n}",
    "xdrrec_endofrecord": "xdrrec_endofrecord (XDR *xdrs, bool_t sendnow){\n  RECSTREAM *rstrm = (RECSTREAM *) xdrs->x_private;\n  u_long len;\t\t/* fragment length */\n\n  if (sendnow || rstrm->frag_sent\n      || rstrm->out_finger + BYTES_PER_XDR_UNIT >= rstrm->out_boundry)\n    {\n      rstrm->frag_sent = FALSE;\n      return flush_out (rstrm, TRUE);\n    }\n  len = (rstrm->out_finger - (char *) rstrm->frag_header\n\t - BYTES_PER_XDR_UNIT);\n  *rstrm->frag_header = htonl ((u_long) len | LAST_FRAG);\n  rstrm->frag_header = (uint32_t *) rstrm->out_finger;\n  rstrm->out_finger += BYTES_PER_XDR_UNIT;\n  return TRUE;\n}",
    "xdr_reference": "xdr_reference (XDR *xdrs,\n\t       /* the pointer to work on */\n\t       caddr_t *pp,\n\t       /* size of the object pointed to */\n\t       u_int size,\n\t       /* xdr routine to handle the object */\n\t       xdrproc_t proc){\n  caddr_t loc = *pp;\n  bool_t stat;\n\n  if (loc == NULL)\n    switch (xdrs->x_op)\n      {\n      case XDR_FREE:\n\treturn TRUE;\n\n      case XDR_DECODE:\n\t*pp = loc = (caddr_t) calloc (1, size);\n\tif (loc == NULL)\n\t  {\n\t    (void) __fxprintf (NULL, \"%s: %s\", __func__, _(\"out of memory\\n\"));\n\t    return FALSE;\n\t  }\n\tbreak;\n      default:\n\tbreak;\n      }\n\n  stat = (*proc) (xdrs, loc, LASTUNSIGNED);\n\n  if (xdrs->x_op == XDR_FREE)\n    {\n      mem_free (loc, size);\n      *pp = NULL;\n    }\n  return stat;\n}",
    "xdr_pointer": "xdr_pointer (XDR *xdrs, char **objpp, u_int obj_size, xdrproc_t xdr_obj){\n\n  bool_t more_data;\n\n  more_data = (*objpp != NULL);\n  if (!xdr_bool (xdrs, &more_data))\n    {\n      return FALSE;\n    }\n  if (!more_data)\n    {\n      *objpp = NULL;\n      return TRUE;\n    }\n  return xdr_reference (xdrs, objpp, obj_size, xdr_obj);\n}",
    "xdr_sizeof": "xdr_sizeof (xdrproc_t func, void *data){\n  XDR x;\n  struct xdr_ops ops;\n  bool_t stat;\n  /* to stop ANSI-C compiler from complaining */\n  typedef bool_t (*dummyfunc1) (XDR *, long *);\n  typedef bool_t (*dummyfunc2) (XDR *, caddr_t, u_int);\n  typedef bool_t (*dummyfunc3) (XDR *, int32_t *);\n\n  ops.x_putlong = x_putlong;\n  ops.x_putbytes = x_putbytes;\n  ops.x_inline = x_inline;\n  ops.x_getpostn = x_getpostn;\n  ops.x_setpostn = x_setpostn;\n  ops.x_destroy = x_destroy;\n  ops.x_putint32 = x_putint32;\n\n  /* the other harmless ones */\n  ops.x_getlong = (dummyfunc1) harmless;\n  ops.x_getbytes = (dummyfunc2) harmless;\n  ops.x_getint32 = (dummyfunc3) harmless;\n\n  x.x_op = XDR_ENCODE;\n  x.x_ops = &ops;\n  x.x_handy = 0;\n  x.x_private = (caddr_t) NULL;\n  x.x_base = (caddr_t) 0;\n\n  stat = func (&x, data);\n  free (x.x_private);\n  return stat == TRUE ? x.x_handy : 0;\n}",
    "xdrstdio_create": "xdrstdio_create (XDR *xdrs, FILE *file, enum xdr_op op){\n  xdrs->x_op = op;\n  /* We have to add the const since the `struct xdr_ops' in `struct XDR'\n     is not `const'.  */\n  xdrs->x_ops = (struct xdr_ops *) &xdrstdio_ops;\n  xdrs->x_private = (caddr_t) file;\n  xdrs->x_handy = 0;\n  xdrs->x_base = 0;\n}",
    "feclearexcept": "feclearexcept (int excepts){\n  fenv_t temp;\n  unsigned int mxcsr;\n\n  /* Mask out unsupported bits/exceptions.  */\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Bah, we have to clear selected exceptions.  Since there is no\n     `fldsw' instruction we have to do it the hard way.  */\n  __asm__ (\"fnstenv %0\" : \"=m\" (*&temp));\n\n  /* Clear the relevant bits.  */\n  temp.__status_word &= excepts ^ FE_ALL_EXCEPT;\n\n  /* Put the new data in effect.  */\n  __asm__ (\"fldenv %0\" : : \"m\" (*&temp));\n\n  /* And the same procedure for SSE.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&mxcsr));\n\n  /* Clear the relevant bits.  */\n  mxcsr &= ~excepts;\n\n  /* And put them into effect.  */\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&mxcsr));\n\n  /* Success.  */\n  return 0;\n}",
    "fegetexceptflag": "fegetexceptflag (fexcept_t *flagp, int excepts){\n  fexcept_t temp;\n  unsigned int mxscr;\n\n  /* Get the current exceptions for the x87 FPU and SSE unit.  */\n  __asm__ (\"fnstsw %0\\n\"\n\t   \"stmxcsr %1\" : \"=m\" (*&temp), \"=m\" (*&mxscr));\n\n  *flagp = (temp | mxscr) & FE_ALL_EXCEPT & excepts;\n\n  /* Success.  */\n  return 0;\n}",
    "fesetexceptflag": "fesetexceptflag (const fexcept_t *flagp, int excepts){\n  /* The flags can be set in the 387 unit or in the SSE unit.\n     When we need to clear a flag, we need to do so in both units,\n     due to the way fetestexcept() is implemented.\n     When we need to set a flag, it is sufficient to do it in the SSE unit,\n     because that is guaranteed to not trap.  */\n\n  fenv_t temp;\n  unsigned int mxcsr;\n\n  excepts &= FE_ALL_EXCEPT;\n\n  /* Get the current x87 FPU environment.  We have to do this since we\n     cannot separately set the status word.  */\n  __asm__ (\"fnstenv %0\" : \"=m\" (*&temp));\n\n  /* Clear relevant flags.  */\n  temp.__status_word &= ~(excepts & ~ *flagp);\n\n  /* Store the new status word (along with the rest of the environment).  */\n  __asm__ (\"fldenv %0\" : : \"m\" (*&temp));\n\n  /* And now similarly for SSE.  */\n  __asm__ (\"stmxcsr %0\" : \"=m\" (*&mxcsr));\n\n  /* Clear or set relevant flags.  */\n  mxcsr ^= (mxcsr ^ *flagp) & excepts;\n\n  /* Put the new data in effect.  */\n  __asm__ (\"ldmxcsr %0\" : : \"m\" (*&mxcsr));\n\n  /* Success.  */\n  return 0;\n}",
    "__libc_ifunc_impl_list": "__libc_ifunc_impl_list (const char *name, struct libc_ifunc_impl *array,\n\t\t\tsize_t max){\n  size_t i = max;\n\n  /* Support sysdeps/x86_64/multiarch/memcmpeq.c.  */\n  IFUNC_IMPL (i, name, __memcmpeq,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcmpeq,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memcmpeq_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcmpeq,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memcmpeq_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcmpeq,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcmpeq_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcmpeq,\n\t\t\t\t     1,\n\t\t\t\t     __memcmpeq_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/memchr.c.  */\n  IFUNC_IMPL (i, name, memchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_evex_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memchr,\n\t\t\t\t     1,\n\t\t\t\t     __memchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/memcmp.c.  */\n  IFUNC_IMPL (i, name, memcmp,\n\t      /* NB: If any of these names change or if any new\n\t         implementations are added be sure to update\n\t         sysdeps/x86_64/memcmp-isa-default-impl.h.  */\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __memcmp_evex_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __memcmp_avx2_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcmp_avx2_movbe_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcmp,\n\t\t\t\t     1,\n\t\t\t\t     __memcmp_sse2))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/memmove_chk.c.  */\n  IFUNC_IMPL (i, name, __memmove_chk,\n\t      IFUNC_IMPL_ADD (array, i, __memmove_chk, 1,\n\t\t\t      __memmove_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memmove_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_chk_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_chk_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_chk_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memmove_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_chk_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memmove_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memmove_chk_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memmove_chk, 1,\n\t\t\t\t     __memmove_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memmove_chk, 1,\n\t\t\t\t     __memmove_chk_sse2_unaligned_erms))\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/memmove.c.  */\n  IFUNC_IMPL (i, name, memmove,\n\t      IFUNC_IMPL_ADD (array, i, memmove, 1,\n\t\t\t      __memmove_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memmove_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memmove_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memmove_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memmove,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memmove_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memmove,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memmove_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memmove, 1,\n\t\t\t\t     __memmove_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memmove, 1,\n\t\t\t\t     __memmove_sse2_unaligned_erms))\n\n  /* Support sysdeps/x86_64/multiarch/memrchr.c.  */\n  IFUNC_IMPL (i, name, memrchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (LZCNT)),\n\t\t\t\t     __memrchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (LZCNT)),\n\t\t\t\t     __memrchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (LZCNT)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memrchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memrchr,\n\t\t\t\t     1,\n\t\t\t\t     __memrchr_sse2))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/memset_chk.c.  */\n  IFUNC_IMPL (i, name, __memset_chk,\n\t      IFUNC_IMPL_ADD (array, i, __memset_chk, 1,\n\t\t\t      __memset_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memset_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_chk_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_chk_avx2_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_chk_avx2_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_chk_avx2_unaligned_erms_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memset_chk, 1,\n\t\t\t\t     __memset_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memset_chk, 1,\n\t\t\t\t     __memset_chk_sse2_unaligned_erms)\n\t      )\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/memset.c.  */\n  IFUNC_IMPL (i, name, memset,\n\t      IFUNC_IMPL_ADD (array, i, memset, 1,\n\t\t\t      __memset_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memset_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __memset_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __memset_avx2_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_avx2_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memset_avx2_unaligned_erms_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memset, 1,\n\t\t\t\t     __memset_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memset, 1,\n\t\t\t\t     __memset_sse2_unaligned_erms)\n\t     )\n\n  /* Support sysdeps/x86_64/multiarch/rawmemchr.c.  */\n  IFUNC_IMPL (i, name, rawmemchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_evex_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __rawmemchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, rawmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __rawmemchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, rawmemchr,\n\t\t\t\t     1,\n\t\t\t\t     __rawmemchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strlen.c.  */\n  IFUNC_IMPL (i, name, strlen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strlen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strlen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strlen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strlen_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strlen,\n\t\t\t\t     1,\n\t\t\t\t     __strlen_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strnlen.c.  */\n  IFUNC_IMPL (i, name, strnlen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strnlen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strnlen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strnlen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strnlen_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strnlen,\n\t\t\t\t     1,\n\t\t\t\t     __strnlen_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/stpncpy.c.  */\n  IFUNC_IMPL (i, name, stpncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, stpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __stpncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpncpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __stpncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __stpncpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, stpncpy,\n\t\t\t\t     1,\n\t\t\t\t     __stpncpy_sse2_unaligned))\n\n  /* Support sysdeps/x86_64/multiarch/stpcpy.c.  */\n  IFUNC_IMPL (i, name, stpcpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, stpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __stpcpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __stpcpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, stpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __stpcpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, stpcpy,\n\t\t\t\t     1,\n\t\t\t\t     __stpcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, stpcpy,\n\t\t\t\t     1,\n\t\t\t\t     __stpcpy_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcasecmp_l.c.  */\n  IFUNC_IMPL (i, name, strcasecmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcasecmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strcasecmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp,\n\t\t\t\t     1,\n\t\t\t\t     __strcasecmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcasecmp_l.c.  */\n  IFUNC_IMPL (i, name, strcasecmp_l,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_l_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcasecmp_l_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcasecmp_l_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp_l,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strcasecmp_l_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcasecmp_l,\n\t\t\t\t     1,\n\t\t\t\t     __strcasecmp_l_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcat.c.  */\n  IFUNC_IMPL (i, name, strcat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strcat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcat,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strcat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcat_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcat,\n\t\t\t\t     1,\n\t\t\t\t     __strcat_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, strcat,\n\t\t\t\t     1,\n\t\t\t\t     __strcat_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strchr.c.  */\n  IFUNC_IMPL (i, name, strchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strchr,\n\t\t\t\t     1,\n\t\t\t\t     __strchr_sse2)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, strchr,\n\t\t\t\t     1,\n\t\t\t\t     __strchr_sse2_no_bsf))\n\n  /* Support sysdeps/x86_64/multiarch/strchrnul.c.  */\n  IFUNC_IMPL (i, name, strchrnul,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchrnul_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strchrnul_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strchrnul_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strchrnul,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strchrnul_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strchrnul,\n\t\t\t\t     1,\n\t\t\t\t     __strchrnul_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strrchr.c.  */\n  IFUNC_IMPL (i, name, strrchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strrchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strrchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strrchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strrchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strrchr,\n\t\t\t\t     1,\n\t\t\t\t     __strrchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcmp.c.  */\n  IFUNC_IMPL (i, name, strcmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strcmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcmp,\n                                 CPU_FEATURE_USABLE (SSE4_2),\n                                 __strcmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementations because the SSE2\n\t         implementations are also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcmp,\n\t\t\t\t     1,\n\t\t\t\t     __strcmp_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcmp,\n\t\t\t\t     1,\n\t\t\t\t     __strcmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcpy.c.  */\n  IFUNC_IMPL (i, name, strcpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strcpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strcpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strcpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strcpy,\n\t\t\t\t     1,\n\t\t\t\t     __strcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, strcpy,\n\t\t\t\t     1,\n\t\t\t\t     __strcpy_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strcspn.c.  */\n  IFUNC_IMPL (i, name, strcspn,\n\t      /* All implementations of strcspn are built at all ISA\n\t         levels.  */\n\t      IFUNC_IMPL_ADD (array, i, strcspn, CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t      __strcspn_sse42)\n\t      IFUNC_IMPL_ADD (array, i, strcspn, 1, __strcspn_generic))\n\n  /* Support sysdeps/x86_64/multiarch/strncase_l.c.  */\n  IFUNC_IMPL (i, name, strncasecmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncasecmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strncasecmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp,\n\t\t\t\t     1,\n\t\t\t\t     __strncasecmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strncase_l.c.  */\n  IFUNC_IMPL (i, name, strncasecmp_l,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      & CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_l_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncasecmp_l_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncasecmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncasecmp_l_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp_l,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strncasecmp_l_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncasecmp_l,\n\t\t\t\t     1,\n\t\t\t\t     __strncasecmp_l_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/strncat.c.  */\n  IFUNC_IMPL (i, name, strncat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strncat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncat,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strncat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncat_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncat,\n\t\t\t\t     1,\n\t\t\t\t     __strncat_sse2_unaligned))\n\n  /* Support sysdeps/x86_64/multiarch/strncpy.c.  */\n  IFUNC_IMPL (i, name, strncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __strncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __strncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncpy_avx2_rtm)\n\t      /* ISA V2 wrapper for sse2_unaligned implementation because\n\t         the sse2_unaligned implementation is also used at ISA\n\t         level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncpy,\n\t\t\t\t     1,\n\t\t\t\t     __strncpy_sse2_unaligned))\n\n  /* Support sysdeps/x86_64/multiarch/strpbrk.c.  */\n  IFUNC_IMPL (i, name, strpbrk,\n\t      /* All implementations of strpbrk are built at all ISA\n\t         levels.  */\n\t      IFUNC_IMPL_ADD (array, i, strpbrk, CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t      __strpbrk_sse42)\n\t      IFUNC_IMPL_ADD (array, i, strpbrk, 1, __strpbrk_generic))\n\n\n  /* Support sysdeps/x86_64/multiarch/strspn.c.  */\n  IFUNC_IMPL (i, name, strspn,\n\t      /* All implementations of strspn are built at all ISA\n\t         levels.  */\n\t      IFUNC_IMPL_ADD (array, i, strspn, CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t      __strspn_sse42)\n\t      IFUNC_IMPL_ADD (array, i, strspn, 1, __strspn_generic))\n\n  /* Support sysdeps/x86_64/multiarch/strstr.c.  */\n  IFUNC_IMPL (i, name, strstr,\n              IFUNC_IMPL_ADD (array, i, strstr,\n                              (CPU_FEATURE_USABLE (AVX512VL)\n                               && CPU_FEATURE_USABLE (AVX512BW)\n                               && CPU_FEATURE_USABLE (AVX512DQ)\n                               && CPU_FEATURE_USABLE (BMI2)),\n                              __strstr_avx512)\n\t      IFUNC_IMPL_ADD (array, i, strstr, 1, __strstr_sse2_unaligned)\n\t      IFUNC_IMPL_ADD (array, i, strstr, 1, __strstr_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcschr.c.  */\n  IFUNC_IMPL (i, name, wcschr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcschr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)),\n\t\t\t\t     __wcschr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcschr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcschr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcschr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcschr,\n\t\t\t\t     1,\n\t\t\t\t     __wcschr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcsrchr.c.  */\n  IFUNC_IMPL (i, name, wcsrchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsrchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsrchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsrchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsrchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI1)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcsrchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsrchr,\n\t\t\t\t     1,\n\t\t\t\t     __wcsrchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcscmp.c.  */\n  IFUNC_IMPL (i, name, wcscmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcscmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcscmp_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcscmp,\n\t\t\t\t     1,\n\t\t\t\t     __wcscmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcsncmp.c.  */\n  IFUNC_IMPL (i, name, wcsncmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcsncmp_avx2_rtm)\n\t      /* ISA V2 wrapper for GENERIC implementation because the\n\t         GENERIC implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncmp,\n\t\t\t\t     1,\n\t\t\t\t     __wcsncmp_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcscpy.c.  */\n  IFUNC_IMPL (i, name, wcscpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcscpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcscpy,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __wcscpy_ssse3)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, wcscpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcscpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcsncpy.c.  */\n  IFUNC_IMPL (i, name, wcsncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcpncpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcsncpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcpcpy.c.  */\n  IFUNC_IMPL (i, name, wcpcpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpcpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcpcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpcpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcpcpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcpcpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcpncpy.c.  */\n  IFUNC_IMPL (i, name, wcpncpy,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpncpy_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcpncpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcpncpy_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncpy,\n\t\t\t\t     1,\n\t\t\t\t     __wcpncpy_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcscat.c.  */\n  IFUNC_IMPL (i, name, wcscat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcscat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcscat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcscat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcscat,\n\t\t\t\t     1,\n\t\t\t\t     __wcscat_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcsncat.c.  */\n  IFUNC_IMPL (i, name, wcsncat,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncat_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsncat,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsncat_avx2)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsncat,\n\t\t\t\t     1,\n\t\t\t\t     __wcsncat_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wcslen.c.  */\n  IFUNC_IMPL (i, name, wcslen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcslen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcslen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcslen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcslen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcslen_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcslen,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_1),\n\t\t\t\t     __wcslen_sse4_1)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, wcslen,\n\t\t\t\t     1,\n\t\t\t\t     __wcslen_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wcsnlen.c.  */\n  IFUNC_IMPL (i, name, wcsnlen,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsnlen_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsnlen_evex512)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wcsnlen_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wcsnlen,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wcsnlen_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wcsnlen,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_1),\n\t\t\t\t     __wcsnlen_sse4_1)\n\t      X86_IFUNC_IMPL_ADD_V1 (array, i, wcsnlen,\n\t\t\t\t     1,\n\t\t\t\t     __wcsnlen_generic))\n\n  /* Support sysdeps/x86_64/multiarch/wmemchr.c.  */\n  IFUNC_IMPL (i, name, wmemchr,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_evex)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_evex512)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_evex_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemchr_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemchr,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemchr_avx2_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wmemchr,\n\t\t\t\t     1,\n\t\t\t\t     __wmemchr_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wmemcmp.c.  */\n  IFUNC_IMPL (i, name, wmemcmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __wmemcmp_evex_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)),\n\t\t\t\t     __wmemcmp_avx2_movbe)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemcmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (MOVBE)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemcmp_avx2_movbe_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wmemcmp,\n\t\t\t\t     1,\n\t\t\t\t     __wmemcmp_sse2))\n\n  /* Support sysdeps/x86_64/multiarch/wmemset.c.  */\n  IFUNC_IMPL (i, name, wmemset,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, wmemset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemset,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __wmemset_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, wmemset,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemset_avx2_unaligned_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, wmemset, 1,\n\t\t\t\t     __wmemset_sse2_unaligned))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/memcpy_chk.c.  */\n  IFUNC_IMPL (i, name, __memcpy_chk,\n\t      IFUNC_IMPL_ADD (array, i, __memcpy_chk, 1,\n\t\t\t      __memcpy_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memcpy_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_chk_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_chk_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_chk_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __memcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_chk_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memcpy_chk_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcpy_chk, 1,\n\t\t\t\t     __memcpy_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __memcpy_chk, 1,\n\t\t\t\t     __memcpy_chk_sse2_unaligned_erms))\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/memcpy.c.  */\n  IFUNC_IMPL (i, name, memcpy,\n\t      IFUNC_IMPL_ADD (array, i, memcpy, 1,\n\t\t\t      __memcpy_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __memcpy_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __memcpy_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __memcpy_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, memcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __memcpy_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __memcpy_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcpy, 1,\n\t\t\t\t     __memcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, memcpy, 1,\n\t\t\t\t     __memcpy_sse2_unaligned_erms))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/mempcpy_chk.c.  */\n  IFUNC_IMPL (i, name, __mempcpy_chk,\n\t      IFUNC_IMPL_ADD (array, i, __mempcpy_chk, 1,\n\t\t\t      __mempcpy_chk_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __mempcpy_chk_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_chk_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_chk_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_chk_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_chk_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __mempcpy_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_chk_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __mempcpy_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __mempcpy_chk_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __mempcpy_chk, 1,\n\t\t\t\t     __mempcpy_chk_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __mempcpy_chk, 1,\n\t\t\t\t     __mempcpy_chk_sse2_unaligned_erms))\n#endif\n\n  /* Support sysdeps/x86_64/multiarch/mempcpy.c.  */\n  IFUNC_IMPL (i, name, mempcpy,\n\t      IFUNC_IMPL_ADD (array, i, mempcpy, 1,\n\t\t\t      __mempcpy_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512F),\n\t\t\t\t     __mempcpy_avx512_no_vzeroupper)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_avx512_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX512VL),\n\t\t\t\t     __mempcpy_evex_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_avx_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX),\n\t\t\t\t     __mempcpy_avx_unaligned_erms)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_avx_unaligned_rtm)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, mempcpy,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __mempcpy_avx_unaligned_erms_rtm)\n\t      /* By V3 we assume fast aligned copy.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, mempcpy,\n\t\t\t\t     CPU_FEATURE_USABLE (SSSE3),\n\t\t\t\t     __mempcpy_ssse3)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2 (SSSE3 is too\n\t         optimized around aligned copy to be better as general\n\t         purpose memmove).  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, mempcpy, 1,\n\t\t\t\t     __mempcpy_sse2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, mempcpy, 1,\n\t\t\t\t     __mempcpy_sse2_unaligned_erms))\n\n  /* Support sysdeps/x86_64/multiarch/strncmp.c.  */\n  IFUNC_IMPL (i, name, strncmp,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, strncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncmp_evex)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __strncmp_avx2)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, strncmp,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __strncmp_avx2_rtm)\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncmp,\n\t\t\t\t     CPU_FEATURE_USABLE (SSE4_2),\n\t\t\t\t     __strncmp_sse42)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, strncmp,\n\t\t\t\t     1,\n\t\t\t\t     __strncmp_sse2))\n\n#ifdef SHARED\n  /* Support sysdeps/x86_64/multiarch/wmemset_chk.c.  */\n  IFUNC_IMPL (i, name, __wmemset_chk,\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __wmemset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_chk_evex_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V4 (array, i, __wmemset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX512VL)\n\t\t\t\t      && CPU_FEATURE_USABLE (AVX512BW)\n\t\t\t\t      && CPU_FEATURE_USABLE (BMI2)),\n\t\t\t\t     __wmemset_chk_avx512_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __wmemset_chk,\n\t\t\t\t     CPU_FEATURE_USABLE (AVX2),\n\t\t\t\t     __wmemset_chk_avx2_unaligned)\n\t      X86_IFUNC_IMPL_ADD_V3 (array, i, __wmemset_chk,\n\t\t\t\t     (CPU_FEATURE_USABLE (AVX2)\n\t\t\t\t      && CPU_FEATURE_USABLE (RTM)),\n\t\t\t\t     __wmemset_chk_avx2_unaligned_rtm)\n\t      /* ISA V2 wrapper for SSE2 implementation because the SSE2\n\t         implementation is also used at ISA level 2.  */\n\t      X86_IFUNC_IMPL_ADD_V2 (array, i, __wmemset_chk, 1,\n\t\t\t\t     __wmemset_chk_sse2_unaligned))\n#endif\n\n  return 0;\n}",
    "__isnan": "__isnan (double x){\n  return (_FCLASS (x) & _FCLASS_NAN) != 0;\n}",
    "link": "*\nlink (void){\n  struct unwind_link *unwind_link = __libc_unwind_link_get ();\n  if (unwind_link == NULL)\n    __libc_fatal (LIBGCC_S_SO \" must be installed for unwinding to work\\n\");\n  return unwind_link;\n}",
    "__signbit": "__signbit (double x){\n  return __builtin_signbit (x);\n}",
    "pthread_attr_getguardsize": "pthread_attr_getguardsize (const pthread_attr_t *attr, size_t * guardsize){\n  *guardsize = attr->__guardsize;\n  return 0;\n}",
    "pthread_attr_setguardsize": "pthread_attr_setguardsize (pthread_attr_t *attr, size_t guardsize){\n  attr->__guardsize = guardsize;\n  return 0;\n}",
    "pthread_barrier_destroy": "pthread_barrier_destroy (pthread_barrier_t *barrier){\n  return 0;\n}",
    "pthread_barrier_init": "pthread_barrier_init (pthread_barrier_t *barrier,\n\t\t      const pthread_barrierattr_t *attr, unsigned count){\n  ASSERT_TYPE_SIZE (pthread_barrier_t, __SIZEOF_PTHREAD_BARRIER_T);\n\n  if (count == 0)\n    return EINVAL;\n\n  memset (barrier, 0, sizeof *barrier);\n\n  barrier->__lock = PTHREAD_SPINLOCK_INITIALIZER;\n  barrier->__pending = count;\n  barrier->__count = count;\n\n  if (attr == NULL\n      || memcmp (attr, &__pthread_default_barrierattr, sizeof (*attr)) == 0)\n    /* Use the default attributes.  */\n    return 0;\n\n  /* Non-default attributes.  */\n\n  barrier->__attr = malloc (sizeof *attr);\n  if (barrier->__attr == NULL)\n    return ENOMEM;\n\n  *barrier->__attr = *attr;\n  return 0;\n}",
    "pthread_barrier_wait": "pthread_barrier_wait (pthread_barrier_t *barrier){\n  __pthread_spin_wait (&barrier->__lock);\n  if (--barrier->__pending == 0)\n    {\n      barrier->__pending = barrier->__count;\n\n      if (barrier->__count == 1)\n\t__pthread_spin_unlock (&barrier->__lock);\n      else\n\t{\n\t  struct __pthread *wakeup;\n\t  unsigned n = 0;\n\n\t  __pthread_queue_iterate (barrier->__queue, wakeup)\n\t    n++;\n\n\t  {\n\t    struct __pthread *wakeups[n];\n\t    unsigned i = 0;\n\n\t    __pthread_dequeuing_iterate (barrier->__queue, wakeup)\n\t      wakeups[i++] = wakeup;\n\n\t    barrier->__queue = NULL;\n\t    __pthread_spin_unlock (&barrier->__lock);\n\n\t    for (i = 0; i < n; i++)\n\t      __pthread_wakeup (wakeups[i]);\n\t  }\n\t}\n\n      return PTHREAD_BARRIER_SERIAL_THREAD;\n    }\n  else\n    {\n      struct __pthread *self = _pthread_self ();\n\n      /* Add ourselves to the list of waiters.  */\n      __pthread_enqueue (&barrier->__queue, self);\n      __pthread_spin_unlock (&barrier->__lock);\n\n      __pthread_block (self);\n      return 0;\n    }\n}",
    "pthread_barrierattr_destroy": "pthread_barrierattr_destroy (pthread_barrierattr_t *attr){\n  return 0;\n}",
    "pthread_barrierattr_getpshared": "pthread_barrierattr_getpshared (const pthread_barrierattr_t *attr,\n\t\t\t\tint *pshared){\n  *pshared = attr->__pshared;\n  return 0;\n}",
    "pthread_barrierattr_init": "pthread_barrierattr_init (pthread_barrierattr_t *attr){\n  ASSERT_TYPE_SIZE (pthread_barrierattr_t, __SIZEOF_PTHREAD_BARRIERATTR_T);\n\n  *attr = __pthread_default_barrierattr;\n  return 0;\n}",
    "pthread_barrierattr_setpshared": "pthread_barrierattr_setpshared (pthread_barrierattr_t *attr, int pshared){\n  switch (pshared)\n    {\n    case PTHREAD_PROCESS_PRIVATE:\n      attr->__pshared = pshared;\n      return 0;\n\n    case PTHREAD_PROCESS_SHARED:\n      return ENOTSUP;\n\n    default:\n      return EINVAL;\n    }\n}",
    "pthread_condattr_getclock": "pthread_condattr_getclock (const pthread_condattr_t *attr, clockid_t * clock){\n  *clock = attr->__clock;\n  return 0;\n}",
    "pthread_condattr_getpshared": "pthread_condattr_getpshared (const pthread_condattr_t *attr, int *pshared){\n  *pshared = attr->__pshared;\n  return 0;\n}",
    "pthread_condattr_setclock": "pthread_condattr_setclock (pthread_condattr_t *attr, clockid_t clock){\n  /* Only a few clocks are allowed.  CLOCK_REALTIME is always allowed.\n     CLOCK_MONOTONIC only if the kernel has the necessary support.  */\n  if (clock == CLOCK_MONOTONIC)\n    {\n      /* Check whether the clock is available.  */\n      static int avail;\n\n      if (avail == 0)\n\t{\n\t  struct timespec ts;\n\t  int res;\n\n\t  res = clock_gettime (CLOCK_MONOTONIC, &ts);\n\t  avail = res < 0 ? -1 : 1;\n\t}\n\n      if (avail < 0)\n\t/* Not available.  */\n\treturn EINVAL;\n    }\n  else if (clock != CLOCK_REALTIME)\n    return EINVAL;\n\n  attr->__clock = clock;\n\n  return 0;\n}",
    "pthread_condattr_setpshared": "pthread_condattr_setpshared (pthread_condattr_t *attr, int pshared){\n  switch (pshared)\n    {\n    case PTHREAD_PROCESS_PRIVATE:\n      attr->__pshared = pshared;\n      return 0;\n\n    case PTHREAD_PROCESS_SHARED:\n      return ENOTSUP;\n\n    default:\n      return EINVAL;\n    }\n}",
    "pthread_getconcurrency": "pthread_getconcurrency (void){\n  return __pthread_concurrency;\n}",
    "pthread_getcpuclockid": "pthread_getcpuclockid (pthread_t thread, clockid_t *clock){\n#ifdef CLOCK_THREAD_CPUTIME_ID\n  *clock = CLOCK_THREAD_CPUTIME_ID;\n  return 0;\n#else\n  return ENOSYS;\n#endif\n}",
    "__pthread_getspecific": "*\n__pthread_getspecific (pthread_key_t key){\n  struct __pthread *self;\n\n  if (key < 0 || key >= __pthread_key_count)\n    return NULL;\n\n  self = _pthread_self ();\n\n  if (self->thread_specifics == NULL)\n    {\n      if (key >= PTHREAD_STATIC_KEYS)\n\treturn NULL;\n      return self->static_thread_specifics[key];\n    }\n\n  if (key >= self->thread_specifics_size)\n    return 0;\n\n  return self->thread_specifics[key];\n}",
    "__pthread_key_create": "__pthread_key_create (pthread_key_t *key, void (*destructor) (void *)){\n  /* Where to look for the next key slot.  */\n  static int index;\n\n  __pthread_key_lock_ready ();\n\n  __pthread_mutex_lock (&__pthread_key_lock);\n\ndo_search:\n  /* Use the search hint and try to find a free slot.  */\n  for (; index < __pthread_key_count\n       && __pthread_key_destructors[index] != PTHREAD_KEY_INVALID; index++)\n    ;\n\n  /* See if we actually found a free element.  */\n  if (index < __pthread_key_count)\n    {\n      assert (__pthread_key_destructors[index] == PTHREAD_KEY_INVALID);\n      assert (__pthread_key_invalid_count > 0);\n\n      __pthread_key_invalid_count--;\n      __pthread_key_destructors[index] = destructor;\n      *key = index++;\n\n      __pthread_mutex_unlock (&__pthread_key_lock);\n      return 0;\n    }\n\n  assert (index == __pthread_key_count);\n\n  /* No space at the end.  */\n  if (__pthread_key_size == __pthread_key_count)\n    {\n      /* See if it is worth looking for a free element.  */\n      if (__pthread_key_invalid_count > 4\n\t  && __pthread_key_invalid_count > __pthread_key_size / 8)\n\t{\n\t  index = 0;\n\t  goto do_search;\n\t}\n\n\n      /* Resize the array.  */\n      {\n\tvoid *t;\n\tint newsize;\n\n\tnewsize = __pthread_key_size * 2;\n\n\tif (__pthread_key_destructors == __pthread_static_key_destructors)\n\t  {\n\t    /* We were still using the static array.  Switch to dynamic.  */\n\t    t = malloc (newsize * sizeof (*__pthread_key_destructors));\n\n\t    if (t != NULL)\n\t      memcpy (t, __pthread_key_destructors,\n\t\t      __pthread_key_size * sizeof (*__pthread_key_destructors));\n\t  }\n\telse\n\t  t = realloc (__pthread_key_destructors,\n\t\t       newsize * sizeof (*__pthread_key_destructors));\n\n\tif (t == NULL)\n\t  {\n\t    __pthread_mutex_unlock (&__pthread_key_lock);\n\t    return ENOMEM;\n\t  }\n\n\t__pthread_key_size = newsize;\n\t__pthread_key_destructors = t;\n      }\n    }\n\n  __pthread_key_destructors[index] = destructor;\n  *key = index;\n\n  index++;\n  __pthread_key_count++;\n\n  __pthread_mutex_unlock (&__pthread_key_lock);\n  return 0;\n}",
    "__pthread_once": "__pthread_once (pthread_once_t *once_control, void (*init_routine) (void)){\n  ASSERT_TYPE_SIZE (pthread_once_t, __SIZEOF_PTHREAD_ONCE_T);\n\n  atomic_full_barrier ();\n  if (once_control->__run == 0)\n    {\n      __pthread_spin_wait (&once_control->__lock);\n\n      if (once_control->__run == 0)\n\t{\n\t  pthread_cleanup_push (clear_once_control, once_control);\n\t  init_routine ();\n\t  pthread_cleanup_pop (0);\n\n\t  atomic_full_barrier ();\n\t  once_control->__run = 1;\n\t}\n\n      __pthread_spin_unlock (&once_control->__lock);\n    }\n\n  return 0;\n}",
    "__pthread_rwlock_rdlock": "__pthread_rwlock_rdlock (struct __pthread_rwlock *rwlock){\n  return __pthread_rwlock_timedrdlock_internal (rwlock, -1, 0);\n}",
    "pthread_rwlock_tryrdlock": "pthread_rwlock_tryrdlock (struct __pthread_rwlock *rwlock){\n  __pthread_spin_wait (&rwlock->__lock);\n  if (__pthread_spin_trylock (&rwlock->__held) == 0)\n    /* Successfully acquired the lock.  */\n    {\n      assert (rwlock->__readerqueue == 0);\n      assert (rwlock->__writerqueue == 0);\n      assert (rwlock->__readers == 0);\n\n      rwlock->__readers = 1;\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n  else\n    /* Lock is held, but is held by a reader?  */\n  if (rwlock->__readers > 0)\n    {\n      assert (rwlock->__readerqueue == 0);\n      rwlock->__readers++;\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n\n  /* The lock is busy.  */\n\n  __pthread_spin_unlock (&rwlock->__lock);\n\n  return EBUSY;\n}",
    "pthread_rwlock_trywrlock": "pthread_rwlock_trywrlock (struct __pthread_rwlock *rwlock){\n  __pthread_spin_wait (&rwlock->__lock);\n  if (__pthread_spin_trylock (&rwlock->__held) == 0)\n    /* Successfully acquired the lock.  */\n    {\n      assert (rwlock->__readerqueue == 0);\n      assert (rwlock->__writerqueue == 0);\n      assert (rwlock->__readers == 0);\n\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n\n  /* The lock is busy.  */\n\n  __pthread_spin_unlock (&rwlock->__lock);\n\n  return EBUSY;\n}",
    "__pthread_rwlock_unlock": "__pthread_rwlock_unlock (pthread_rwlock_t *rwlock){\n  struct __pthread *wakeup;\n\n  __pthread_spin_wait (&rwlock->__lock);\n\n  assert (__pthread_spin_trylock (&rwlock->__held) == EBUSY);\n\n  if (rwlock->__readers > 1)\n    /* There are other readers.  */\n    {\n      rwlock->__readers--;\n      __pthread_spin_unlock (&rwlock->__lock);\n      return 0;\n    }\n\n  if (rwlock->__readers == 1)\n    /* Last reader.  */\n    rwlock->__readers = 0;\n\n\n  /* Wake someone else up.  Try the writer queue first, then the\n     reader queue if that is empty.  */\n\n  if (rwlock->__writerqueue)\n    {\n      wakeup = rwlock->__writerqueue;\n      __pthread_dequeue (wakeup);\n\n      /* We do not unlock RWLOCK->held: we are transferring the ownership\n         to the thread that we are waking up.  */\n\n      __pthread_spin_unlock (&rwlock->__lock);\n      __pthread_wakeup (wakeup);\n\n      return 0;\n    }\n\n  if (rwlock->__readerqueue)\n    {\n      unsigned n = 0;\n\n      __pthread_queue_iterate (rwlock->__readerqueue, wakeup)\n\tn++;\n\n      {\n\tstruct __pthread *wakeups[n];\n\tunsigned i = 0;\n\n\t__pthread_dequeuing_iterate (rwlock->__readerqueue, wakeup)\n\t  wakeups[i++] = wakeup;\n\n\trwlock->__readers += n;\n\trwlock->__readerqueue = 0;\n\n\t__pthread_spin_unlock (&rwlock->__lock);\n\n\tfor (i = 0; i < n; i++)\n\t  __pthread_wakeup (wakeups[i]);\n      }\n\n      return 0;\n    }\n\n\n  /* No one is waiting.  Just unlock it.  */\n\n  __pthread_spin_unlock (&rwlock->__held);\n  __pthread_spin_unlock (&rwlock->__lock);\n  return 0;\n}",
    "__pthread_rwlock_wrlock": "__pthread_rwlock_wrlock (struct __pthread_rwlock *rwlock){\n  return __pthread_rwlock_timedwrlock_internal (rwlock, -1, 0);\n}",
    "pthread_rwlockattr_destroy": "pthread_rwlockattr_destroy (pthread_rwlockattr_t *attr){\n  return 0;\n}",
    "pthread_rwlockattr_getpshared": "pthread_rwlockattr_getpshared (const pthread_rwlockattr_t *attr, int *pshared){\n  *pshared = attr->__pshared;\n  return 0;\n}",
    "pthread_rwlockattr_init": "pthread_rwlockattr_init (pthread_rwlockattr_t *attr){\n  ASSERT_TYPE_SIZE (pthread_rwlockattr_t, __SIZEOF_PTHREAD_RWLOCKATTR_T);\n\n  *attr = __pthread_default_rwlockattr;\n  return 0;\n}",
    "pthread_rwlockattr_setpshared": "pthread_rwlockattr_setpshared (pthread_rwlockattr_t *attr, int pshared){\n  switch (pshared)\n    {\n    case PTHREAD_PROCESS_PRIVATE:\n      attr->__pshared = pshared;\n      return 0;\n\n    case PTHREAD_PROCESS_SHARED:\n      return ENOTSUP;\n\n    default:\n      return EINVAL;\n    }\n}",
    "pthread_setconcurrency": "pthread_setconcurrency (int new_level){\n  if (new_level < 0)\n    return EINVAL;\n\n  __pthread_concurrency = new_level;\n\n  return 0;\n}",
    "pthread_setschedprio": "pthread_setschedprio (pthread_t thread, int prio){\n  return ENOSYS;\n}",
    "__pthread_setspecific": "__pthread_setspecific (pthread_key_t key, const void *value){\n  struct __pthread *self = _pthread_self ();\n\n  if (key < 0 || key >= __pthread_key_count)\n    return EINVAL;\n\n  if (self->thread_specifics == NULL)\n    {\n      if (key < PTHREAD_STATIC_KEYS)\n\t{\n\t  self->static_thread_specifics[key] = (void *) value;\n\t  return 0;\n\t}\n    }\n\n  if (key >= self->thread_specifics_size)\n    {\n      /* Amortize reallocation cost.  */\n      int newsize = 2 * key + 1;\n      void **new;\n\n      if (self->thread_specifics == NULL)\n\t{\n\t  self->thread_specifics_size = PTHREAD_STATIC_KEYS;\n\t  new = malloc (newsize * sizeof (new[0]));\n\t  if (new != NULL)\n\t    memcpy (new, self->static_thread_specifics,\n\t\t    PTHREAD_STATIC_KEYS * sizeof (new[0]));\n\t}\n      else\n\t{\n\t  new = realloc (self->thread_specifics,\n\t\t\t newsize * sizeof (new[0]));\n\t}\n      if (new == NULL)\n\treturn ENOMEM;\n\n      memset (&new[self->thread_specifics_size], 0,\n\t      (newsize - self->thread_specifics_size) * sizeof (new[0]));\n      self->thread_specifics = new;\n      self->thread_specifics_size = newsize;\n    }\n\n  self->thread_specifics[key] = (void *) value;\n  return 0;\n}",
    "init_module": "init_module (void){\n  int i;\n\n  INIT_LIST_HEAD (&timer_free_list);\n  INIT_LIST_HEAD (&thread_free_list);\n  INIT_LIST_HEAD (&thread_active_list);\n\n  for (i = 0; i < TIMER_MAX; ++i)\n    {\n      list_append (&timer_free_list, &__timer_array[i].links);\n      __timer_array[i].inuse = TIMER_FREE;\n    }\n\n  for (i = 0; i < THREAD_MAXNODES; ++i)\n    list_append (&thread_free_list, &thread_array[i].links);\n\n  thread_init (&__timer_signal_thread_rclk, 0, CLOCK_REALTIME);\n}",
    "strlen": "strlen (const char *str){\n  int cnt;\n\n  asm(\"cld\\n\"\t\t\t/* Search forward.  */\n      /* Some old versions of gas need `repne' instead of `repnz'.  */\n      \"repnz\\n\"\t\t\t/* Look for a zero byte.  */\n      \"scasb\" /* %0, %1, %3 */ :\n      \"=c\" (cnt) : \"D\" (str), \"0\" (-1), \"a\" (0));\n\n  return -2 - cnt;\n}",
    "__isinfl": "attribute_hidden\n__isinfl (double x){\n  return isinf (x);\n}",
    "__finite": "__finite (double x){\n  return _FCLASS (x) & ~(_FCLASS_INF | _FCLASS_NAN);\n}",
    "__fpclassify": "__fpclassify (double x){\n  int cls = _FCLASS (x);\n  if (__builtin_expect (cls & _FCLASS_NORM, _FCLASS_NORM))\n    return FP_NORMAL;\n  if (__builtin_expect (cls & _FCLASS_ZERO, _FCLASS_ZERO))\n    return FP_ZERO;\n  if (__builtin_expect (cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))\n    return FP_SUBNORMAL;\n  if (__builtin_expect (cls & _FCLASS_INF, _FCLASS_INF))\n    return FP_INFINITE;\n  return FP_NAN;\n}",
    "__isinf": "__isinf (double x){\n  int cls = _FCLASS (x);\n  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);\n}",
    "__issignaling": "__issignaling (double x){\n  return (_FCLASS (x) & _FCLASS_SNAN) != 0;\n}",
    "__fpclassifyf": "__fpclassifyf (float x){\n  int cls = _FCLASS (x);\n  if (__builtin_expect (cls & _FCLASS_NORM, _FCLASS_NORM))\n    return FP_NORMAL;\n  if (__builtin_expect (cls & _FCLASS_ZERO, _FCLASS_ZERO))\n    return FP_ZERO;\n  if (__builtin_expect (cls & _FCLASS_SUBNORM, _FCLASS_SUBNORM))\n    return FP_SUBNORMAL;\n  if (__builtin_expect (cls & _FCLASS_INF, _FCLASS_INF))\n    return FP_INFINITE;\n  return FP_NAN;\n}",
    "__isinff": "__isinff (float x){\n  int cls = _FCLASS (x);\n  return -((cls & _FCLASS_MINF) ? 1 : 0) | ((cls & _FCLASS_PINF) ? 1 : 0);\n}",
    "__isnanf": "__isnanf (float x){\n  return (_FCLASS (x) & _FCLASS_NAN) != 0;\n}",
    "__issignalingf": "__issignalingf (float x){\n  return (_FCLASS (x) & _FCLASS_SNAN) != 0;\n}",
    "__signbitf": "__signbitf (float x){\n  return __builtin_signbitf (x);\n}",
    "__finitel": "attribute_hidden\n__finitel (double x){\n  return isfinite (x);\n}",
    "__fpclassifyl": "__fpclassifyl (long double x){\n  uint32_t ex, hx, lx;\n  int retval = FP_NORMAL;\n\n  GET_LDOUBLE_WORDS (ex, hx, lx, x);\n  ex &= 0x7fff;\n  if ((ex | lx | hx) == 0)\n    retval = FP_ZERO;\n  else if (ex == 0 && (hx & 0x80000000) == 0)\n    retval = FP_SUBNORMAL;\n  /* Pseudo-normals, i.e. pseudo-zero, pseudo-infinity and un-normals.  They\n     behave like NaNs, so categorize them as such.  */\n  else if ((hx & 0x80000000) == 0)\n    retval = FP_NAN;\n  else if (ex == 0x7fff)\n    retval = ((hx & 0x7fffffff) | lx) != 0 ? FP_NAN : FP_INFINITE;\n\n  return retval;\n}",
    "__isnanl": "__isnanl(long double x){\n\tint32_t se,hx,lx,pn;\n\tGET_LDOUBLE_WORDS(se,hx,lx,x);\n\tse = (se & 0x7fff) << 1;\n\t/* Detect pseudo-normal numbers, i.e. exponent is non-zero and the top\n\t   bit of the significand is not set.   */\n\tpn = (uint32_t)((~hx & 0x80000000) & (se|(-se)))>>31;\n\t/* Clear the significand bit when computing mantissa.  */\n\tlx |= hx & 0x7fffffff;\n\tse |= (uint32_t)(lx|(-lx))>>31;\n\tse = 0xfffe - se;\n\n\treturn (int)(((uint32_t)(se)) >> 16) | pn;\n}",
    "__issignalingl": "__issignalingl (long double x){\n  uint32_t exi, hxi, lxi;\n  GET_LDOUBLE_WORDS (exi, hxi, lxi, x);\n\n  /* By default we do not recognize a pseudo NaN as sNaN.  However on 80387 and\n     later all pseudo numbers including pseudo NaNs result in a signal and are\n     hence recognized as signaling.  */\n  int ret = is_pseudo_signaling (exi, hxi);\n\n#if HIGH_ORDER_BIT_IS_SET_FOR_SNAN\n# error not implemented\n#else\n  /* To keep the following comparison simple, toggle the quiet/signaling bit,\n     so that it is set for sNaNs.  This is inverse to IEEE 754-2008 (as well as\n     common practice for IEEE 754-1985).  */\n  hxi ^= 0x40000000;\n  /* If lxi != 0, then set any suitable bit of the significand in hxi.  */\n  hxi |= (lxi | -lxi) >> 31;\n  /* We have to compare for greater (instead of greater or equal), because x's\n     significand being all-zero designates infinity not NaN.  */\n  return ret || (((exi & 0x7fff) == 0x7fff) && (hxi > 0xc0000000));\n#endif\n}",
    "__signbitl": "attribute_hidden\n__signbitl (double x){\n  return signbit (x);\n}",
    "__iscanonicall": "__iscanonicall (long double x){\n  uint32_t se, i0, i1 __attribute__ ((unused));\n\n  GET_LDOUBLE_WORDS (se, i0, i1, x);\n  int32_t ix = se & 0x7fff;\n  bool mant_high = (i0 & 0x80000000) != 0;\n\n  if (LDBL_MIN_EXP == -16381)\n    /* Intel variant: the high mantissa bit should have a value\n       determined by the exponent.  */\n    return ix > 0 ? mant_high : !mant_high;\n  else\n    /* M68K variant: both values of the high bit are valid for the\n       greatest and smallest exponents, while other exponents require\n       the high bit to be set.  */\n    return ix == 0 || ix == 0x7fff || mant_high;\n}",
    "acosl": "attribute_hidden\nacosl (double x){\n  return acos (x);\n}",
    "acoshl": "attribute_hidden\nacoshl (double x){\n  return acosh (x);\n}",
    "asinl": "attribute_hidden\nasinl (double x){\n  return asin (x);\n}",
    "asinhl": "attribute_hidden\nasinhl (double x){\n  return asinh (x);\n}",
    "__asprintf": "__asprintf (char **string_ptr, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vasprintf (string_ptr, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__asprintf_chk": "__asprintf_chk (char **string_ptr, int flag, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vasprintf_chk (string_ptr, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "atanl": "attribute_hidden\natanl (double x){\n  return atan (x);\n}",
    "atan2l": "attribute_hidden\natan2l (double x, double y){\n  return atan2 (x, y);\n}",
    "atanhl": "attribute_hidden\natanhl (double x){\n  return atanh (x);\n}",
    "cabsl": "attribute_hidden\ncabsl (double _Complex x){\n  return cabs (x);\n}",
    "cacosl": "cacosl (double _Complex x){\n  return cacos (x);\n}",
    "cacoshl": "cacoshl (double _Complex x){\n  return cacosh (x);\n}",
    "canonicalizel": "attribute_hidden\ncanonicalizel (double *cx, double *x){\n  return canonicalize (cx, x);\n}",
    "cargl": "attribute_hidden\ncargl (double _Complex x){\n  return carg (x);\n}",
    "casinl": "casinl (double _Complex x){\n  return casin (x);\n}",
    "casinhl": "casinhl (double _Complex x){\n  return casinh (x);\n}",
    "catanl": "catanl (double _Complex x){\n  return catan (x);\n}",
    "catanhl": "catanhl (double _Complex x){\n  return catanh (x);\n}",
    "cbrtl": "attribute_hidden\ncbrtl (double x){\n  return cbrt (x);\n}",
    "ccosl": "ccosl (double _Complex x){\n  return ccos (x);\n}",
    "ccoshl": "ccoshl (double _Complex x){\n  return ccosh (x);\n}",
    "ceill": "attribute_hidden\nceill (double x){\n  return ceil (x);\n}",
    "cexpl": "cexpl (double _Complex x){\n  return cexp (x);\n}",
    "cimagl": "attribute_hidden\ncimagl (double _Complex x){\n  return cimag (x);\n}",
    "clogl": "clogl (double _Complex x){\n  return clog (x);\n}",
    "clog10l": "clog10l (double _Complex x){\n  return clog10 (x);\n}",
    "conjl": "conjl (double _Complex x){\n  return conj (x);\n}",
    "copysignl": "attribute_hidden\ncopysignl (double x, double y){\n  return copysign (x, y);\n}",
    "cosl": "attribute_hidden\ncosl (double x){\n  return cos (x);\n}",
    "coshl": "attribute_hidden\ncoshl (double x){\n  return cosh (x);\n}",
    "cpowl": "cpowl (double _Complex x, double _Complex y){\n  return cpow (x, y);\n}",
    "cprojl": "cprojl (double _Complex x){\n  return cproj (x);\n}",
    "creall": "attribute_hidden\ncreall (double _Complex x){\n  return creal (x);\n}",
    "csinl": "csinl (double _Complex x){\n  return csin (x);\n}",
    "csinhl": "csinhl (double _Complex x){\n  return csinh (x);\n}",
    "csqrtl": "csqrtl (double _Complex x){\n  return csqrt (x);\n}",
    "ctanl": "ctanl (double _Complex x){\n  return ctan (x);\n}",
    "ctanhl": "ctanhl (double _Complex x){\n  return ctanh (x);\n}",
    "daddl": "attribute_hidden\ndaddl (double x, double y){\n  return __nldbl_daddl (x, y);\n}",
    "ddivl": "attribute_hidden\nddivl (double x, double y){\n  return __nldbl_ddivl (x, y);\n}",
    "dfmal": "attribute_hidden\ndfmal (double x, double y, double z){\n  return fma (x, y, z);\n}",
    "dmull": "attribute_hidden\ndmull (double x, double y){\n  return __nldbl_dmull (x, y);\n}",
    "dprintf": "dprintf (int d, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vdprintf (d, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "dsqrtl": "attribute_hidden\ndsqrtl (double x){\n  return sqrt (x);\n}",
    "dsubl": "attribute_hidden\ndsubl (double x, double y){\n  return __nldbl_dsubl (x, y);\n}",
    "erfl": "attribute_hidden\nerfl (double x){\n  return erf (x);\n}",
    "erfcl": "attribute_hidden\nerfcl (double x){\n  return erfc (x);\n}",
    "expl": "attribute_hidden\nexpl (double x){\n  return exp (x);\n}",
    "exp10l": "attribute_hidden\nexp10l (double x){\n  return exp10 (x);\n}",
    "exp2l": "attribute_hidden\nexp2l (double x){\n  return exp2 (x);\n}",
    "expm1l": "attribute_hidden\nexpm1l (double x){\n  return expm1 (x);\n}",
    "fabsl": "attribute_hidden\nfabsl (double x){\n  return fabs (x);\n}",
    "faddl": "attribute_hidden\nfaddl (double x, double y){\n  return fadd (x, y);\n}",
    "fdiml": "attribute_hidden\nfdiml (double x, double y){\n  return fdim (x, y);\n}",
    "fdivl": "attribute_hidden\nfdivl (double x, double y){\n  return fdiv (x, y);\n}",
    "ffmal": "attribute_hidden\nffmal (double x, double y, double z){\n  return ffma (x, y, z);\n}",
    "floorl": "attribute_hidden\nfloorl (double x){\n  return floor (x);\n}",
    "fmal": "attribute_hidden\nfmal (double x, double y, double z){\n  return fma (x, y, z);\n}",
    "fmaxl": "attribute_hidden\nfmaxl (double x, double y){\n  return fmax (x, y);\n}",
    "fmaximuml": "attribute_hidden\nfmaximuml (double x, double y){\n  return fmaximum (x, y);\n}",
    "fmaximum_magl": "attribute_hidden\nfmaximum_magl (double x, double y){\n  return fmaximum_mag (x, y);\n}",
    "fmaximum_mag_numl": "fmaximum_mag_numl (double x, double y){\n  return fmaximum_mag_num (x, y);\n}",
    "fmaximum_numl": "attribute_hidden\nfmaximum_numl (double x, double y){\n  return fmaximum_num (x, y);\n}",
    "fmaxmagl": "attribute_hidden\nfmaxmagl (double x, double y){\n  return fmaxmag (x, y);\n}",
    "fminl": "attribute_hidden\nfminl (double x, double y){\n  return fmin (x, y);\n}",
    "fminimuml": "attribute_hidden\nfminimuml (double x, double y){\n  return fminimum (x, y);\n}",
    "fminimum_magl": "attribute_hidden\nfminimum_magl (double x, double y){\n  return fminimum_mag (x, y);\n}",
    "fminimum_mag_numl": "fminimum_mag_numl (double x, double y){\n  return fminimum_mag_num (x, y);\n}",
    "fminimum_numl": "attribute_hidden\nfminimum_numl (double x, double y){\n  return fminimum_num (x, y);\n}",
    "fminmagl": "attribute_hidden\nfminmagl (double x, double y){\n  return fminmag (x, y);\n}",
    "fmodl": "attribute_hidden\nfmodl (double x, double y){\n  return fmod (x, y);\n}",
    "fmull": "attribute_hidden\nfmull (double x, double y){\n  return fmul (x, y);\n}",
    "fprintf": "fprintf (FILE *stream, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfprintf (stream, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__fprintf_chk": "attribute_hidden\n__fprintf_chk (FILE *stream, int flag, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vfprintf_chk (stream, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "frexpl": "attribute_hidden\nfrexpl (double x, int *exponent){\n  return frexp (x, exponent);\n}",
    "fromfpl": "attribute_hidden\nfromfpl (double x, int round, unsigned int width){\n  return fromfp (x, round, width);\n}",
    "fromfpxl": "attribute_hidden\nfromfpxl (double x, int round, unsigned int width){\n  return fromfpx (x, round, width);\n}",
    "fscanf": "attribute_hidden\nfscanf (FILE *stream, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl__IO_vfscanf (stream, fmt, arg, NULL);\n  va_end (arg);\n\n  return done;\n}",
    "fsqrtl": "attribute_hidden\nfsqrtl (double x){\n  return fsqrt (x);\n}",
    "fsubl": "attribute_hidden\nfsubl (double x, double y){\n  return fsub (x, y);\n}",
    "fwprintf": "fwprintf (FILE *stream, const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfwprintf (stream, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "fwscanf": "attribute_hidden\nfwscanf (FILE *stream, const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfwscanf (stream, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "gammal": "attribute_hidden\ngammal (double x){\n  return gamma (x);\n}",
    "getpayloadl": "attribute_hidden\ngetpayloadl (const double *x){\n  return getpayload (x);\n}",
    "hypotl": "attribute_hidden\nhypotl (double x, double y){\n  return hypot (x, y);\n}",
    "ilogbl": "attribute_hidden\nilogbl (double x){\n  return ilogb (x);\n}",
    "_IO_vfscanf": "attribute_hidden\n_IO_vfscanf (FILE *s, const char *fmt, va_list ap, int *errp){\n  return __nldbl__IO_vfscanf (s, fmt, ap, errp);\n}",
    "__isoc23_fwscanf": "__isoc23_fwscanf (FILE *stream, const wchar_t *format, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stream, format, arg,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_swscanf": "__isoc23_swscanf (const wchar_t *s, const wchar_t *format, ...){\n  va_list arg;\n  int done;\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, s);\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (f, format, arg,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc23_vfwscanf": "__isoc23_vfwscanf (FILE *stream, const wchar_t *format, va_list args){\n  return __vfwscanf_internal (stream, format, args,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_vswscanf": "__isoc23_vswscanf (const wchar_t *string, const wchar_t *format, va_list args){\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, string);\n  return __vfwscanf_internal (f, format, args,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_vwscanf": "__isoc23_vwscanf (const wchar_t *format, va_list args){\n  return __vfwscanf_internal (stdin, format, args,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n}",
    "__isoc23_wscanf": "__isoc23_wscanf (const wchar_t *format, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stdin, format, arg,\n\t\t\t      SCANF_ISOC99_A | SCANF_ISOC23_BIN_CST);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_fwscanf": "__isoc99_fwscanf (FILE *stream, const wchar_t *format, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stream, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_swscanf": "__isoc99_swscanf (const wchar_t *s, const wchar_t *format, ...){\n  va_list arg;\n  int done;\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, s);\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (f, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "__isoc99_vfwscanf": "__isoc99_vfwscanf (FILE *stream, const wchar_t *format, va_list args){\n  return __vfwscanf_internal (stream, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_vswscanf": "__isoc99_vswscanf (const wchar_t *string, const wchar_t *format, va_list args){\n  _IO_strfile sf;\n  struct _IO_wide_data wd;\n  FILE *f = _IO_strfile_readw (&sf, &wd, string);\n  return __vfwscanf_internal (f, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_vwscanf": "__isoc99_vwscanf (const wchar_t *format, va_list args){\n  return __vfwscanf_internal (stdin, format, args, SCANF_ISOC99_A);\n}",
    "__isoc99_wscanf": "__isoc99_wscanf (const wchar_t *format, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, format);\n  done = __vfwscanf_internal (stdin, format, arg, SCANF_ISOC99_A);\n  va_end (arg);\n\n  return done;\n}",
    "j0l": "attribute_hidden\nj0l (double x){\n  return j0 (x);\n}",
    "j1l": "attribute_hidden\nj1l (double x){\n  return j1 (x);\n}",
    "jnl": "attribute_hidden\njnl (int n, double x){\n  return jn (n, x);\n}",
    "ldexpl": "attribute_hidden\nldexpl (double x, int exponent){\n  return ldexp (x, exponent);\n}",
    "lgammal": "attribute_hidden\nlgammal (double x){\n  return lgamma (x);\n}",
    "lgammal_r": "attribute_hidden\nlgammal_r (double x, int *signgamp){\n  return lgamma_r (x, signgamp);\n}",
    "llogbl": "attribute_hidden\nllogbl (double x){\n  return llogb (x);\n}",
    "llrintl": "attribute_hidden\nllrintl (double x){\n  return llrint (x);\n}",
    "llroundl": "attribute_hidden\nllroundl (double x){\n  return llround (x);\n}",
    "logl": "attribute_hidden\nlogl (double x){\n  return log (x);\n}",
    "log10l": "attribute_hidden\nlog10l (double x){\n  return log10 (x);\n}",
    "log1pl": "attribute_hidden\nlog1pl (double x){\n  return log1p (x);\n}",
    "log2l": "attribute_hidden\nlog2l (double x){\n  return log2 (x);\n}",
    "logbl": "attribute_hidden\nlogbl (double x){\n  return logb (x);\n}",
    "lrintl": "attribute_hidden\nlrintl (double x){\n  return lrint (x);\n}",
    "lroundl": "attribute_hidden\nlroundl (double x){\n  return lround (x);\n}",
    "modfl": "attribute_hidden\nmodfl (double x, double *iptr){\n  return modf (x, iptr);\n}",
    "nanl": "attribute_hidden\nnanl (const char *tag){\n  return nan (tag);\n}",
    "nearbyintl": "attribute_hidden\nnearbyintl (double x){\n  return nearbyint (x);\n}",
    "nextafterl": "attribute_hidden\nnextafterl (double x, double y){\n  return nextafter (x, y);\n}",
    "nextdownl": "attribute_hidden\nnextdownl (double x){\n  return nextdown (x);\n}",
    "nexttoward": "attribute_hidden\nnexttoward (double x, double y){\n  return nextafter (x, y);\n}",
    "nexttowardf": "attribute_hidden\nnexttowardf (float x, double y){\n  return __nldbl_nexttowardf (x, y);\n}",
    "nextupl": "attribute_hidden\nnextupl (double x){\n  return nextup (x);\n}",
    "obstack_printf": "attribute_hidden\nobstack_printf (struct obstack *obstack, const char *fmt, ...){\n  int result;\n  va_list ap;\n  va_start (ap, fmt);\n  result = __nldbl_obstack_vprintf (obstack, fmt, ap);\n  va_end (ap);\n  return result;\n}",
    "obstack_vprintf": "attribute_hidden\nobstack_vprintf (struct obstack *obstack, const char *fmt, va_list ap){\n  return __nldbl_obstack_vprintf (obstack, fmt, ap);\n}",
    "powl": "attribute_hidden\npowl (double x, double y){\n  return pow (x, y);\n}",
    "printf": "attribute_hidden\nprintf (const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfprintf (stdout, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__printf_chk": "attribute_hidden\n__printf_chk (int flag, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vfprintf_chk (stdout, flag, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__printf_fp": "attribute_hidden\n__printf_fp (FILE *fp, const struct printf_info *info,\n\t     const void *const *args){\n  return __nldbl___printf_fp (fp, info, args);\n}",
    "printf_size": "attribute_hidden\nprintf_size (FILE *__restrict fp, const struct printf_info *info,\n\t     const void *const *__restrict args){\n  return __nldbl_printf_size (fp, info, args);\n}",
    "qecvt": "*\nqecvt (double val, int ndigit, int *__restrict decpt, int *__restrict sign){\n  return ecvt (val, ndigit, decpt, sign);\n}",
    "qecvt_r": "attribute_hidden\nqecvt_r (double val, int ndigit, int *__restrict decpt, int *__restrict sign,\n\t char *__restrict buf, size_t len){\n  return ecvt_r (val, ndigit, decpt, sign, buf, len);\n}",
    "qfcvt": "*\nqfcvt (double val, int ndigit, int *__restrict decpt, int *__restrict sign){\n  return fcvt (val, ndigit, decpt, sign);\n}",
    "qfcvt_r": "attribute_hidden\nqfcvt_r (double val, int ndigit, int *__restrict decpt, int *__restrict sign,\n\t char *__restrict buf, size_t len){\n  return fcvt_r (val, ndigit, decpt, sign, buf, len);\n}",
    "qgcvt": "*\nqgcvt (double val, int ndigit, char *buf){\n  return gcvt (val, ndigit, buf);\n}",
    "remainderl": "attribute_hidden\nremainderl (double x, double y){\n  return remainder (x, y);\n}",
    "remquol": "attribute_hidden\nremquol (double x, double y, int *quo){\n  return remquo (x, y, quo);\n}",
    "rintl": "attribute_hidden\nrintl (double x){\n  return rint (x);\n}",
    "roundl": "attribute_hidden\nroundl (double x){\n  return round (x);\n}",
    "roundevenl": "attribute_hidden\nroundevenl (double x){\n  return roundeven (x);\n}",
    "scalbl": "attribute_hidden\nscalbl (double x, double n){\n  return scalb (x, n);\n}",
    "scalblnl": "attribute_hidden\nscalblnl (double x, long int n){\n  return scalbln (x, n);\n}",
    "scalbnl": "attribute_hidden\nscalbnl (double x, int n){\n  return scalbn (x, n);\n}",
    "scanf": "attribute_hidden\nscanf (const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl__IO_vfscanf (stdin, fmt, arg, NULL);\n  va_end (arg);\n\n  return done;\n}",
    "setpayloadl": "attribute_hidden\nsetpayloadl (double *x, double payload){\n  return setpayload (x, payload);\n}",
    "setpayloadsigl": "attribute_hidden\nsetpayloadsigl (double *x, double payload){\n  return setpayloadsig (x, payload);\n}",
    "significandl": "attribute_hidden\nsignificandl (double x){\n  return significand (x);\n}",
    "sinl": "attribute_hidden\nsinl (double x){\n  return sin (x);\n}",
    "sincosl": "attribute_hidden\nsincosl (double x, double *sinx, double *cosx){\n  sincos (x, sinx, cosx);\n}",
    "sinhl": "attribute_hidden\nsinhl (double x){\n  return sinh (x);\n}",
    "snprintf": "snprintf (char *s, size_t maxlen, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vsnprintf (s, maxlen, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__snprintf_chk": "attribute_hidden\n__snprintf_chk (char *s, size_t maxlen, int flag, size_t slen,\n\t\tconst char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vsnprintf_chk (s, maxlen, flag, slen, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "sprintf": "attribute_hidden\nsprintf (char *s, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vsprintf (s, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "__sprintf_chk": "attribute_hidden\n__sprintf_chk (char *s, int flag, size_t slen, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl___vsprintf_chk (s, flag, slen, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "sqrtl": "attribute_hidden\nsqrtl (double x){\n  return sqrt (x);\n}",
    "sscanf": "attribute_hidden\nsscanf (const char *s, const char *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vsscanf (s, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "strfmon": "attribute_hidden\nstrfmon (char *s, size_t maxsize, const char *format, ...){\n  va_list ap;\n  ssize_t res;\n\n  va_start (ap, format);\n  res = __nldbl___vstrfmon (s, maxsize, format, ap);\n  va_end (ap);\n  return res;\n}",
    "__strfmon_l": "attribute_hidden\n__strfmon_l (char *s, size_t maxsize, locale_t loc, const char *format, ...){\n  va_list ap;\n  ssize_t res;\n\n  va_start (ap, format);\n  res = __nldbl___vstrfmon_l (s, maxsize, loc, format, ap);\n  va_end (ap);\n  return res;\n}",
    "strfroml": "attribute_hidden\nstrfroml (char *dest, size_t size, const char *format, long double f){\n  return strfromd (dest, size, format, f);\n}",
    "strtold": "attribute_hidden\nstrtold (const char *nptr, char **endptr){\n  return strtod (nptr, endptr);\n}",
    "__strtold_l": "attribute_hidden\n__strtold_l (const char *nptr, char **endptr, locale_t loc){\n  return __strtod_l (nptr, endptr, loc);\n}",
    "__strtold_internal": "__strtold_internal (const char *nptr, char **endptr, int group){\n  return __strtod_internal (nptr, endptr, group);\n}",
    "swprintf": "attribute_hidden\nswprintf (wchar_t *s, size_t n, const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vswprintf (s, n, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "swscanf": "attribute_hidden\nswscanf (const wchar_t *s, const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vswscanf (s, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "syslog": "attribute_hidden\nsyslog (int pri, const char *fmt, ...){\n  va_list ap;\n  va_start (ap, fmt);\n  __nldbl_vsyslog (pri, fmt, ap);\n  va_end (ap);\n}",
    "__syslog_chk": "attribute_hidden\n__syslog_chk (int pri, int flag, const char *fmt, ...){\n  va_list ap;\n\n  va_start (ap, fmt);\n  __nldbl___vsyslog_chk (pri, flag, fmt, ap);\n  va_end(ap);\n}",
    "tanl": "attribute_hidden\ntanl (double x){\n  return tan (x);\n}",
    "tanhl": "attribute_hidden\ntanhl (double x){\n  return tanh (x);\n}",
    "tgammal": "attribute_hidden\ntgammal (double x){\n  return tgamma (x);\n}",
    "totalorderl": "attribute_hidden\ntotalorderl (const double *x, const double *y){\n  return totalorder (x, y);\n}",
    "totalordermagl": "attribute_hidden\ntotalordermagl (const double *x, const double *y){\n  return totalordermag (x, y);\n}",
    "truncl": "attribute_hidden\ntruncl (double x){\n  return trunc (x);\n}",
    "ufromfpl": "attribute_hidden\nufromfpl (double x, int round, unsigned int width){\n  return ufromfp (x, round, width);\n}",
    "ufromfpxl": "attribute_hidden\nufromfpxl (double x, int round, unsigned int width){\n  return ufromfpx (x, round, width);\n}",
    "vasprintf": "vasprintf (char **result_ptr, const char *fmt, va_list ap){\n  return __nldbl_vasprintf (result_ptr, fmt, ap);\n}",
    "vdprintf": "attribute_hidden\nvdprintf (int d, const char *fmt, va_list arg){\n  return __nldbl_vdprintf (d, fmt, arg);\n}",
    "__vfprintf_chk": "attribute_hidden\n__vfprintf_chk (FILE *s, int flag, const char *fmt, va_list ap){\n  return __nldbl___vfprintf_chk (s, flag, fmt, ap);\n}",
    "__vfscanf": "attribute_hidden\n__vfscanf (FILE *s, const char *fmt, va_list ap){\n  return __nldbl__IO_vfscanf (s, fmt, ap, NULL);\n}",
    "vfwprintf": "vfwprintf (FILE *s, const wchar_t *fmt, va_list ap){\n  return __nldbl_vfwprintf (s, fmt, ap);\n}",
    "vfwscanf": "attribute_hidden\nvfwscanf (FILE *s, const wchar_t *fmt, va_list ap){\n  return __nldbl_vfwscanf (s, fmt, ap);\n}",
    "vprintf": "attribute_hidden\nvprintf (const char *fmt, va_list ap){\n  return __nldbl_vfprintf (stdout, fmt, ap);\n}",
    "__vprintf_chk": "attribute_hidden\n__vprintf_chk (int flag, const char *fmt, va_list ap){\n  return __nldbl___vfprintf_chk (stdout, flag, fmt, ap);\n}",
    "vscanf": "vscanf (const char *fmt, va_list ap){\n  return __nldbl__IO_vfscanf (stdin, fmt, ap, NULL);\n}",
    "vsnprintf": "attribute_hidden\nvsnprintf (char *string, size_t maxlen, const char *fmt, va_list ap){\n  return __nldbl_vsnprintf (string, maxlen, fmt, ap);\n}",
    "__vsnprintf_chk": "attribute_hidden\n__vsnprintf_chk (char *string, size_t maxlen, int flag, size_t slen,\n\t\t const char *fmt, va_list ap){\n  return __nldbl___vsnprintf_chk (string, maxlen, flag, slen, fmt, ap);\n}",
    "_IO_vsprintf": "attribute_hidden\n_IO_vsprintf (char *string, const char *fmt, va_list ap){\n  return __nldbl_vsprintf (string, fmt, ap);\n}",
    "__vsprintf_chk": "attribute_hidden\n__vsprintf_chk (char *string, int flag, size_t slen, const char *fmt,\n\t\tva_list ap){\n  return __nldbl___vsprintf_chk (string, flag, slen, fmt, ap);\n}",
    "__vsscanf": "attribute_hidden\n__vsscanf (const char *string, const char *fmt, va_list ap){\n  return __nldbl_vsscanf (string, fmt, ap);\n}",
    "vswprintf": "vswprintf (wchar_t *string, size_t maxlen, const wchar_t *fmt, va_list ap){\n  return __nldbl_vswprintf (string, maxlen, fmt, ap);\n}",
    "vswscanf": "attribute_hidden\nvswscanf (const wchar_t *string, const wchar_t *fmt, va_list ap){\n  return __nldbl_vswscanf (string, fmt, ap);\n}",
    "vsyslog": "vsyslog (int pri, const char *fmt, va_list ap){\n  __nldbl_vsyslog (pri, fmt, ap);\n}",
    "vwprintf": "attribute_hidden\nvwprintf (const wchar_t *fmt, va_list ap){\n  return __nldbl_vfwprintf (stdout, fmt, ap);\n}",
    "vwscanf": "vwscanf (const wchar_t *fmt, va_list ap){\n  return __nldbl_vfwscanf (stdin, fmt, ap);\n}",
    "wcstold": "attribute_hidden\nwcstold (const wchar_t *nptr, wchar_t **endptr){\n  return wcstod (nptr, endptr);\n}",
    "__wcstold_l": "attribute_hidden\n__wcstold_l (const wchar_t *nptr, wchar_t **endptr, locale_t loc){\n  return __wcstod_l (nptr, endptr, loc);\n}",
    "__wcstold_internal": "__wcstold_internal (const wchar_t *nptr, wchar_t **endptr, int group){\n  return __wcstod_internal (nptr, endptr, group);\n}",
    "wprintf": "attribute_hidden\nwprintf (const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfwprintf (stdout, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "wscanf": "attribute_hidden\nwscanf (const wchar_t *fmt, ...){\n  va_list arg;\n  int done;\n\n  va_start (arg, fmt);\n  done = __nldbl_vfwscanf (stdin, fmt, arg);\n  va_end (arg);\n\n  return done;\n}",
    "y0l": "attribute_hidden\ny0l (double x){\n  return y0 (x);\n}",
    "y1l": "attribute_hidden\ny1l (double x){\n  return y1 (x);\n}",
    "ynl": "attribute_hidden\nynl (int n, double x){\n  return yn (n, x);\n}",
    "__finitef": "__finitef (float x){\n  return _FCLASS (x) & ~(_FCLASS_INF | _FCLASS_NAN);\n}",
    "__clock_gettime": "__clock_gettime (clockid_t clock_id, struct timespec *tp){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "clock": "clock (void){\n  __set_errno (ENOSYS);\n  return (clock_t) -1;\n}",
    "__close_nocancel": "__close_nocancel (int fd){\n  return INLINE_SYSCALL_CALL (close, fd);\n}",
    "__open": "weak_function\n__open (const char *file_name, int mode, ...){\n  mach_port_t port;\n  error_t err = open_file (file_name, mode, &port, 0);\n  if (err)\n    return __hurd_fail (err);\n  else\n    return (int)port;\n}",
    "__pread64": "weak_function\n__pread64 (int fd, void *buf, size_t nbytes, off64_t offset){\n  error_t err;\n  char *data;\n  mach_msg_type_number_t nread;\n\n  data = buf;\n  nread = nbytes;\n  err = __io_read ((mach_port_t) fd, &data, &nread, offset, nbytes);\n  if (err)\n    return __hurd_fail (err);\n\n  if (data != buf)\n    {\n      memcpy (buf, data, nread);\n      __vm_deallocate (__mach_task_self (), (vm_address_t) data, nread);\n    }\n\n  return nread;\n}",
    "__read": "__ssize_t weak_function\n__read (int fd, void *buf, size_t nbytes){\n  return __pread64 (fd, buf, nbytes, -1);\n}",
    "__write": "__ssize_t weak_function\n__write (int fd, const void *buf, size_t nbytes){\n  error_t err;\n  vm_size_t nwrote;\n\n  assert (fd < _hurd_init_dtablesize);\n\n  err = __io_write (_hurd_init_dtable[fd], buf, nbytes, -1, &nwrote);\n  if (err)\n    return __hurd_fail (err);\n\n  return nwrote;\n}",
    "__strtoul_internal": "__strtoul_internal (const char *nptr, char **endptr, int base, int group){\n  assert (base == 0 || base == 10);\n  assert (group == 0);\n  return _dl_strtoul (nptr, endptr);\n}",
    "fstatvfs": "fstatvfs (int fd, struct statvfs *buf){\n  /* `struct statvfs' is in fact identical to `struct statfs' so we\n     can simply call fstatfs.  */\n  return __fstatfs (fd, (struct statfs *)buf);\n}",
    "fstatvfs64": "fstatvfs64 (int fd, struct statvfs64 *buf){\n  /* `struct statvfs64' is in fact identical to `struct statfs64' so\n     we can simply call fstatfs64.  */\n  return __fstatfs64 (fd, (struct statfs64 *)buf);\n}",
    "__fxstat": "__fxstat (int vers, int fd, struct stat *buf){\n  switch (vers)\n    {\n    case _STAT_VER_KERNEL:\n      return INLINE_SYSCALL_CALL (fstat, fd, buf);\n\n    default:\n      {\n\tstruct kernel_stat kbuf;\n\tint r = INTERNAL_SYSCALL_CALL (fstat, fd, &kbuf);\n\tif (r == 0)\n\t  return  __xstat_conv (vers, &kbuf, buf);\n\treturn INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);\n      }\n    }\n}",
    "__fxstat64": "__fxstat64 (int vers, int fd, struct stat64 *buf){\n  struct kernel_stat kbuf;\n  int r = INLINE_SYSCALL_CALL (fstat, fd, &kbuf);\n  return r ?: __xstat64_conv (vers, &kbuf, buf);\n\n}",
    "__fxstatat": "__fxstatat (int vers, int fd, const char *file, struct stat *st, int flag){\n  struct kernel_stat kst;\n  int r = INLINE_SYSCALL_CALL (newfstatat, fd, file, &kst, flag);\n  return r ?: __xstat_conv (vers, &kst, st);\n}",
    "__fxstatat64": "__fxstatat64 (int vers, int fd, const char *file, struct stat64 *st, int flag){\n  if (vers == _STAT_VER_LINUX)\n    {\n      struct kernel_stat kst;\n      int r = INLINE_SYSCALL_CALL (newfstatat, fd, file, &kst, flag);;\n      return r ?: __xstat64_conv (vers, &kst, st);\n    }\n  return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n}",
    "__lxstat": "__lxstat (int vers, const char *name, struct stat *buf){\n  switch (vers)\n    {\n    case _STAT_VER_KERNEL:\n      return INLINE_SYSCALL_CALL (lstat, name, buf);\n\n    default:\n      {\n\tstruct kernel_stat kbuf;\n\tint r = INTERNAL_SYSCALL_CALL (lstat, name, &kbuf);\n\tif (r == 0)\n\t  return  __xstat_conv (vers, &kbuf, buf);\n\treturn INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);\n      }\n    }\n}",
    "__lxstat64": "__lxstat64 (int vers, const char *name, struct stat64 *buf){\n  struct kernel_stat kbuf;\n  int r = INLINE_SYSCALL_CALL (lstat, name, &kbuf);\n  return r ?: __xstat64_conv (vers, &kbuf, buf);\n}",
    "__open_nocancel": "__open_nocancel (const char *file, int oflag, ...){\n  int mode = 0;\n\n  if (__OPEN_NEEDS_MODE (oflag))\n    {\n      va_list arg;\n      va_start (arg, oflag);\n      mode = va_arg (arg, int);\n      va_end (arg);\n    }\n\n  return INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag, mode);\n}",
    "__pread64_nocancel": "__pread64_nocancel (int fd, void *buf, size_t count, off64_t offset){\n  return INLINE_SYSCALL_CALL (pread64, fd, buf, count, SYSCALL_LL64_PRW (offset));\n}",
    "ptsname": "*\nptsname (int fd){\n  return __ptsname_r (fd, buffer, sizeof (buffer)) != 0 ? NULL : buffer;\n}",
    "__read_nocancel": "__read_nocancel (int fd, void *buf, size_t nbytes){\n  return INLINE_SYSCALL_CALL (read, fd, buf, nbytes);\n}",
    "statvfs": "statvfs (const char *file, struct statvfs *buf){\n  /* `struct statvfs' is in fact identical to `struct statfs' so we\n     can simply call statfs.  */\n  return __statfs (file, (struct statfs *)buf);\n}",
    "statvfs64": "statvfs64 (const char *file, struct statvfs64 *buf){\n  /* `struct statvfs64' is in fact identical to `struct statfs64' so\n     we can simply call statfs64.  */\n  return __statfs64 (file, (struct statfs64 *)buf);\n}",
    "__write_nocancel": "__write_nocancel (int fd, const void *buf, size_t nbytes){\n  return INLINE_SYSCALL_CALL (write, fd, buf, nbytes);\n}",
    "__xmknod": "__xmknod (int vers, const char *path, mode_t mode, dev_t *dev){\n  if (vers != _MKNOD_VER)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n  return __mknodat (AT_FDCWD, path, mode, *dev);\n}",
    "__xmknodat": "__xmknodat (int vers, int fd, const char *file, mode_t mode, dev_t *dev){\n  if (vers != _MKNOD_VER)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EINVAL);\n\n  return __mknodat (fd, file, mode, *dev);\n}",
    "__xstat": "__xstat (int vers, const char *name, struct stat *buf){\n  switch (vers)\n    {\n    case _STAT_VER_KERNEL:\n      return INLINE_SYSCALL_CALL (stat, name, buf);\n\n    default:\n      {\n\tstruct kernel_stat kbuf;\n\tint r = INTERNAL_SYSCALL_CALL (stat, name, &kbuf);\n\tif (r == 0)\n\t  return  __xstat_conv (vers, &kbuf, buf);\n\treturn INLINE_SYSCALL_ERROR_RETURN_VALUE (-r);\n      }\n    }\n}",
    "__xstat64": "__xstat64 (int vers, const char *name, struct stat64 *buf){\n  struct kernel_stat kbuf;\n  int r = INLINE_SYSCALL_CALL (stat, name, &kbuf);\n  return r ?: __xstat64_conv (vers, &kbuf, buf);\n}",
    "pthread_mutex_consistent": "pthread_mutex_consistent (pthread_mutex_t *mtxp){\n  int ret = EINVAL;\n  unsigned int val = mtxp->__lock;\n\n  if ((mtxp->__flags & PTHREAD_MUTEX_ROBUST) != 0\n      && (val & LLL_DEAD_OWNER) != 0\n      && atomic_compare_and_exchange_bool_acq (&mtxp->__lock,\n\t\t\t\t\t       __getpid () | LLL_WAITERS,\n\t\t\t\t\t       val) == 0)\n    {\n      /* The mutex is now ours, and it's consistent. */\n      mtxp->__owner_id = _pthread_self ()->thread;\n      mtxp->__cnt = 1;\n      ret = 0;\n    }\n\n  return ret;\n}",
    "__pthread_mutex_destroy": "__pthread_mutex_destroy (pthread_mutex_t *mtxp){\n  atomic_read_barrier ();\n  if (*(volatile unsigned int *) &mtxp->__lock != 0)\n    return EBUSY;\n\n  mtxp->__type = -1;\n  return 0;\n}",
    "pthread_mutex_getprioceiling": "pthread_mutex_getprioceiling (const pthread_mutex_t *mtxp, int *clp){\n  (void) mtxp;\n  (void) clp;\n  return ENOSYS;\n}",
    "__pthread_mutex_init": "__pthread_mutex_init (pthread_mutex_t *mtxp, const pthread_mutexattr_t *attrp){\n  ASSERT_TYPE_SIZE (pthread_mutex_t, __SIZEOF_PTHREAD_MUTEX_T);\n\n  if (attrp == NULL)\n    attrp = &dfl_attr;\n\n  mtxp->__flags = (attrp->__pshared == PTHREAD_PROCESS_SHARED\n\t\t   ? GSYNC_SHARED : 0) | ((attrp->__prioceiling\n\t\t\t\t\t   & PTHREAD_MUTEX_ROBUST)\n\t\t\t\t\t  ? PTHREAD_MUTEX_ROBUST : 0);\n\n  mtxp->__type = (attrp->__mutex_type\n\t\t  + (attrp->__mutex_type != __PTHREAD_MUTEX_TIMED));\n\n  mtxp->__owner_id = 0;\n  mtxp->__shpid = 0;\n  mtxp->__cnt = 0;\n  mtxp->__lock = 0;\n\n  return 0;\n}",
    "__pthread_mutex_lock": "__pthread_mutex_lock (pthread_mutex_t *mtxp){\n  struct __pthread *self;\n  int flags = mtxp->__flags & GSYNC_SHARED;\n  int ret = 0;\n\n  switch (MTX_TYPE (mtxp))\n    {\n    case PT_MTX_NORMAL:\n      lll_lock (mtxp->__lock, flags);\n      break;\n\n    case PT_MTX_RECURSIVE:\n      self = _pthread_self ();\n      if (mtx_owned_p (mtxp, self, flags))\n\t{\n\t  if (__glibc_unlikely (mtxp->__cnt + 1 == 0))\n\t    return EAGAIN;\n\n\t  ++mtxp->__cnt;\n\t  return ret;\n\t}\n\n      lll_lock (mtxp->__lock, flags);\n      mtx_set_owner (mtxp, self, flags);\n      mtxp->__cnt = 1;\n      break;\n\n    case PT_MTX_ERRORCHECK:\n      self = _pthread_self ();\n      if (mtx_owned_p (mtxp, self, flags))\n\treturn EDEADLK;\n\n      lll_lock (mtxp->__lock, flags);\n      mtx_set_owner (mtxp, self, flags);\n      break;\n\n    case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST:\n      self = _pthread_self ();\n      ROBUST_LOCK (self, mtxp, lll_robust_lock, flags);\n      break;\n\n    default:\n      ret = EINVAL;\n      break;\n    }\n\n  return ret;\n}",
    "pthread_mutex_setprioceiling": "pthread_mutex_setprioceiling (pthread_mutex_t *mtxp, int cl, int *prp){\n  (void) mtxp;\n  (void) cl;\n  (void) prp;\n  return ENOSYS;\n}",
    "__pthread_mutex_trylock": "__pthread_mutex_trylock (pthread_mutex_t *mtxp){\n  struct __pthread *self;\n  int ret;\n\n  switch (MTX_TYPE (mtxp))\n    {\n    case PT_MTX_NORMAL:\n      ret = lll_trylock (mtxp->__lock);\n      if (ret)\n\tret = EBUSY;\n      break;\n\n    case PT_MTX_RECURSIVE:\n      self = _pthread_self ();\n      if (mtx_owned_p (mtxp, self, mtxp->__flags))\n\t{\n\t  if (__glibc_unlikely (mtxp->__cnt + 1 == 0))\n\t    return EAGAIN;\n\n\t  ++mtxp->__cnt;\n\t  ret = 0;\n\t}\n      else if ((ret = lll_trylock (mtxp->__lock)) == 0)\n\t{\n\t  mtx_set_owner (mtxp, self, mtxp->__flags);\n\t  mtxp->__cnt = 1;\n\t}\n      else\n\tret = EBUSY;\n\n      break;\n\n    case PT_MTX_ERRORCHECK:\n      self = _pthread_self ();\n      if ((ret = lll_trylock (mtxp->__lock)) == 0)\n\tmtx_set_owner (mtxp, self, mtxp->__flags);\n      else\n\tret = EBUSY;\n      break;\n\n    case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST:\n      self = _pthread_self ();\n      ROBUST_LOCK (self, mtxp, lll_robust_trylock);\n      break;\n\n    default:\n      ret = EINVAL;\n      break;\n    }\n\n  return ret;\n}",
    "__pthread_mutex_unlock": "__pthread_mutex_unlock (pthread_mutex_t *mtxp){\n  struct __pthread *self;\n  int ret = 0, flags = mtxp->__flags & GSYNC_SHARED;\n\n  switch (MTX_TYPE (mtxp))\n    {\n    case PT_MTX_NORMAL:\n      lll_unlock (mtxp->__lock, flags);\n      break;\n\n    case PT_MTX_RECURSIVE:\n      self = _pthread_self ();\n      if (!mtx_owned_p (mtxp, self, flags))\n\tret = EPERM;\n      else if (--mtxp->__cnt == 0)\n\t{\n\t  mtxp->__owner_id = mtxp->__shpid = 0;\n\t  lll_unlock (mtxp->__lock, flags);\n\t}\n\n      break;\n\n    case PT_MTX_ERRORCHECK:\n      self = _pthread_self ();\n      if (!mtx_owned_p (mtxp, self, flags))\n\tret = EPERM;\n      else\n\t{\n\t  mtxp->__owner_id = mtxp->__shpid = 0;\n\t  lll_unlock (mtxp->__lock, flags);\n\t}\n\n      break;\n\n    case PT_MTX_NORMAL | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_RECURSIVE | PTHREAD_MUTEX_ROBUST:\n    case PT_MTX_ERRORCHECK | PTHREAD_MUTEX_ROBUST:\n      self = _pthread_self ();\n      if (mtxp->__owner_id == NOTRECOVERABLE_ID)\n\t;\t\t\t/* Nothing to do. */\n      else if (mtxp->__owner_id != self->thread\n\t       || (int) (mtxp->__lock & LLL_OWNER_MASK) != __getpid ())\n\tret = EPERM;\n      else if (--mtxp->__cnt == 0)\n\t{\n\t  /* Release the lock. If it's in an inconsistent\n\t   * state, mark it as irrecoverable. */\n\t  mtxp->__owner_id = ((mtxp->__lock & LLL_DEAD_OWNER)\n\t\t\t      ? NOTRECOVERABLE_ID : 0);\n\t  lll_robust_unlock (mtxp->__lock, flags);\n\t}\n\n      break;\n\n    default:\n      ret = EINVAL;\n      break;\n    }\n\n  return ret;\n}",
    "__pthread_mutexattr_destroy": "__pthread_mutexattr_destroy (pthread_mutexattr_t *attrp){\n  (void) attrp;\n  return 0;\n}",
    "pthread_mutexattr_getprioceiling": "pthread_mutexattr_getprioceiling (const pthread_mutexattr_t *ap, int *clp){\n  (void) ap;\n  (void) clp;\n  return ENOSYS;\n}",
    "pthread_mutexattr_getprotocol": "pthread_mutexattr_getprotocol (const pthread_mutexattr_t *attrp, int *ptp){\n  *ptp = attrp->__protocol;\n  return 0;\n}",
    "pthread_mutexattr_getpshared": "pthread_mutexattr_getpshared (const pthread_mutexattr_t *attrp, int *outp){\n  *outp = attrp->__pshared;\n  return 0;\n}",
    "pthread_mutexattr_getrobust": "pthread_mutexattr_getrobust (const pthread_mutexattr_t *attrp, int *outp){\n  *outp = ((attrp->__prioceiling & PTHREAD_MUTEX_ROBUST)\n\t   ? PTHREAD_MUTEX_ROBUST : PTHREAD_MUTEX_STALLED);\n  return 0;\n}",
    "pthread_mutexattr_gettype": "pthread_mutexattr_gettype (const pthread_mutexattr_t *attrp, int *outp){\n  *outp = attrp->__mutex_type;\n  return 0;\n}",
    "__pthread_mutexattr_init": "__pthread_mutexattr_init (pthread_mutexattr_t *attrp){\n  ASSERT_TYPE_SIZE (pthread_mutexattr_t, __SIZEOF_PTHREAD_MUTEXATTR_T);\n\n  *attrp = dfl_attr;\n  return 0;\n}",
    "pthread_mutexattr_setprioceiling": "pthread_mutexattr_setprioceiling (pthread_mutexattr_t *attrp, int cl){\n  (void) attrp;\n  (void) cl;\n  return ENOSYS;\n}",
    "pthread_mutexattr_setprotocol": "pthread_mutexattr_setprotocol (pthread_mutexattr_t *attrp, int proto){\n  (void) attrp;\n  return (proto == PTHREAD_PRIO_NONE\n\t  ? 0\n\t  : (proto != PTHREAD_PRIO_INHERIT\n\t     && proto != PTHREAD_PRIO_PROTECT) ? EINVAL : ENOTSUP);\n}",
    "pthread_mutexattr_setpshared": "pthread_mutexattr_setpshared (pthread_mutexattr_t *attrp, int pshared){\n  if (pshared != PTHREAD_PROCESS_PRIVATE && pshared != PTHREAD_PROCESS_SHARED)\n    return EINVAL;\n\n  attrp->__pshared = pshared;\n  return 0;\n}",
    "pthread_mutexattr_setrobust": "pthread_mutexattr_setrobust (pthread_mutexattr_t *attrp, int robust){\n  if (robust != PTHREAD_MUTEX_ROBUST && robust != PTHREAD_MUTEX_STALLED)\n    return EINVAL;\n\n  attrp->__prioceiling |= robust;\n  return 0;\n}",
    "__pthread_mutexattr_settype": "__pthread_mutexattr_settype (pthread_mutexattr_t *attrp, int type){\n  if (type < 0 || type > __PTHREAD_MUTEX_RECURSIVE)\n    return EINVAL;\n\n  attrp->__mutex_type = type;\n  return 0;\n}",
    "ioperm": "ioperm (unsigned long int from, unsigned long int num, int turn_on){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "euidaccess": "euidaccess (const char *path, int mode){\n  struct __stat64_t64 stats;\n  int granted;\n\n#ifdef\t_LIBC\n  uid_t euid;\n  gid_t egid;\n#else\n  if (have_ids == 0)\n    {\n      have_ids = 1;\n      uid = getuid ();\n      gid = getgid ();\n      euid = geteuid ();\n      egid = getegid ();\n    }\n\n  if (uid == euid && gid == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return access (path, mode);\n#endif\n\n  if (__stat64_time64 (path, &stats))\n    return -1;\n\n  mode &= (X_OK | W_OK | R_OK);\t/* Clear any bogus bits. */\n#if R_OK != S_IROTH || W_OK != S_IWOTH || X_OK != S_IXOTH\n  ?error Oops, portability assumptions incorrect.\n#endif\n\n  if (mode == F_OK)\n    return 0;\t\t\t/* The file exists. */\n\n#ifdef\t_LIBC\n  /* Now we need the IDs.  */\n  euid = __geteuid ();\n  egid = __getegid ();\n\n  if (__getuid () == euid && __getgid () == egid)\n    /* If we are not set-uid or set-gid, access does the same.  */\n    return __access (path, mode);\n#endif\n\n  /* The super-user can read and write any file, and execute any file\n     that anyone can execute. */\n  if (euid == 0 && ((mode & X_OK) == 0\n\t\t    || (stats.st_mode & (S_IXUSR | S_IXGRP | S_IXOTH))))\n    return 0;\n\n  if (euid == stats.st_uid)\n    granted = (unsigned int) (stats.st_mode & (mode << 6)) >> 6;\n  else if (egid == stats.st_gid || group_member (stats.st_gid))\n    granted = (unsigned int) (stats.st_mode & (mode << 3)) >> 3;\n  else\n    granted = (stats.st_mode & mode);\n  /* XXX Add support for ACLs.  */\n  if (granted == mode)\n    return 0;\n  __set_errno (EACCESS);\n  return -1;\n}",
    "__xpg_sigpause": "__xpg_sigpause (int sig){\n  return __sigpause (sig, 1);\n}",
    "cnd_timedwait": "cnd_timedwait (cnd_t *restrict cond, mtx_t *restrict mutex,\n\t       const struct timespec* restrict time_point){\n  int err_code = __pthread_cond_timedwait ((pthread_cond_t *) cond,\n\t\t\t\t\t   (pthread_mutex_t *) mutex,\n\t\t\t\t\t   time_point);\n  return thrd_err_map (err_code);\n}",
    "mtx_timedlock": "mtx_timedlock (mtx_t *restrict mutex,\n\t       const struct timespec *restrict time_point){\n  int err_code = __pthread_mutex_timedlock ((pthread_mutex_t *)mutex,\n\t\t\t\t\t    time_point);\n  return thrd_err_map (err_code);\n}",
    "thrd_equal": "thrd_equal (thrd_t lhs, thrd_t rhs){\n  return lhs == rhs;\n}",
    "thrd_sleep": "thrd_sleep (const struct timespec* time_point, struct timespec* remaining){\n  int ret = __clock_nanosleep (CLOCK_REALTIME, 0, time_point, remaining);\n  /* C11 states thrd_sleep function returns -1 if it has been interrupted\n     by a signal, or a negative value if it fails.  */\n  switch (ret)\n  {\n     case 0:      return 0;\n     case EINTR:  return -1;\n     default:     return -2;\n  }\n}",
    "grantpt": "grantpt (int fd){\n  /* Without pt_chown on Linux, we have delegated the creation of the\n     pty node with the right group and permission mode to the kernel, and\n     non-root users are unlikely to be able to change it. Therefore let's\n     consider that POSIX enforcement is the responsibility of the whole\n     system and not only the GNU libc.   */\n\n  /* Verify that fd refers to a ptmx descriptor.  */\n  unsigned int ptyno;\n  int ret = __ioctl (fd, TIOCGPTN, &ptyno);\n  if (ret != 0 && errno == ENOTTY)\n    /* POSIX requires EINVAL instead of ENOTTY provided by the kernel.  */\n    __set_errno (EINVAL);\n  return ret;\n}",
    "tcflow": "tcflow (int fd, int action){\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  switch (action)\n    {\n    case TCOOFF:\n    case TCOON:\n    case TCIOFF:\n    case TCION:\n      break;\n\n    default:\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "tcflush": "tcflush (int fd, int queue_selector){\n  switch (queue_selector)\n    {\n    case TCIFLUSH:\n    case TCOFLUSH:\n    case TCIOFLUSH:\n      break;\n\n    default:\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "tcgetpgrp": "tcgetpgrp (int fd){\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return (pid_t) -1;\n    }\n\n  __set_errno (ENOSYS);\n  return (pid_t) -1;\n}",
    "tcsendbreak": "tcsendbreak (int fd, int duration){\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "tcsetattr": "tcsetattr (int fd, int optional_actions, const struct termios *termios_p){\n  if (fd < 0)\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n  if (termios_p == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  switch (optional_actions)\n    {\n    case TCSANOW:\n    case TCSADRAIN:\n    case TCSAFLUSH:\n      break;\n    default:\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  if (bad_speed(termios_p->__ospeed)\n      || bad_speed(termios_p->__ispeed == 0\n\t\t   ? termios_p->__ospeed : termios_p->__ispeed))\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "unlockpt": "unlockpt (int fd){\n  int unlock = 0;\n\n  int ret = __ioctl (fd, TIOCSPTLCK, &unlock);\n  if (ret != 0 && errno == ENOTTY)\n    /* POSIX mandates EINVAL for non-ptmx descriptors.  */\n    __set_errno (EINVAL);\n  return ret;\n}",
    "accept4": "accept4 (int fd, __SOCKADDR_ARG addr, socklen_t *addr_len, int flags){\n#ifdef __ASSUME_ACCEPT4_SYSCALL\n  return SYSCALL_CANCEL (accept4, fd, addr.__sockaddr__, addr_len, flags);\n#else\n  return SOCKETCALL_CANCEL (accept4, fd, addr.__sockaddr__, addr_len, flags);\n#endif\n}",
    "__cmsg_nxthdr": "*\n__cmsg_nxthdr (struct msghdr *mhdr, struct cmsghdr *cmsg){\n  /* We may safely assume that cmsg lies between mhdr->msg_control and\n     mhdr->msg_controllen because the user is required to obtain the first\n     cmsg via CMSG_FIRSTHDR, set its length, then obtain subsequent cmsgs\n     via CMSG_NXTHDR, setting lengths along the way.  However, we don't yet\n     trust the value of cmsg->cmsg_len and therefore do not use it in any\n     pointer arithmetic until we check its value.  */\n\n  unsigned char * msg_control_ptr = (unsigned char *) mhdr->msg_control;\n  unsigned char * cmsg_ptr = (unsigned char *) cmsg;\n\n  size_t size_needed = sizeof (struct cmsghdr)\n                       + __CMSG_PADDING (cmsg->cmsg_len);\n\n  /* The current header is malformed, too small to be a full header.  */\n  if ((size_t) cmsg->cmsg_len < sizeof (struct cmsghdr))\n    return (struct cmsghdr *) 0;\n\n  /* There isn't enough space between cmsg and the end of the buffer to\n  hold the current cmsg *and* the next one.  */\n  if (((size_t)\n         (msg_control_ptr + mhdr->msg_controllen - cmsg_ptr)\n       < size_needed)\n      || ((size_t)\n            (msg_control_ptr + mhdr->msg_controllen - cmsg_ptr\n             - size_needed)\n          < cmsg->cmsg_len))\n\n    return (struct cmsghdr *) 0;\n\n  /* Now, we trust cmsg_len and can use it to find the next header.  */\n  cmsg = (struct cmsghdr *) ((unsigned char *) cmsg\n\t\t\t     + CMSG_ALIGN (cmsg->cmsg_len));\n  return cmsg;\n}",
    "openat64": "openat64 (int dfd, const char *file, int oflag, ...){\n  assert (!__OPEN_NEEDS_MODE (oflag));\n\n  return INLINE_SYSCALL (openat, 3, dfd, file, oflag | O_LARGEFILE);\n}",
    "epoll_create": "epoll_create (int size){\n#ifdef __NR_epoll_create\n  return INLINE_SYSCALL_CALL (epoll_create, size);\n#else\n  if (size <= 0)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  return INLINE_SYSCALL_CALL (epoll_create1, 0);\n#endif\n}",
    "epoll_pwait": "epoll_pwait (int epfd, struct epoll_event *events,\n\t\t int maxevents, int timeout,\n\t\t const sigset_t *set){\n  return SYSCALL_CANCEL (epoll_pwait, epfd, events, maxevents,\n\t\t\t timeout, set, __NSIG_BYTES);\n}",
    "epoll_pwait2": "epoll_pwait2 (int fd, struct epoll_event *ev, int maxev,\n\t      const struct timespec *tmo, const sigset_t *s){\n  struct __timespec64 tmo64, *ptmo64 = NULL;\n  if (tmo != NULL)\n    {\n      tmo64 = valid_timespec_to_timespec64 (*tmo);\n      ptmo64 = &tmo64;\n    }\n  return __epoll_pwait2_time64 (fd, ev, maxev, ptmo64, s);\n}",
    "epoll_wait": "epoll_wait (int epfd, struct epoll_event *events, int maxevents, int timeout){\n#ifdef __NR_epoll_wait\n  return SYSCALL_CANCEL (epoll_wait, epfd, events, maxevents, timeout);\n#else\n  return epoll_pwait (epfd, events, maxevents, timeout, NULL);\n#endif\n}",
    "eventfd_read": "eventfd_read (int fd, eventfd_t *value){\n  return __read (fd, value, sizeof (eventfd_t)) != sizeof (eventfd_t) ? -1 : 0;\n}",
    "eventfd_write": "eventfd_write (int fd, eventfd_t value){\n  return __write (fd, &value,\n\t\t  sizeof (eventfd_t)) != sizeof (eventfd_t) ? -1 : 0;\n}",
    "execveat": "execveat (int dirfd, const char *path, char *const argv[], char *const envp[],\n          int flags){\n  /* Avoid implicit array coercion in syscall macros.  */\n  return INLINE_SYSCALL_CALL (execveat, dirfd, path, &argv[0], &envp[0],\n\t\t\t      flags);\n}",
    "fallocate": "fallocate (int fd, int mode, __off_t offset, __off_t len){\n  return SYSCALL_CANCEL (fallocate, fd, mode,\n\t\t\t SYSCALL_LL (offset), SYSCALL_LL (len));\n}",
    "fallocate64": "fallocate64 (int fd, int mode, __off64_t offset, __off64_t len){\n  return SYSCALL_CANCEL (fallocate, fd, mode,\n\t\t\t SYSCALL_LL64 (offset), SYSCALL_LL64 (len));\n}",
    "__libc_fcntl64": "__libc_fcntl64 (int fd, int cmd, ...){\n  va_list ap;\n  void *arg;\n\n  va_start (ap, cmd);\n  arg = va_arg (ap, void *);\n  va_end (ap);\n\n  cmd = FCNTL_ADJUST_CMD (cmd);\n\n  if (cmd == F_SETLKW || cmd == F_SETLKW64 || cmd == F_OFD_SETLKW)\n    return SYSCALL_CANCEL (fcntl64, fd, cmd, arg);\n\n  return __fcntl64_nocancel_adjusted (fd, cmd, arg);\n}",
    "ftime": "ftime (struct timeb *timebuf){\n  struct timespec ts;\n  __clock_gettime (CLOCK_REALTIME, &ts);\n\n  timebuf->time = ts.tv_sec;\n  timebuf->millitm = ts.tv_nsec / 1000000;\n  timebuf->timezone = 0;\n  timebuf->dstflag = 0;\n  return 0;\n}",
    "getdirentries": "getdirentries (int fd, char *buf, size_t nbytes, off_t *basep){\n  off_t base = __lseek (fd, 0, SEEK_CUR);\n\n  ssize_t result = __getdents (fd, buf, nbytes);\n\n  if (result != -1)\n    *basep = base;\n\n  return result;\n}",
    "__gettimeofday": "__gettimeofday (struct timeval *restrict tv, void *restrict tz){\n  struct __timeval64 tv64;\n  if (__gettimeofday64 (&tv64, tz))\n\t  return -1;\n\n  if (! in_time_t_range (tv64.tv_sec))\n    {\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n\n  *tv = valid_timeval64_to_timeval (tv64);\n  return 0;\n}",
    "inotify_init": "inotify_init (void){\n#ifdef __NR_inotify_init\n  return INLINE_SYSCALL_CALL (inotify_init);\n#else\n  return INLINE_SYSCALL_CALL (inotify_init1, 0);\n#endif\n}",
    "listen": "listen (int fd, int backlog){\n#ifdef __ASSUME_LISTEN_SYSCALL\n  return INLINE_SYSCALL_CALL (listen, fd, backlog);\n#else\n  return SOCKETCALL (listen, fd, backlog);\n#endif\n}",
    "__lseek": "__lseek (int fd, off_t offset, int whence){\n  off64_t res = __lseek64 (fd, offset, whence);\n  if (res != (off_t) res)\n    {\n      __set_errno (EOVERFLOW);\n      return (off_t) -1;\n    }\n  return (off_t) res;\n}",
    "mlock2": "mlock2 (const void *addr, size_t length, unsigned int flags){\n#ifdef __ASSUME_MLOCK2\n  return INLINE_SYSCALL_CALL (mlock2, addr, length, flags);\n#else\n  if (flags == 0)\n    return INLINE_SYSCALL_CALL (mlock, addr, length);\n  int ret = INLINE_SYSCALL_CALL (mlock2, addr, length, flags);\n  if (ret == 0 || errno != ENOSYS)\n    return ret;\n  /* Treat the missing system call as an invalid (non-zero) flag\n     argument.  */\n  __set_errno (EINVAL);\n  return -1;\n#endif /* __ASSUME_MLOCK2 */\n}",
    "msgget": "msgget (key_t key, int msgflg){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__libc_msgrcv": "__libc_msgrcv (int msqid, void *msgp, size_t msgsz, long int msgtyp,\n\t       int msgflg){\n#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS\n  return SYSCALL_CANCEL (msgrcv, msqid, msgp, msgsz, msgtyp, msgflg);\n#else\n  return SYSCALL_CANCEL (ipc, IPCOP_msgrcv, msqid, msgsz, msgflg,\n\t\t\t MSGRCV_ARGS (msgp, msgtyp));\n#endif\n}",
    "__libc_msgsnd": "__libc_msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg){\n#ifdef __ASSUME_DIRECT_SYSVIPC_SYSCALLS\n  return SYSCALL_CANCEL (msgsnd, msqid, msgp, msgsz, msgflg);\n#else\n  return SYSCALL_CANCEL (ipc, IPCOP_msgsnd, msqid, msgsz, msgflg,\n\t\t\t msgp);\n#endif\n}",
    "__netlink_assert_response": "__netlink_assert_response (int fd, ssize_t result){\n  if (result < 0)\n    {\n      /* Check if the error is unexpected.  */\n      bool terminate = false;\n      int error_code = errno;\n      int family = get_address_family (fd);\n      if (family != AF_NETLINK)\n        /* If the address family does not match (or getsockname\n           failed), report the original error.  */\n        terminate = true;\n      else if (error_code == EBADF\n          || error_code == ENOTCONN\n          || error_code == ENOTSOCK\n          || error_code == ECONNREFUSED)\n        /* These errors indicate that the descriptor is not a\n           connected socket.  */\n        terminate = true;\n      else if (error_code == EAGAIN || error_code == EWOULDBLOCK)\n        {\n          /* The kernel might return EAGAIN for other reasons than a\n             non-blocking socket.  But if the socket is not blocking,\n             it is not ours, so report the error.  */\n          int mode = __fcntl (fd, F_GETFL, 0);\n          if (mode < 0 || (mode & O_NONBLOCK) != 0)\n            terminate = true;\n        }\n      if (terminate)\n        {\n          char message[200];\n          if (family < 0)\n            __snprintf (message, sizeof (message),\n                        \"Unexpected error %d on netlink descriptor %d.\\n\",\n                        error_code, fd);\n          else\n            __snprintf (message, sizeof (message),\n                        \"Unexpected error %d on netlink descriptor %d\"\n                        \" (address family %d).\\n\",\n                        error_code, fd, family);\n          __libc_fatal (message);\n        }\n      else\n        /* Restore original errno value.  */\n        __set_errno (error_code);\n    }\n  else if (result < sizeof (struct nlmsghdr))\n    {\n      char message[200];\n      int family = get_address_family (fd);\n      if (family < 0)\n          __snprintf (message, sizeof (message),\n                      \"Unexpected netlink response of size %zd\"\n                      \" on descriptor %d\\n\",\n                      result, fd);\n      else\n          __snprintf (message, sizeof (message),\n                      \"Unexpected netlink response of size %zd\"\n                      \" on descriptor %d (address family %d)\\n\",\n                      result, fd, family);\n      __libc_fatal (message);\n    }\n}",
    "__open64_nocancel": "__open64_nocancel (const char *file, int oflag, ...){\n  int mode = 0;\n\n  if (__OPEN_NEEDS_MODE (oflag))\n    {\n      va_list arg;\n      va_start (arg, oflag);\n      mode = va_arg (arg, int);\n      va_end (arg);\n    }\n\n  return INLINE_SYSCALL_CALL (openat, AT_FDCWD, file, oflag | O_LARGEFILE,\n\t\t\t      mode);\n}",
    "open_by_handle_at": "open_by_handle_at (int mount_fd, struct file_handle *handle, int flags){\n  return SYSCALL_CANCEL (open_by_handle_at, mount_fd, handle, flags);\n}",
    "pidfd_getpid": "pidfd_getpid (int fd){\n  if (__glibc_unlikely (fd < 0))\n    {\n      __set_errno (EBADF);\n      return -1;\n    }\n\n  char fdinfoname[FDINFO_FILENAME_LEN];\n\n  char *p = mempcpy (fdinfoname, FDINFO_TO_FILENAME_PREFIX,\n\t\t     strlen (FDINFO_TO_FILENAME_PREFIX));\n  *_fitoa_word (fd, p, 10, 0) = '\\0';\n\n  struct parse_fdinfo_t fdinfo = { .found = false, .pid = -1 };\n  if (!procutils_read_file (fdinfoname, parse_fdinfo, &fdinfo))\n    /* The fdinfo contains an invalid 'Pid:' value.  */\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EBADF);\n\n  /* The FD does not have a 'Pid:' entry associated.  */\n  if (!fdinfo.found)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EBADF);\n\n  /* The pidfd cannot be resolved because it is in a separate pid\n     namespace.  */\n  if (fdinfo.pid == 0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EREMOTE);\n\n  /* A negative value means the process is terminated.  */\n  if (fdinfo.pid < 0)\n    return INLINE_SYSCALL_ERROR_RETURN_VALUE (ESRCH);\n\n  return fdinfo.pid;\n}",
    "pidfd_spawn": "pidfd_spawn (int *pidfd, const char *path,\n\t     const posix_spawn_file_actions_t *file_actions,\n\t     const posix_spawnattr_t *attrp, char *const argv[],\n\t     char *const envp[]){\n  return __spawni (pidfd, path, file_actions, attrp, argv, envp,\n\t\t   SPAWN_XFLAGS_RET_PIDFD);\n}",
    "pidfd_spawnp": "pidfd_spawnp (int *pidfd, const char *path,\n\t      const posix_spawn_file_actions_t *file_actions,\n\t      const posix_spawnattr_t *attrp, char *const argv[],\n\t      char *const envp[]){\n  return __spawni (pidfd, path, file_actions, attrp, argv, envp,\n\t\t   SPAWN_XFLAGS_USE_PATH | SPAWN_XFLAGS_RET_PIDFD);\n}",
    "pkey_get": "pkey_get (int key){\n  if (key < 0 || key > 15)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  unsigned int pkru = pkey_read ();\n  return (pkru >> (2 * key)) & 3;\n  return 0;\n}",
    "pkey_mprotect": "pkey_mprotect (void *addr, size_t len, int prot, int pkey){\n  if (pkey == -1)\n    /* If the key is -1, the system call is precisely equivalent to\n       mprotect.  */\n    return __mprotect (addr, len, prot);\n  return INLINE_SYSCALL_CALL (pkey_mprotect, addr, len, prot, pkey);\n}",
    "pkey_set": "pkey_set (int key, unsigned int rights){\n  if (key < 0 || key > 15 || rights > 3)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n  unsigned int mask = 3 << (2 * key);\n  unsigned int pkru = pkey_read ();\n  pkru = (pkru & ~mask) | (rights << (2 * key));\n  pkey_write (pkru);\n  return 0;\n}",
    "prlimit": "prlimit (__pid_t pid, enum __rlimit_resource resource,\n\t const struct rlimit *new_rlimit, struct rlimit *old_rlimit){\n  struct rlimit64 new_rlimit64_mem;\n  struct rlimit64 *new_rlimit64 = NULL;\n  struct rlimit64 old_rlimit64_mem;\n  struct rlimit64 *old_rlimit64 = (old_rlimit != NULL\n\t\t\t\t   ? &old_rlimit64_mem : NULL);\n\n  if (new_rlimit != NULL)\n    {\n      if (new_rlimit->rlim_cur == RLIM_INFINITY)\n\tnew_rlimit64_mem.rlim_cur = RLIM64_INFINITY;\n      else\n\tnew_rlimit64_mem.rlim_cur = new_rlimit->rlim_cur;\n      if (new_rlimit->rlim_max == RLIM_INFINITY)\n\tnew_rlimit64_mem.rlim_max = RLIM64_INFINITY;\n      else\n\tnew_rlimit64_mem.rlim_max = new_rlimit->rlim_max;\n      new_rlimit64 = &new_rlimit64_mem;\n    }\n\n  int res = INLINE_SYSCALL (prlimit64, 4, pid, resource, new_rlimit64,\n\t\t\t    old_rlimit64);\n\n  if (res == 0 && old_rlimit != NULL)\n    {\n      /* The prlimit64 syscall is ill-designed for 32-bit machines.\n\t We have to provide a 32-bit variant since otherwise the LFS\n\t system would not work.  The infinity value can be translated,\n\t but otherwise what shall we do if the syscall succeeds but the\n\t old values do not fit into a rlimit structure?  We cannot return\n\t an error because the operation itself worked.  Best is perhaps\n\t to return RLIM_INFINITY.  */\n      old_rlimit->rlim_cur = old_rlimit64_mem.rlim_cur;\n      if (old_rlimit->rlim_cur != old_rlimit64_mem.rlim_cur)\n\t{\n\t  if ((new_rlimit == NULL)\n\t      && (old_rlimit64_mem.rlim_cur != RLIM64_INFINITY))\n\t    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EOVERFLOW);\n\t  old_rlimit->rlim_cur = RLIM_INFINITY;\n\t}\n      old_rlimit->rlim_max = old_rlimit64_mem.rlim_max;\n      if (old_rlimit->rlim_max != old_rlimit64_mem.rlim_max)\n\t{\n\t  if ((new_rlimit == NULL)\n\t      && (old_rlimit64_mem.rlim_max != RLIM64_INFINITY))\n\t    return INLINE_SYSCALL_ERROR_RETURN_VALUE (EOVERFLOW);\n\t  old_rlimit->rlim_max = RLIM_INFINITY;\n\t}\n    }\n\n  return res;\n}",
    "process_vm_readv": "process_vm_readv (pid_t pid, const struct iovec *local_iov,\n\t\t  unsigned long int liovcnt,\n\t\t  const struct iovec *remote_iov,\n\t\t  unsigned long int riovcnt, unsigned long int flags){\n  return INLINE_SYSCALL_CALL (process_vm_readv, pid, local_iov,\n\t\t\t      liovcnt, remote_iov, riovcnt, flags);\n}",
    "process_vm_writev": "process_vm_writev (pid_t pid, const struct iovec *local_iov,\n\t\t   unsigned long int liovcnt,\n\t\t   const struct iovec *remote_iov,\n\t\t   unsigned long int riovcnt, unsigned long int flags){\n  return INLINE_SYSCALL_CALL (process_vm_writev, pid, local_iov,\n\t\t\t      liovcnt, remote_iov, riovcnt, flags);\n}",
    "sched_getcpu": "sched_getcpu (void){\n  return vsyscall_sched_getcpu ();\n}",
    "semget": "semget (key_t key, int nsems, int semflg){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "semop": "semop (int semid, struct sembuf *sops, size_t nsops){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shmat": "*\nshmat (int shmid, const void *shmaddr, int shmflg){\n  __set_errno (ENOSYS);\n  return (void *) -1;\n}",
    "shmdt": "shmdt (const void *shmaddr){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shmget": "shmget (key_t key, size_t size, int shmflg){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "signalfd": "signalfd (int fd, const sigset_t *mask, int flags){\n  return INLINE_SYSCALL (signalfd4, 4, fd, mask, __NSIG_BYTES, flags);\n}",
    "posix_spawnattr_getcgroup_np": "posix_spawnattr_getcgroup_np (const posix_spawnattr_t *attr,\n\t\t\t      int *cgroup){\n  *cgroup = attr->__cgroup;\n\n  return 0;\n}",
    "posix_spawnattr_setcgroup_np": "posix_spawnattr_setcgroup_np (posix_spawnattr_t *attr, int cgroup){\n  attr->__cgroup = cgroup;\n\n  return 0;\n}",
    "cfgetospeed": "cfgetospeed (const struct termios *termios_p){\n  return termios_p->__ospeed;\n}",
    "cfgetispeed": "cfgetispeed (const struct termios *termios_p){\n  return termios_p->__ispeed;\n}",
    "cfsetospeed": "cfsetospeed (struct termios *termios_p, speed_t speed){\n  if (termios_p == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  termios_p->__ospeed = speed;\n  return 0;\n}",
    "cfsetispeed": "cfsetispeed (struct termios *termios_p, speed_t speed){\n  if (termios_p == NULL)\n    {\n      __set_errno (EINVAL);\n      return -1;\n    }\n\n  termios_p->__ispeed = speed;\n  return 0;\n}",
    "splice": "splice (int fd_in, loff_t *off_in, int fd_out, loff_t *off_out, size_t len,\n\tunsigned int flags){\n  return SYSCALL_CANCEL (splice, fd_in, off_in, fd_out, off_out, len, flags);\n}",
    "sync_file_range": "sync_file_range (int fd, __off64_t offset, __off64_t len, unsigned int flags){\n#if defined (__NR_sync_file_range2)\n  return SYSCALL_CANCEL (sync_file_range2, fd, flags, SYSCALL_LL64 (offset),\n\t\t\t SYSCALL_LL64 (len));\n#elif defined (__NR_sync_file_range)\n  return SYSCALL_CANCEL (sync_file_range, fd,\n\t\t\t __ALIGNMENT_ARG SYSCALL_LL64 (offset),\n\t\t\t SYSCALL_LL64 (len), flags);\n#endif\n}",
    "tee": "tee (int src, int dest, size_t len, unsigned int flags){\n  return SYSCALL_CANCEL (tee, src, dest, len, flags);\n}",
    "time": "time (time_t *timer){\n  struct timespec ts;\n  __clock_gettime (TIME_CLOCK_GETTIME_CLOCKID, &ts);\n\n  if (timer)\n    *timer = ts.tv_sec;\n  return ts.tv_sec;\n}",
    "vmsplice": "vmsplice (int fd, const struct iovec *iov, size_t count, unsigned int flags){\n  return SYSCALL_CANCEL (vmsplice, fd, iov, count, flags);\n}",
    "iopl": "iopl (unsigned int level){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "__clone": "__clone (int (*fn)(void *), void *child_stack,\n\t int flags, void *arg, ...\n\t /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ ){\n  void *ptid;\n  void *tls;\n  void *ctid;\n  va_list ap;\n  int err;\n\n  va_start (ap, arg);\n  ptid = va_arg (ap, void *);\n  tls = va_arg (ap, void *);\n  ctid = va_arg (ap, void *);\n  va_end (ap);\n\n  /* Sanity check the arguments */\n  err = -EINVAL;\n  if (!fn)\n    goto syscall_error;\n  if (!child_stack)\n    goto syscall_error;\n\n  return __or1k_clone (fn, child_stack, flags, arg, ptid, tls, ctid);\n\nsyscall_error:\n  __set_errno (-err);\n  return -1;\n}",
    "__arch_prctl": "__arch_prctl (int code, uintptr_t *addr){\n  int res;\n  uint64_t addr64;\n  void *prctl_arg = addr;\n\n  switch (code)\n    {\n    case ARCH_GET_FS:\n    case ARCH_GET_GS:\n      prctl_arg = &addr64;\n      break;\n    }\n\n  res = INLINE_SYSCALL (arch_prctl, 2, code, prctl_arg);\n  if (res == 0)\n    switch (code)\n      {\n      case ARCH_GET_FS:\n      case ARCH_GET_GS:\n\t /* Check for a large value that overflows.  */\n\tif ((uintptr_t) addr64 != addr64)\n\t  {\n\t    __set_errno (EOVERFLOW);\n\t    return -1;\n\t  }\n\t*addr = (uintptr_t) addr64;\n\tbreak;\n      }\n\n  return res;\n}",
    "__x86_get_cpuid_feature_leaf": "*\n__x86_get_cpuid_feature_leaf (unsigned int leaf){\n  static const struct cpuid_feature feature = {};\n  if (leaf < CPUID_INDEX_MAX)\n    return ((const struct cpuid_feature *)\n\t    &GLRO(dl_x86_cpu_features).features[leaf]);\n  else\n    return &feature;\n}",
    "ftok": "ftok (const char *pathname, int proj_id){\n  struct __stat64_t64 st;\n  key_t key;\n\n  if (__stat64_time64 (pathname, &st) < 0)\n    return (key_t) -1;\n\n  key = ((st.st_ino & 0xffff) | ((st.st_dev & 0xff) << 16)\n\t | ((proj_id & 0xff) << 24));\n\n  return key;\n}",
    "msgctl": "msgctl (int msqid, int cmd, struct msqid_ds *buf){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "msgrcv": "msgrcv (int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "msgsnd": "msgsnd (int msqid, const void *msgp, size_t msgsz, int msgflg){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "semctl": "semctl (int semid, int semnum, int cmd, ...){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "shmctl": "shmctl (int shmid, int cmd, struct shmid_ds *buf){\n  __set_errno (ENOSYS);\n  return -1;\n}",
    "cfmakeraw": "cfmakeraw (struct termios *t){\n  t->c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);\n  t->c_oflag &= ~OPOST;\n  t->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);\n  t->c_cflag &= ~(CSIZE|PARENB);\n  t->c_cflag |= CS8;\n  t->c_cc[VMIN] = 1;\t\t/* read returns when one char is available.  */\n  t->c_cc[VTIME] = 0;\n}",
    "cfsetspeed": "cfsetspeed (struct termios *termios_p, speed_t speed){\n  size_t cnt;\n\n  for (cnt = 0; cnt < sizeof (speeds) / sizeof (speeds[0]); ++cnt)\n    if (speed == speeds[cnt].internal)\n      {\n\tcfsetispeed (termios_p, speed);\n\tcfsetospeed (termios_p, speed);\n\treturn 0;\n      }\n    else if (speed == speeds[cnt].value)\n      {\n\tcfsetispeed (termios_p, speeds[cnt].internal);\n\tcfsetospeed (termios_p, speeds[cnt].internal);\n\treturn 0;\n      }\n\n  __set_errno (EINVAL);\n\n  return -1;\n}",
    "tcgetsid": "tcgetsid (int fd){\n  pid_t pgrp;\n  pid_t sid;\n#ifdef TIOCGSID\n  static int tiocgsid_does_not_work;\n\n  if (! tiocgsid_does_not_work)\n    {\n      int serrno = errno;\n      int sid;\n\n      if (__ioctl (fd, TIOCGSID, &sid) < 0)\n\t{\n\t  if (errno == EINVAL)\n\t    {\n\t      tiocgsid_does_not_work = 1;\n\t      __set_errno (serrno);\n\t    }\n\t  else\n\t    return (pid_t) -1;\n\t}\n      else\n\treturn (pid_t) sid;\n    }\n#endif\n\n  pgrp = tcgetpgrp (fd);\n  if (pgrp == -1)\n    return (pid_t) -1;\n\n  sid = getsid (pgrp);\n  if (sid == -1 && errno == ESRCH)\n    __set_errno (ENOTTY);\n\n  return sid;\n}",
    "asctime": "*\nasctime (const struct tm *tp){\n  return asctime_internal (tp, result, sizeof (result));\n}",
    "ctime": "*\nctime (const time_t *t){\n  __time64_t t64 = *t;\n  return __ctime64 (&t64);\n}",
    "ctime_r": "*\nctime_r (const time_t *t, char *buf){\n  __time64_t t64 = *t;\n  return __ctime64_r (&t64, buf);\n}",
    "dysize": "dysize (int year){\n  return __isleap (year) ? 366 : 365;\n}",
    "getdate": "*\ngetdate (const char *string){\n  /* Buffer returned by getdate.  */\n  static struct tm tmbuf;\n  int errval = __getdate_r (string, &tmbuf);\n\n  if (errval != 0)\n    {\n      getdate_err = errval;\n      return NULL;\n    }\n\n  return &tmbuf;\n}",
    "__gmtime_r": "*\n__gmtime_r (const time_t *t, struct tm *tp){\n  __time64_t t64 = *t;\n  return __gmtime64_r (&t64, tp);\n}",
    "gmtime": "*\ngmtime (const time_t *t){\n  __time64_t t64 = *t;\n  return __gmtime64 (&t64);\n}",
    "localtime": "*\nlocaltime (const time_t *t){\n  __time64_t t64 = *t;\n  return __localtime64 (&t64);\n}",
    "mktime": "mktime (struct tm *tp){\n  struct tm tm = *tp;\n  __time64_t t = __mktime64 (&tm);\n  if (in_time_t_range (t))\n    {\n      *tp = tm;\n      return t;\n    }\n  else\n    {\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n}",
    "strftime": "strftime (char *s, size_t maxsize, const char *format, const struct tm *tp){\n  return __strftime_l (s, maxsize, format, tp, _NL_CURRENT_LOCALE);\n}",
    "strptime": "*\nstrptime (const char *buf, const char *format, struct tm *tm LOCALE_PARAM){\n  return __strptime_internal (buf, format, tm, NULL LOCALE_ARG);\n}",
    "localtime_r": "*\nlocaltime_r(time_t *tp, struct tm *tmp){\n  struct tm *r = localtime(tp);\n  if (r) {\n    *tmp = *r;\n    r = tmp;\n  }\n  return r;\n}",
    "timegm": "timegm (struct tm *tmp){\n  struct tm tm = *tmp;\n  __time64_t t = __timegm64 (&tm);\n  if (in_time_t_range (t))\n    {\n      *tmp = tm;\n      return t;\n    }\n  else\n    {\n      __set_errno (EOVERFLOW);\n      return -1;\n    }\n}",
    "timespec_get": "timespec_get (struct timespec *ts, int base){\n  if (base == TIME_UTC)\n    {\n      __clock_gettime (CLOCK_REALTIME, ts);\n      return base;\n    }\n  return 0;\n}",
    "timespec_getres": "timespec_getres (struct timespec *ts, int base){\n  if (base == TIME_UTC)\n    {\n      __clock_getres (CLOCK_REALTIME, ts);\n      return base;\n    }\n  return 0;\n}",
    "wcsftime": "wcsftime (wchar_t *s, size_t maxsize, const wchar_t *format,\n\t  const struct tm *tp){\n  return __wcsftime_l (s, maxsize, format, tp, _NL_CURRENT_LOCALE);\n}",
    "tzset": "tzset(void){ }",
    "gmtime_r": "*\ngmtime_r(time_t *tp, struct tm *tmp){\n  struct tm *r = gmtime(tp);\n  if (r) {\n    *tmp = *r;\n    r = tmp;\n  }\n  return r;\n}",
    "strdup": "*\nstrdup(char const *str){\n  char *result = malloc(strlen(str) + 1);\n  return result ? strcpy(result, str) : result;\n}",
    "c16rtomb": "c16rtomb (char *s, char16_t c16, mbstate_t *ps){\n  wchar_t wc = c16;\n\n  if (ps == NULL)\n    ps = &state;\n\n  if (s == NULL)\n    {\n      /* Reset any state relating to surrogate pairs.  */\n      ps->__count &= 0x7fffffff;\n      ps->__value.__wch = 0;\n      wc = 0;\n    }\n\n  if (ps->__count & 0x80000000)\n    {\n      /* The previous call passed in the first surrogate of a\n\t surrogate pair.  */\n      ps->__count &= 0x7fffffff;\n      if (wc >= 0xdc00 && wc < 0xe000)\n\twc = (0x10000\n\t      + ((ps->__value.__wch & 0x3ff) << 10)\n\t      + (wc & 0x3ff));\n      else\n\t/* This is not a low surrogate; ensure an EILSEQ error by\n\t   trying to decode the high surrogate as a wide character on\n\t   its own.  */\n\twc = ps->__value.__wch;\n      ps->__value.__wch = 0;\n    }\n  else if (wc >= 0xd800 && wc < 0xdc00)\n    {\n      /* The high part of a surrogate pair.  */\n      ps->__count |= 0x80000000;\n      ps->__value.__wch = wc;\n      return 0;\n    }\n\n  return wcrtomb (s, wc, ps);\n}",
    "c32rtomb": "c32rtomb (char *s, char32_t c32, mbstate_t *ps){\n  if (ps == NULL)\n    ps = &state;\n  return wcrtomb (s, c32, ps);\n}",
    "c8rtomb": "c8rtomb (char *s, char8_t c8, mbstate_t *ps){\n  /* This implementation depends on the converter invoked by wcrtomb not\n     needing to retain state in either the top most bit of ps->__count or\n     in ps->__value between invocations.  This implementation uses the\n     top most bit of ps->__count to indicate that trailing code units are\n     expected and uses ps->__value to store previously seen code units.  */\n\n  wchar_t wc;\n\n  if (ps == NULL)\n    ps = &state;\n\n  if (s == NULL)\n    {\n      /* if 's' is a null pointer, behave as if u8'\\0' was passed as 'c8'.  If\n         this occurs for an incomplete code unit sequence, then an error will\n         be reported below.  */\n      c8 = u8\"\"[0];\n    }\n\n  if (! (ps->__count & 0x80000000))\n    {\n      /* Initial state.  */\n      if ((c8 >= 0x80 && c8 <= 0xC1) || c8 >= 0xF5)\n\t{\n\t  /* An invalid lead code unit.  */\n\t  __set_errno (EILSEQ);\n\t  return -1;\n\t}\n      if (c8 >= 0xC2)\n\t{\n\t  /* A valid lead code unit.  */\n\t  ps->__count |= 0x80000000;\n\t  ps->__value.__wchb[0] = c8;\n\t  ps->__value.__wchb[3] = 1;\n\t  return 0;\n\t}\n      /* A single byte (ASCII) code unit.  */\n      wc = c8;\n    }\n  else\n    {\n      char8_t cu1 = ps->__value.__wchb[0];\n      if (ps->__value.__wchb[3] == 1)\n\t{\n\t  /* A single lead code unit was previously seen.  */\n\t  if ((c8 < 0x80 || c8 > 0xBF)\n              || (cu1 == 0xE0 && c8 < 0xA0)\n              || (cu1 == 0xED && c8 > 0x9F)\n              || (cu1 == 0xF0 && c8 < 0x90)\n              || (cu1 == 0xF4 && c8 > 0x8F))\n\t    {\n\t      /* An invalid second code unit.  */\n\t      __set_errno (EILSEQ);\n\t      return -1;\n\t    }\n\t  if (cu1 >= 0xE0)\n\t    {\n\t      /* A three or four code unit sequence.  */\n\t      ps->__value.__wchb[1] = c8;\n\t      ++ps->__value.__wchb[3];\n\t      return 0;\n\t    }\n\t  wc = ((cu1 & 0x1F) << 6)\n\t       + (c8 & 0x3F);\n\t}\n      else\n\t{\n\t  char8_t cu2 = ps->__value.__wchb[1];\n\t  /* A three or four byte code unit sequence.  */\n\t  if (c8 < 0x80 || c8 > 0xBF)\n\t    {\n\t      /* An invalid third or fourth code unit.  */\n\t      __set_errno (EILSEQ);\n\t      return -1;\n\t    }\n\t  if (ps->__value.__wchb[3] == 2 && cu1 >= 0xF0)\n\t    {\n\t      /* A four code unit sequence.  */\n\t      ps->__value.__wchb[2] = c8;\n\t      ++ps->__value.__wchb[3];\n\t      return 0;\n\t    }\n\t  if (cu1 < 0xF0)\n\t    {\n\t      wc = ((cu1 & 0x0F) << 12)\n\t\t   + ((cu2 & 0x3F) << 6)\n\t\t   + (c8 & 0x3F);\n\t    }\n\t  else\n\t    {\n\t      char8_t cu3 = ps->__value.__wchb[2];\n\t      wc = ((cu1 & 0x07) << 18)\n\t\t   + ((cu2 & 0x3F) << 12)\n\t\t   + ((cu3 & 0x3F) << 6)\n\t\t   + (c8 & 0x3F);\n\t    }\n\t}\n      ps->__count &= 0x7fffffff;\n      ps->__value.__wch = 0;\n    }\n\n  return wcrtomb (s, wc, ps);\n}",
    "__mbrlen": "__mbrlen (const char *s, size_t n, mbstate_t *ps){\n  return __mbrtowc (NULL, s, n, ps ?: &internal);\n}",
    "mbrtoc16": "mbrtoc16 (char16_t *pc16, const char *s, size_t n, mbstate_t *ps){\n  if (ps == NULL)\n    ps = &state;\n\n  /* The standard text does not say that S being NULL means the state\n     is reset even if the second half of a surrogate still have to be\n     returned.  In fact, the error code description indicates\n     otherwise.  Therefore always first try to return a second\n     half.  */\n  if (ps->__count & 0x80000000)\n    {\n      /* We have to return the second word for a surrogate.  */\n      ps->__count &= 0x7fffffff;\n      *pc16 = ps->__value.__wch;\n      ps->__value.__wch = L'\\0';\n      return (size_t) -3;\n    }\n\n  wchar_t wc;\n  struct __gconv_step_data data;\n  int status;\n  size_t result;\n  size_t dummy;\n  const unsigned char *inbuf, *endbuf;\n  unsigned char *outbuf = (unsigned char *) &wc;\n  const struct gconv_fcts *fcts;\n\n  /* Set information for this step.  */\n  data.__invocation_counter = 0;\n  data.__internal_use = 1;\n  data.__flags = __GCONV_IS_LAST;\n  data.__statep = ps;\n\n  /* A first special case is if S is NULL.  This means put PS in the\n     initial state.  */\n  if (s == NULL)\n    {\n      pc16 = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t) -2;\n\n  /* Tell where we want the result.  */\n  data.__outbuf = outbuf;\n  data.__outbufend = outbuf + sizeof (wchar_t);\n\n  /* Get the conversion functions.  */\n  fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n  /* Do a normal conversion.  */\n  inbuf = (const unsigned char *) s;\n  endbuf = inbuf + n;\n  if (__glibc_unlikely (endbuf < inbuf))\n    {\n      endbuf = (const unsigned char *) ~(uintptr_t) 0;\n      if (endbuf == inbuf)\n\tgoto ilseq;\n    }\n  __gconv_fct fct = fcts->towc->__fct;\n  if (fcts->towc->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n\n  status = DL_CALL_FCT (fct, (fcts->towc, &data, &inbuf, endbuf,\n\t\t\t      NULL, &dummy, 0, 1));\n\n  /* There must not be any problems with the conversion but illegal input\n     characters.  The output buffer must be large enough, otherwise the\n     definition of MB_CUR_MAX is not correct.  All the other possible\n     errors also must not happen.  */\n  assert (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n\t  || status == __GCONV_ILLEGAL_INPUT\n\t  || status == __GCONV_INCOMPLETE_INPUT\n\t  || status == __GCONV_FULL_OUTPUT);\n\n  if (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n      || status == __GCONV_FULL_OUTPUT)\n    {\n      result = inbuf - (const unsigned char *) s;\n\n      if (wc < 0x10000)\n\t{\n\t  if (pc16 != NULL)\n\t    *pc16 = wc;\n\n\t  if (data.__outbuf != outbuf && wc == L'\\0')\n\t    {\n\t      /* The converted character is the NUL character.  */\n\t      assert (__mbsinit (data.__statep));\n\t      result = 0;\n\t    }\n\t}\n      else\n\t{\n\t  /* This is a surrogate.  */\n\t  if (pc16 != NULL)\n\t    *pc16 = 0xd7c0 + (wc >> 10);\n\n\t  ps->__count |= 0x80000000;\n\t  ps->__value.__wch = 0xdc00 + (wc & 0x3ff);\n\t}\n    }\n  else if (status == __GCONV_INCOMPLETE_INPUT)\n    result = (size_t) -2;\n  else\n    {\n    ilseq:\n      result = (size_t) -1;\n      __set_errno (EILSEQ);\n    }\n\n  return result;\n}",
    "mbrtoc32": "mbrtoc32 (char32_t *pc32, const char *s, size_t n, mbstate_t *ps){\n  if (ps == NULL)\n    ps = &state;\n  return mbrtowc ((wchar_t *) pc32, s, n, ps);\n}",
    "mbrtoc8": "mbrtoc8 (char8_t *pc8, const char *s, size_t n, mbstate_t *ps){\n  /* This implementation depends on the converter invoked by mbrtowc not\n     needing to retain state in either the top most bit of ps->__count or\n     in ps->__value between invocations.  This implementation uses the\n     top most bit of ps->__count to indicate that trailing code units are\n     yet to be written and uses ps->__value to store those code units.  */\n\n  if (ps == NULL)\n    ps = &state;\n\n  /* If state indicates that trailing code units are yet to be written, write\n     those first regardless of whether 's' is a null pointer.  */\n  if (ps->__count & 0x80000000)\n    {\n      /* ps->__value.__wchb[3] stores the index of the next code unit to\n         write.  Code units are stored in reverse order.  */\n      size_t i = ps->__value.__wchb[3];\n      if (pc8 != NULL)\n\t{\n\t  *pc8 = ps->__value.__wchb[i];\n\t}\n      if (i == 0)\n\t{\n\t  ps->__count &= 0x7fffffff;\n\t  ps->__value.__wch = 0;\n\t}\n      else\n\t--ps->__value.__wchb[3];\n      return -3;\n    }\n\n  if (s == NULL)\n    {\n      /* if 's' is a null pointer, behave as if a null pointer was passed for\n         'pc8', an empty string was passed for 's', and 1 passed for 'n'.  */\n      pc8 = NULL;\n      s = \"\";\n      n = 1;\n    }\n\n  wchar_t wc;\n  size_t result;\n\n  result = mbrtowc (&wc, s, n, ps);\n  if (result <= n)\n    {\n      if (wc <= 0x7F)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = wc;\n\t}\n      else if (wc <= 0x7FF)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = 0xC0 + ((wc >> 6) & 0x1F);\n\t  ps->__value.__wchb[0] = 0x80 + (wc & 0x3F);\n\t  ps->__value.__wchb[3] = 0;\n\t  ps->__count |= 0x80000000;\n\t}\n      else if (wc <= 0xFFFF)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = 0xE0 + ((wc >> 12) & 0x0F);\n\t  ps->__value.__wchb[1] = 0x80 + ((wc >> 6) & 0x3F);\n\t  ps->__value.__wchb[0] = 0x80 + (wc & 0x3F);\n\t  ps->__value.__wchb[3] = 1;\n\t  ps->__count |= 0x80000000;\n\t}\n      else if (wc <= 0x10FFFF)\n\t{\n\t  if (pc8 != NULL)\n\t    *pc8 = 0xF0 + ((wc >> 18) & 0x07);\n\t  ps->__value.__wchb[2] = 0x80 + ((wc >> 12) & 0x3F);\n\t  ps->__value.__wchb[1] = 0x80 + ((wc >> 6) & 0x3F);\n\t  ps->__value.__wchb[0] = 0x80 + (wc & 0x3F);\n\t  ps->__value.__wchb[3] = 2;\n\t  ps->__count |= 0x80000000;\n\t}\n    }\n  if (result == 0 && wc != 0)\n    {\n      /* mbrtowc() never returns -3.  When a MB sequence converts to multiple\n         WCs, no input is consumed when writing the subsequent WCs resulting\n         in a result of 0 even if a null character wasn't written.  */\n      result = -3;\n    }\n\n  return result;\n}",
    "__mbrtowc": "__mbrtowc (wchar_t *pwc, const char *s, size_t n, mbstate_t *ps){\n  wchar_t buf[1];\n  struct __gconv_step_data data;\n  int status;\n  size_t result;\n  size_t dummy;\n  const unsigned char *inbuf, *endbuf;\n  unsigned char *outbuf = (unsigned char *) (pwc ?: buf);\n  const struct gconv_fcts *fcts;\n\n  /* Set information for this step.  */\n  data.__invocation_counter = 0;\n  data.__internal_use = 1;\n  data.__flags = __GCONV_IS_LAST;\n  data.__statep = ps ?: &state;\n\n  /* A first special case is if S is NULL.  This means put PS in the\n     initial state.  */\n  if (s == NULL)\n    {\n      outbuf = (unsigned char *) buf;\n      s = \"\";\n      n = 1;\n    }\n\n  if (n == 0)\n    return (size_t) -2;\n\n  /* Tell where we want the result.  */\n  data.__outbuf = outbuf;\n  data.__outbufend = outbuf + sizeof (wchar_t);\n\n  /* Get the conversion functions.  */\n  fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n  /* Do a normal conversion.  */\n  inbuf = (const unsigned char *) s;\n  endbuf = inbuf + n;\n  if (__glibc_unlikely (endbuf < inbuf))\n    {\n      endbuf = (const unsigned char *) ~(uintptr_t) 0;\n      if (endbuf == inbuf)\n\tgoto ilseq;\n    }\n  __gconv_fct fct = fcts->towc->__fct;\n  if (fcts->towc->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n  status = DL_CALL_FCT (fct, (fcts->towc, &data, &inbuf, endbuf,\n\t\t\t      NULL, &dummy, 0, 1));\n\n  /* There must not be any problems with the conversion but illegal input\n     characters.  The output buffer must be large enough, otherwise the\n     definition of MB_CUR_MAX is not correct.  All the other possible\n     errors also must not happen.  */\n  assert (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n\t  || status == __GCONV_ILLEGAL_INPUT\n\t  || status == __GCONV_INCOMPLETE_INPUT\n\t  || status == __GCONV_FULL_OUTPUT);\n\n  if (status == __GCONV_OK || status == __GCONV_EMPTY_INPUT\n      || status == __GCONV_FULL_OUTPUT)\n    {\n      if (data.__outbuf != (unsigned char *) outbuf\n\t  && *(wchar_t *) outbuf == L'\\0')\n\t{\n\t  /* The converted character is the NUL character.  */\n\t  assert (__mbsinit (data.__statep));\n\t  result = 0;\n\t}\n      else\n\tresult = inbuf - (const unsigned char *) s;\n    }\n  else if (status == __GCONV_INCOMPLETE_INPUT)\n    result = (size_t) -2;\n  else\n    {\n    ilseq:\n      result = (size_t) -1;\n      __set_errno (EILSEQ);\n    }\n\n  return result;\n}",
    "wcscspn": "wcscspn (const wchar_t *wcs, const wchar_t *reject){\n  size_t count = 0;\n\n  while (*wcs != L'\\0')\n    if (wcschr (reject, *wcs++) == NULL)\n      ++count;\n    else\n      return count;\n\n  return count;\n}",
    "wcsdup": "*\nwcsdup (const wchar_t *s){\n  size_t len = (__wcslen (s) + 1) * sizeof (wchar_t);\n  void *new = malloc (len);\n\n  if (new == NULL)\n    return NULL;\n\n  return (wchar_t *) memcpy (new, (void *) s, len);\n}",
    "wcspbrk": "*\nwcspbrk (const wchar_t *wcs, const wchar_t *accept){\n  while (*wcs != L'\\0')\n    if (wcschr (accept, *wcs) == NULL)\n      ++wcs;\n    else\n      return (wchar_t *) wcs;\n\n  return NULL;\n}",
    "wcsspn": "wcsspn (const wchar_t *wcs, const wchar_t *accept){\n  const wchar_t *p;\n  const wchar_t *a;\n  size_t count = 0;\n\n  for (p = wcs; *p != L'\\0'; ++p)\n    {\n      for (a = accept; *a != L'\\0'; ++a)\n\tif (*p == *a)\n\t  break;\n      if (*a == L'\\0')\n\treturn count;\n      else\n\t++count;\n    }\n\n  return count;\n}",
    "wcsstr": "*\nwcsstr (const wchar_t *haystack, const wchar_t *needle){\n  wchar_t b, c;\n\n  if ((b = *needle) != L'\\0')\n    {\n      haystack--;\t\t\t\t/* possible ANSI violation */\n      do\n\tif ((c = *++haystack) == L'\\0')\n\t  goto ret0;\n      while (c != b);\n\n      if (!(c = *++needle))\n\tgoto foundneedle;\n      ++needle;\n      goto jin;\n\n      for (;;)\n\t{\n\t  wchar_t a;\n\t  const wchar_t *rhaystack, *rneedle;\n\n\t  do\n\t    {\n\t      if (!(a = *++haystack))\n\t\tgoto ret0;\n\t      if (a == b)\n\t\tbreak;\n\t      if ((a = *++haystack) == L'\\0')\n\t\tgoto ret0;\nshloop:\t      ;\n\t    }\n\t  while (a != b);\n\njin:\t  if (!(a = *++haystack))\n\t    goto ret0;\n\n\t  if (a != c)\n\t    goto shloop;\n\n\t  if (*(rhaystack = haystack-- + 1) == (a = *(rneedle = needle)))\n\t    do\n\t      {\n\t\tif (a == L'\\0')\n\t\t  goto foundneedle;\n\t\tif (*++rhaystack != (a = *++needle))\n\t\t  break;\n\t\tif (a == L'\\0')\n\t\t  goto foundneedle;\n\t      }\n\t    while (*++rhaystack == (a = *++needle));\n\n\t  needle = rneedle;\t\t  /* took the register-poor approach */\n\n\t  if (a == L'\\0')\n\t    break;\n\t}\n    }\nfoundneedle:\n  return (wchar_t*) haystack;\nret0:\n  return NULL;\n}",
    "wcstok": "*\nwcstok (wchar_t *wcs, const wchar_t *delim, wchar_t **save_ptr){\n  wchar_t *result;\n\n  if (wcs == NULL)\n    {\n      if (*save_ptr == NULL)\n\t{\n\t  __set_errno (EINVAL);\n\t  return NULL;\n\t}\n      else\n\twcs = *save_ptr;\n    }\n\n  /* Scan leading delimiters.  */\n  wcs += wcsspn (wcs, delim);\n  if (*wcs == L'\\0')\n    {\n      *save_ptr = NULL;\n      return NULL;\n    }\n\n  /* Find the end of the token.\t */\n  result = wcs;\n  wcs = wcspbrk (result, delim);\n  if (wcs == NULL)\n    /* This token finishes the string.\t*/\n    *save_ptr = NULL;\n  else\n    {\n      /* Terminate the token and make *SAVE_PTR point past it.  */\n      *wcs = L'\\0';\n      *save_ptr = wcs + 1;\n    }\n  return result;\n}",
    "wcswidth": "wcswidth (const wchar_t *s, size_t n){\n  int result = 0;\n\n  while (n-- > 0 && *s != L'\\0')\n    {\n      int now = internal_wcwidth (*s);\n      if (now == -1)\n\treturn -1;\n      result += now;\n      ++s;\n    }\n\n  return result;\n}",
    "wctob": "wctob (wint_t c){\n  unsigned char buf[MB_LEN_MAX];\n  struct __gconv_step_data data;\n  wchar_t inbuf[1];\n  wchar_t *inptr = inbuf;\n  size_t dummy;\n  int status;\n  const struct gconv_fcts *fcts;\n\n  if (c == WEOF)\n    return EOF;\n\n  /* We know that only ASCII compatible encodings are used for the\n     locale and that the wide character encoding is ISO 10646.  */\n  if (c >= L'\\0' && c <= L'\\x7f')\n    return (int) c;\n\n  /* Tell where we want the result.  */\n  data.__outbuf = buf;\n  data.__outbufend = buf + MB_LEN_MAX;\n  data.__invocation_counter = 0;\n  data.__internal_use = 1;\n  data.__flags = __GCONV_IS_LAST;\n  data.__statep = &data.__state;\n\n  /* Make sure we start in the initial state.  */\n  memset (&data.__state, '\\0', sizeof (mbstate_t));\n\n  /* Get the conversion functions.  */\n  fcts = get_gconv_fcts (_NL_CURRENT_DATA (LC_CTYPE));\n\n  /* Create the input string.  */\n  inbuf[0] = c;\n\n  const unsigned char *argptr = (const unsigned char *) inptr;\n  __gconv_fct fct = fcts->tomb->__fct;\n  if (fcts->tomb->__shlib_handle != NULL)\n    PTR_DEMANGLE (fct);\n  status = DL_CALL_FCT (fct,\n\t\t\t(fcts->tomb, &data, &argptr,\n\t\t\t argptr + sizeof (inbuf[0]), NULL, &dummy, 0, 1));\n\n  /* The conversion failed or the output is too long.  */\n  if ((status != __GCONV_OK && status != __GCONV_FULL_OUTPUT\n       && status != __GCONV_EMPTY_INPUT)\n      || data.__outbuf != (unsigned char *) (buf + 1))\n    return EOF;\n\n  return buf[0];\n}",
    "wcwidth": "wcwidth (wchar_t ch){\n  return internal_wcwidth (ch);\n}",
    "__iswctype": "__iswctype (wint_t wc, wctype_t desc){\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `wctype' in case of an error) simply return 0.  */\n  if (desc == (wctype_t) 0)\n    return 0;\n\n  return wctype_table_lookup ((const char *) desc, wc);\n}",
    "__iswctype_l": "__iswctype_l (wint_t wc, wctype_t desc, locale_t locale){\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `__wctype_l' in case of an error) simply return 0.  */\n  if (desc == (wctype_t) 0)\n    return 0;\n\n  return wctype_table_lookup ((const char *) desc, wc);\n}",
    "__towctrans": "__towctrans (wint_t wc, wctrans_t desc){\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `wctrans' in case of an error) simply return the value.  */\n  if (desc == (wctrans_t) 0)\n    return wc;\n\n  return wctrans_table_lookup ((const char *) desc, wc);\n}",
    "__towctrans_l": "__towctrans_l (wint_t wc, wctrans_t desc, locale_t locale){\n  /* If the user passes in an invalid DESC valid (the one returned from\n     `__wctrans_l' in case of an error) simply return the value.  */\n  if (desc == (wctrans_t) 0)\n    return wc;\n\n  return wctrans_table_lookup ((const char *) desc, wc);\n}",
    "__wctrans_l": "__wctrans_l (const char *property, locale_t locale){\n  const char *names;\n  size_t cnt;\n  size_t i;\n\n  names = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_MAP_NAMES)].string;\n  cnt = 0;\n  while (names[0] != '\\0')\n    {\n      if (strcmp (property, names) == 0)\n\tbreak;\n\n      names = strchr (names, '\\0') + 1;\n      ++cnt;\n    }\n\n  if (names[0] == '\\0')\n    return 0;\n\n  i = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_MAP_OFFSET)].word + cnt;\n  return (wctrans_t) locale->__locales[LC_CTYPE]->values[i].string;\n}",
    "__wctype_l": "__wctype_l (const char *property, locale_t locale){\n  const char *names;\n  unsigned int result;\n  size_t proplen = strlen (property);\n  size_t i;\n\n  names = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_CLASS_NAMES)].string;\n  for (result = 0; ; result++)\n    {\n      size_t nameslen = strlen (names);\n\n      if (proplen == nameslen && memcmp (property, names, proplen) == 0)\n\tbreak;\n\n      names += nameslen + 1;\n      if (names[0] == '\\0')\n\treturn 0;\n    }\n\n  i = locale->__locales[LC_CTYPE]->values[_NL_ITEM_INDEX (_NL_CTYPE_CLASS_OFFSET)].word + result;\n  return (wctype_t) locale->__locales[LC_CTYPE]->values[i].string;\n}"
}
