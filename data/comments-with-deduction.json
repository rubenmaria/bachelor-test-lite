{
    "__assert": "",
    "__assert_perror_fail": "Define our own version of the internal function used by strerror.  We\n   only provide the messages for some common errors.  This avoids pulling\n   in the whole error list.",
    "__assert_fail": "Define (weakly) our own assert failure function which doesn't use stdio.\n   If we are linked into the user program (-ldl), the normal __assert_fail\n   defn can override this one.",
    "catopen": "Open the catalog and return a descriptor for the catalog.",
    "catgets": "Return message from message catalog.",
    "catclose": "Return resources used for loaded message catalog.",
    "__open_catalog": "",
    "__errno_location": "",
    "__gmon_start__": "We cannot use the normal constructor mechanism to call\n   __gmon_start__ because gcrt1.o appears before crtbegin.o in the link.\n   Instead crti.o calls it specially.",
    "__libc_init_first": "",
    "isblank": "",
    "__isblank_l": "",
    "_tolower": "Real function versions of the non-ANSI ctype functions.",
    "_toupper": "",
    "toascii": "",
    "isascii": "",
    "tolower": "",
    "toupper": "",
    "__isctype": "",
    "__backtrace": "",
    "__backtrace_symbols": "",
    "__backtrace_symbols_fd": "",
    "__chk_fail": "",
    "__confstr_chk": "",
    "__dprintf_chk": "",
    "__explicit_bzero_chk": "",
    "__fdelt_chk": "",
    "__fgets_chk": "",
    "__fgets_unlocked_chk": "",
    "__fgetws_chk": "",
    "__fgetws_unlocked_chk": "",
    "__fortify_fail": "",
    "__fread_chk": "",
    "__fread_unlocked_chk": "",
    "__fwprintf_chk": "",
    "__getcwd_chk": "",
    "__getdomainname_chk": "",
    "__getgroups_chk": "",
    "__gethostname_chk": "",
    "__gets_chk": "",
    "__getwd_chk": "",
    "__mbsnrtowcs_chk": "",
    "__mbsrtowcs_chk": "",
    "__mbstowcs_chk": "",
    "__memcpy_chk": "",
    "__mempcpy_chk": "",
    "__memset_chk": "",
    "__cyg_profile_func_enter": "",
    "__obstack_printf_chk": "",
    "__poll_chk": "",
    "__ppoll_chk": "",
    "__pread64_chk": "",
    "__pread_chk": "",
    "__read_chk": "",
    "__readlink_chk": "",
    "__readlinkat_chk": "",
    "__realpath_chk": "",
    "__recv_chk": "",
    "__recvfrom_chk": "",
    "__stack_chk_fail": "",
    "__stpcpy_chk": "Copy SRC to DEST, returning the address of the terminating '\\0' in DEST.",
    "__stpncpy_chk": "Copy no more than N characters of SRC to DEST, returning the address of\n   the terminating '\\0' in DEST, if any, or else DEST + N.",
    "__strcat_chk": "Append SRC on the end of DEST.",
    "__strcpy_chk": "Copy SRC to DEST with checking of destination buffer overflow.",
    "__strlcat_chk": "Check that the user-supplied size does not exceed the\n   compiler-determined size, and then forward to strlcat.",
    "__strlcpy_chk": "Check that the user-supplied size does not exceed the\n   compiler-determined size, and then forward to strlcpy.",
    "__strncat_chk": "",
    "__strncpy_chk": "",
    "__swprintf_chk": "",
    "__ttyname_r_chk": "",
    "__vasprintf_chk": "",
    "__vdprintf_chk": "",
    "__vfwprintf_chk": "",
    "__obstack_vprintf_chk": "",
    "__vswprintf_chk": "",
    "__vwprintf_chk": "",
    "__wcpcpy_chk": "Copy SRC to DEST, returning the address of the terminating L'\\0' in\n   DEST.  Check for overflows.",
    "__wcpncpy_chk": "Copy no more than N wide-characters of SRC to DEST.",
    "__wcrtomb_chk": "",
    "__wcscat_chk": "Append SRC on the end of DEST.  Check for overflows.",
    "__wcscpy_chk": "Copy SRC to DEST.",
    "__wcslcat_chk": "Check that the user-supplied size does not exceed the\n   compiler-determined size, and then forward to wcslcat.",
    "__wcslcpy_chk": "Check that the user-supplied size does not exceed the\n   compiler-determined size, and then forward to wcslcpy.",
    "__wcsncat_chk": "Append no more than N wide-character of SRC onto DEST.",
    "__wcsncpy_chk": "Copy no more than N wide-characters of SRC to DEST.",
    "__wcsnrtombs_chk": "",
    "__wcsrtombs_chk": "",
    "__wcstombs_chk": "",
    "__wctomb_chk": "Defined in wctomb.c.",
    "__wmemcpy_chk": "",
    "__wmemmove_chk": "",
    "__wmempcpy_chk": "",
    "__wmemset_chk": "",
    "__wprintf_chk": "",
    "alphasort": "",
    "alphasort64": "",
    "getdirentries64": "",
    "readdir64_r": "Read a directory entry from DIRP, store result in ENTRY and return\n   pointer to result in *RESULT.",
    "scandir": "",
    "scandir64": "",
    "scandirat64": "",
    "seekdir": "XXX should be __seekdir ?",
    "telldir": "Return the current position of DIRP.",
    "versionsort": "",
    "versionsort64": "",
    "malloc": "",
    "unsetenv": "",
    "_dl_find_object": "",
    "__strerror_r": "Return a string describing the errno code in ERRNUM.",
    "__libc_fatal": "",
    "_dl_mcount_wrapper": "This is the map for the shared object we profile.  It is defined here\n   only because we test for this value being NULL or not.",
    "_dl_mcount_wrapper_check": "",
    "__libc_early_init": "",
    "getpid": "",
    "calloc": "Internal helper functions.  Those must be called while the lock is\n   acquired.",
    "access": "",
    "__monstartup": "Control profiling\n *\tprofiling is what mcount checks to see if\n *\tall the data structures are ready.",
    "_mcleanup": "This symbol isn't used anywhere in the DSO and it is not exported.\n   This would normally mean it should be removed to get the same API\n   in static libraries.  But since profiling is special in static libs\n   anyway we keep it.  But not when building the DSO since some\n   quality assurance tests will otherwise trigger.",
    "__profile_frequency": "",
    "__libc_alloca_cutoff": "",
    "__h_errno_location": "When threaded, h_errno may be a per-thread variable.",
    "pthread_cancel": "",
    "pthread_sigmask": "",
    "pthread_yield": "",
    "free": "",
    "realloc": "The first thread that gets a lock in _res_hconf_reorder_addrs()\n   should hold the lock long enough to make two other threads blocked.\n   This is achieved by slowing down realloc(3) that is called several times\n   by _res_hconf_reorder_addrs().",
    "__gconv_get_cache": "",
    "__gconv_create_spec": "This function accepts the charset names of the source and destination of the\n   conversion and populates *conv_spec with an equivalent conversion\n   specification that may later be used by __gconv_open.  The charset names\n   might contain options in the form of suffixes that alter the conversion,\n   e.g. \"ISO-10646/UTF-8/TRANSLIT\".  It processes the charset names, ignoring\n   and truncating any suffix options in fromcode, and processing and truncating\n   any suffix options in tocode.  Supported suffix options (\"TRANSLIT\" or\n   \"IGNORE\") when found in tocode lead to the corresponding flag in *conv_spec\n   to be set to true.  Unrecognized suffix options are silently discarded.  If\n   the function succeeds, it returns conv_spec back to the caller.  It returns\n   NULL upon failure.  conv_spec must be allocated and freed by the caller.",
    "__gconv_destroy_spec": "",
    "__gconv_get_modules_db": "Provide access to module database.",
    "__gconv_get_alias_db": "",
    "__gconv_open": "",
    "__gconv_transliterate": "",
    "iconv": "",
    "iconv_close": "",
    "iconv_open": "",
    "bindresvport": "* Bind a socket to a privileged IP port",
    "ether_aton": "",
    "ether_aton_r": "",
    "ether_line": "",
    "ether_ntoa": "",
    "ether_ntoa_r": "",
    "getipv4sourcefilter": "",
    "getsourcefilter": "Try to determine the socket level value.  Ideally both side and\n   family are set.  But sometimes only the size is correct and the\n   family value might be bogus.  Loop over the array entries and look\n   for a perfect match or the first match based on size.",
    "htonl": "",
    "htons": "",
    "__idna_to_dns_encoding": "strdup with an EAI_* error code.Ensure that *functions is initialized and return the value of the\n   pointer.  If the library cannot be loaded, return NULL.",
    "__idna_from_dns_encoding": "Ensure that *functions is initialized and return the value of the\n   pointer.  If the library cannot be loaded, return NULL.strdup with an EAI_* error code.",
    "inet6_opt_init": "RFC 3542, 10.1\n\n   This function returns the number of bytes needed for the empty\n   extension header i.e., without any options.  If EXTBUF is not NULL it\n   also initializes the extension header to have the correct length\n   field.  In that case if the EXTLEN value is not a positive (i.e.,\n   non-zero) multiple of 8 the function fails and returns -1.",
    "inet6_opt_append": "RFC 3542, 10.2\n\n   This function returns the updated total length taking into account\n   adding an option with length 'len' and alignment 'align'.  If\n   EXTBUF is not NULL then, in addition to returning the length, the\n   function inserts any needed pad option, initializes the option\n   (setting the type and length fields) and returns a pointer to the\n   location for the option content in databufp.  If the option does\n   not fit in the extension header buffer the function returns -1.",
    "inet6_opt_finish": "RFC 3542, 10.3\n\n   This function returns the updated total length taking into account\n   the final padding of the extension header to make it a multiple of\n   8 bytes.  If EXTBUF is not NULL the function also initializes the\n   option by inserting a Pad1 or PadN option of the proper length.",
    "inet6_opt_set_val": "RFC 3542, 10.4\n\n   This function inserts data items of various sizes in the data\n   portion of the option.  VAL should point to the data to be\n   inserted.  OFFSET specifies where in the data portion of the option\n   the value should be inserted; the first byte after the option type\n   and length is accessed by specifying an offset of zero.",
    "inet6_opt_next": "RFC 3542, 10.5\n\n   This function parses received option extension headers returning\n   the next option.  EXTBUF and EXTLEN specifies the extension header.\n   OFFSET should either be zero (for the first option) or the length\n   returned by a previous call to 'inet6_opt_next' or\n   'inet6_opt_find'.  It specifies the position where to continue\n   scanning the extension buffer.",
    "inet6_opt_find": "RFC 3542, 10.6\n\n   This function is similar to the previously described\n   'inet6_opt_next' function, except this function lets the caller\n   specify the option type to be searched for, instead of always\n   returning the next option in the extension header.",
    "inet6_opt_get_val": "RFC 3542, 10.7\n\n   This function extracts data items of various sizes in the data\n   portion of the option.",
    "inet6_option_space": "RFC 2292, 6.3.1\n\n   This function returns the number of bytes required to hold an option\n   when it is stored as ancillary data, including the cmsghdr structure\n   at the beginning, and any padding at the end (to make its size a\n   multiple of 8 bytes).  The argument is the size of the structure\n   defining the option, which must include any pad bytes at the\n   beginning (the value y in the alignment term \"xn + y\"), the type\n   byte, the length byte, and the option data.",
    "inet6_option_init": "RFC 2292, 6.3.2\n\n   This function is called once per ancillary data object that will\n   contain either Hop-by-Hop or Destination options.  It returns 0 on\n   success or -1 on an error.",
    "inet6_option_append": "RFC 2292, 6.3.3\n\n   This function appends a Hop-by-Hop option or a Destination option\n   into an ancillary data object that has been initialized by\n   inet6_option_init().  This function returns 0 if it succeeds or -1 on\n   an error.",
    "inet6_option_alloc": "RFC 2292, 6.3.4\n\n   This function appends a Hop-by-Hop option or a Destination option\n   into an ancillary data object that has been initialized by\n   inet6_option_init().  This function returns a pointer to the 8-bit\n   option type field that starts the option on success, or NULL on an\n   error.",
    "inet6_option_next": "RFC 2292, 6.3.5\n\n   This function processes the next Hop-by-Hop option or Destination\n   option in an ancillary data object.  If another option remains to be\n   processed, the return value of the function is 0 and *tptrp points to\n   the 8-bit option type field (which is followed by the 8-bit option\n   data length, followed by the option data).  If no more options remain\n   to be processed, the return value is -1 and *tptrp is NULL.  If an\n   error occurs, the return value is -1 and *tptrp is not NULL.",
    "inet6_option_find": "RFC 2292, 6.3.6\n\n   This function is similar to the previously described\n   inet6_option_next() function, except this function lets the caller\n   specify the option type to be searched for, instead of always\n   returning the next option in the ancillary data object.  cmsg is a\n   pointer to cmsghdr structure of which cmsg_level equals IPPROTO_IPV6\n   and cmsg_type equals either IPV6_HOPOPTS or IPV6_DSTOPTS.",
    "inet6_rth_space": "RFC 3542, 7.1\n\n   This function returns the number of bytes required to hold a\n   Routing header of the specified type containing the specified\n   number of segments (addresses).  For an IPv6 Type 0 Routing header,\n   the number of segments must be between 0 and 127, inclusive.",
    "inet6_rth_init": "RFC 3542, 7.2\n\n   This function initializes the buffer pointed to by BP to contain a\n   Routing header of the specified type and sets ip6r_len based on the\n   segments parameter.",
    "inet6_rth_add": "RFC 3542, 7.3\n\n   This function adds the IPv6 address pointed to by addr to the end of\n   the Routing header being constructed.",
    "inet6_rth_reverse": "RFC 3542, 7.4\n\n   This function takes a Routing header extension header (pointed to by\n   the first argument) and writes a new Routing header that sends\n   datagrams along the reverse of that route.  The function reverses the\n   order of the addresses and sets the segleft member in the new Routing\n   header to the number of segments.",
    "inet6_rth_segments": "RFC 3542, 7.5\n\n   This function returns the number of segments (addresses) contained in\n   the Routing header described by BP.",
    "inet6_rth_getaddr": "RFC 3542, 7.6\n\n   This function returns a pointer to the IPv6 address specified by\n   index (which must have a value between 0 and one less than the\n   value returned by 'inet6_rth_segments') in the Routing header\n   described by BP.",
    "__inet6_scopeid_pton": "Parse SOURCE as a scope ID for ADDRESS.  Return 0 on success and -1\n   on error.",
    "inet_lnaof": "* Return the local network address portion of an\n * internet address; handles class a/b/c network\n * number formats.",
    "inet_netof": "* Return the network number from an internet\n * address; handles class a/b/c network #'s.",
    "inet_ntoa": "",
    "rcmd_af": "",
    "rcmd": "",
    "rresvport_af": "",
    "rresvport": "",
    "ruserok_af": "New .rhosts strategy: We are passed an ip address. We spin through\n * hosts.equiv and .rhosts looking for a match. When the .rhosts only\n * has ip addresses, we don't have to trust a nameserver.  When it\n * contains hostnames, we spin through the list of addresses the nameserver\n * gives us and look for a match.\n *\n * Returns 0 if ok, -1 if not ok.",
    "ruserok": "",
    "iruserok_af": "This is the exported version.",
    "iruserok": "This is the exported version.",
    "__ivaliduser": "Previously used by lpd.  Current lpd versions have their own copy.",
    "rexec_af": "",
    "rexec": "",
    "ruserpass": "",
    "setipv4sourcefilter": "",
    "setsourcefilter": "",
    "stpcpy": "",
    "mempcpy": "",
    "__close": "Close the file descriptor FD.",
    "copy_file_range": "",
    "creat": "Create FILE with protections MODE.",
    "creat64": "Create FILE with protections MODE.",
    "__dup2": "Duplicate FD to FD2, closing the old FD2 and making FD2 be\n   open the same file as FD is.  Return FD2 or -1.",
    "faccessat": "",
    "fchmodat": "",
    "fchownat": "Change the owner and group of FILE.",
    "__fcntl": "Perform file control operations on FD.",
    "__file_is_unchanged": "",
    "__file_change_detection_for_stat": "",
    "__file_change_detection_for_path": "",
    "__file_change_detection_for_fp": "",
    "__fstat64": "",
    "futimens": "Change the access time of the file associated with FD to TSP[0] and\n   the modification time of FILE to TSP[1].",
    "get_current_dir_name": "Return a malloc'd string containing the current directory name.\n   If the environment variable `PWD' is set, and its value is correct,\n   that value is used.",
    "getwd": "",
    "lchmod": "Change the protections of FILE to MODE.",
    "linkat": "Make a link to FROM relative to FROMFD called TO relative to TOFD.",
    "lockf": "lockf is a simplified interface to fcntl's locking facilities.",
    "mkdirat": "Create a directory named PATH relative to FD with protections MODE.",
    "mkfifo": "Create a named pipe (FIFO) named PATH with protections MODE.",
    "mkfifoat": "Create a new FIFO with permission bits MODE.  But interpret\n   relative PATH names relative to the directory associated with FD.",
    "__open64_2": "",
    "__open_2": "",
    "__openat64_2": "",
    "__openat_2": "",
    "__pipe": "Create a one-way communication channel (__pipe).\n   If successful, two file descriptors are stored in PIPEDES;\n   bytes written on PIPEDES[1] can be read from PIPEDES[0].\n   Returns 0 if successful, -1 if not.",
    "__poll": "",
    "posix_fadvise": "Default implementation will use __NR_fadvise64 with expected argument\n   positions (for instance i386 and powerpc32 that uses __ALIGNMENT_ARG).\n\n   Second option will be used by arm which define __NR_arm_fadvise64_64\n   (redefined to __NR_fadvise64_64 in kernel-features.h) that behaves as\n   __NR_fadvise64_64 (without the alignment argument required for the ABI).\n\n   Third option will be used by mips o32.  Mips will use a 7 argument\n   syscall with __NR_fadvise64.\n\n   s390 implements fadvice64_64 using a specific struct with arguments\n   packed inside.  This is the only implementation handled in arch-specific\n   code.",
    "posix_fadvise64": "Advice the system about the expected behaviour of the application with\n   respect to the file associated with FD.",
    "posix_fallocate": "Reserve storage for the data of the file associated with FD.",
    "posix_fallocate64": "Reserve storage for the data of the file associated with FD.",
    "ppoll": "",
    "readlinkat": "Read the contents of the symbolic link PATH relative to FD into no\n   more than LEN bytes of BUF.  The contents are not null-terminated.\n   Returns the number of characters read, or -1 for errors.",
    "sendfile": "Send COUNT bytes from file associated with IN_FD starting at OFFSET to\n   descriptor OUT_FD.",
    "sendfile64": "Send COUNT bytes from file associated with IN_FD starting at OFFSET to\n   descriptor OUT_FD.",
    "__statfs": "Return information about the filesystem on which FILE resides.",
    "statx": "",
    "symlinkat": "Make a link to FROM called TO relative to FD.",
    "ttyname": "Return the pathname of the terminal FD is open on, or NULL on errors.\n   The returned storage is good only until the next call to this function.",
    "unlinkat": "Remove the link named NAME.",
    "utime": "Set the access and modification times of FILE to those given in TIMES.\n   If TIMES is NULL, set them to the current time.",
    "utimensat": "Change the access time of FILE to TSP[0] and\n   the modification time of FILE to TSP[1].",
    "__fbufsize": "",
    "__flbf": "",
    "__fpending": "",
    "__fpurge": "",
    "__freadable": "",
    "__freading": "",
    "__fsetlocking": "",
    "__fwritable": "",
    "__fwriting": "",
    "clearerr": "",
    "clearerr_unlocked": "",
    "_IO_feof": "",
    "_IO_ferror": "",
    "_IO_file_doallocate": "Allocate a file buffer, or switch to unbuffered I/O.  Streams for\n   TTY devices default to line buffered.",
    "_IO_file_open": "",
    "_IO_file_read": "",
    "_IO_file_seek": "",
    "_IO_file_stat": "",
    "_IO_file_close": "",
    "fputc": "",
    "fputc_unlocked": "",
    "fputwc": "",
    "fputwc_unlocked": "",
    "freopen": "",
    "freopen64": "",
    "fseek": "",
    "__fseeko64": "",
    "__ftello64": "",
    "fwide": "",
    "_IO_un_link": "",
    "_IO_link_in": "",
    "_IO_switch_to_get_mode": "",
    "_IO_free_backup_area": "Switch current get area from backup buffer to (start of) main get area.",
    "__overflow": "",
    "__underflow": "Switch current get area from backup buffer to (start of) main get area.",
    "__uflow": "Switch current get area from backup buffer to (start of) main get area.",
    "_IO_setb": "",
    "_IO_doallocbuf": "",
    "_IO_default_uflow": "",
    "_IO_default_xsputn": "",
    "_IO_sgetn": "",
    "_IO_default_xsgetn": "",
    "_IO_default_doallocate": "",
    "_IO_init": "",
    "_IO_enable_locks": "In a single-threaded process most stdio locks can be omitted.  After\n   _IO_enable_locks is called, locks are not optimized away any more.\n   It must be first called while the process is still single-threaded.\n\n   This lock optimization can be disabled on a per-file basis by setting\n   _IO_FLAGS2_NEED_LOCK, because a file can have user-defined callbacks\n   or can be locked with flockfile and then a thread may be created\n   between a lock and unlock, so omitting the lock is not valid.\n\n   Here we have to make sure that the flag is set on all existing files\n   and files created later.",
    "_IO_default_finish": "The way the C++ classes are mapped into the C functions in the\n   current implementation, this function can get called twice!",
    "_IO_sputbackc": "",
    "_IO_sungetc": "",
    "_IO_adjust_column": "",
    "_IO_flush_all": "",
    "_IO_flush_all_linebuffered": "",
    "_IO_init_marker": "",
    "_IO_remove_marker": "",
    "_IO_marker_difference": "",
    "_IO_marker_delta": "Return difference between MARK and current position of MARK's stream.",
    "_IO_seekmark": "Switch current get area from backup buffer to (start of) main get area.Switch current get area from main get area to (end of) backup area.",
    "_IO_unsave_markers": "",
    "_IO_default_pbackfail": "Switch current get area from main get area to (end of) backup area.",
    "_IO_iter_begin": "",
    "_IO_iter_end": "",
    "_IO_iter_next": "",
    "_IO_iter_file": "",
    "_IO_list_lock": "",
    "_IO_list_unlock": "",
    "_IO_list_resetlock": "",
    "_IO_getc": "",
    "getchar": "",
    "getchar_unlocked": "",
    "getwchar": "",
    "getwchar_unlocked": "",
    "_IO_fflush": "",
    "_IO_fgets": "",
    "fgetws": "",
    "fgetws_unlocked": "",
    "_IO_fputs": "",
    "fputws": "",
    "fputws_unlocked": "",
    "_IO_fread": "",
    "_IO_ftell": "ANSI explicily requires setting errno to a positive value on failure.",
    "_IO_fwrite": "",
    "fwrite_unlocked": "",
    "__getdelim": "Read up to (and including) a TERMINATOR from FP into *LINEPTR\n   (and null-terminate it).  *LINEPTR is a pointer returned from malloc (or\n   NULL), pointing to *N characters of space.  It is realloc'ed as\n   necessary.  Returns the number of characters read (not including the\n   null terminator), or -1 on error or EOF.",
    "_IO_getline": "",
    "_IO_getline_info": "",
    "_IO_gets": "",
    "_IO_padn": "",
    "_IO_puts": "",
    "_IO_seekoff": "",
    "_IO_seekpos": "",
    "_IO_setbuffer": "",
    "_IO_setvbuf": "",
    "ungetc": "",
    "ungetwc": "",
    "_IO_peekc_locked": "",
    "_IO_putc": "",
    "putchar": "",
    "putchar_unlocked": "",
    "putwc": "",
    "putwc_unlocked": "",
    "putwchar": "",
    "putwchar_unlocked": "",
    "rewind": "",
    "setbuf": "",
    "setlinebuf": "",
    "_IO_str_init_static": "",
    "_IO_str_init_readonly": "",
    "_IO_str_overflow": "",
    "_IO_str_underflow": "",
    "_IO_str_seekoff": "",
    "_IO_str_pbackfail": "",
    "_IO_wdo_write": "Convert TO_DO wide character from DATA to FP.\n   Then mark FP as having empty buffers.",
    "_IO_wfile_underflow": "",
    "_IO_wfile_overflow": "",
    "_IO_wfile_sync": "",
    "_IO_wfile_seekoff": "ftell{,o} implementation for wide mode.  Don't modify any state of the file\n   pointer while we try to get the current state of the stream except in one\n   case, which is when we have unflushed writes in append mode.",
    "_IO_wfile_xsputn": "Convert TO_DO wide character from DATA to FP.\n   Then mark FP as having empty buffers.",
    "_IO_least_wmarker": "Return minimum _pos markers\n   Assumes the current get area is the main get area.",
    "_IO_switch_to_main_wget_area": "",
    "_IO_switch_to_wbackup_area": "",
    "_IO_wsetb": "",
    "_IO_wdefault_pbackfail": "",
    "_IO_wdefault_finish": "",
    "_IO_wdefault_uflow": "",
    "__woverflow": "",
    "__wuflow": "",
    "__wunderflow": "",
    "_IO_wdefault_xsputn": "",
    "_IO_wdefault_xsgetn": "",
    "_IO_wdoallocbuf": "",
    "_IO_wdefault_doallocate": "",
    "_IO_switch_to_wget_mode": "",
    "_IO_free_wbackup_area": "",
    "_IO_sputbackwc": "",
    "_IO_sungetwc": "",
    "_IO_adjust_wcolumn": "",
    "_IO_init_wmarker": "",
    "_IO_wmarker_delta": "Return difference between MARK and current position of MARK's stream.",
    "_IO_seekwmark": "",
    "_IO_unsave_wmarkers": "",
    "open_wmemstream": "Open a stream that writes into a malloc'd buffer that is expanded as\n   necessary.  *BUFLOC and *SIZELOC are updated with the buffer's location\n   and the number of characters written on fflush or fclose.",
    "__ctype_get_mb_cur_max": "This is a gross hack to get broken programs running.\n\n   ISO C provides no mean to find out how many bytes the wide\n   character representation really uses.  But it defines MB_CUR_LEN to\n   return the information for the multi-byte character representation.\n   Many programmers don't know the difference between the two and\n   think this means the same.  But assuming all characters have a size\n   of MB_CUR_LEN after they have been processed by `mbrtowc' is wrong.\n   Instead the maximum number of characters used for the conversion is\n   MB_CUR_LEN.\n\n   It is known that some Motif applications have this problem.  To\n   cure this one has to make sure the glibc uses the function in this\n   file instead of the one in locale/mb_cur_max.c.  This can either be\n   done by linking with this file or by using the LD_PRELOAD feature\n   of the dynamic linker.",
    "__duplocale": "",
    "__freelocale": "",
    "__newlocale": "",
    "nl_langinfo": "Return a string with the data for locale-dependent parameter ITEM.",
    "__nl_langinfo_l": "Return a string with the data for locale-dependent parameter ITEM.",
    "setlocale": "Construct a new composite name.Put DATA in *_nl_current[CATEGORY].Put NAME in _nl_global_locale.__names.Put NAME in _nl_global_locale.__names.Construct a new composite name.Put DATA in *_nl_current[CATEGORY].Put NAME in _nl_global_locale.__names.Put NAME in _nl_global_locale.__names.",
    "__uselocale": "Switch the current thread's locale to DATASET.\n   If DATASET is null, instead just return the current setting.\n   The special value LC_GLOBAL_LOCALE is the initial setting\n   for all threads, and means the thread uses the global\n   setting controlled by `setlocale'.",
    "endutxent": "",
    "getlogin": "Return the login name of the user, or NULL if it can't be determined.\n   The returned pointer, if not NULL, is good only until the next call.",
    "__getlogin_r_chk": "",
    "getutmp": "",
    "getutmpx": "Copy the information in UTMP to UTMPX.",
    "getutxent": "",
    "getutxid": "",
    "getutxline": "",
    "__ptsname_r_chk": "",
    "pututxline": "",
    "setlogin": "Set the login name returned by `getlogin'.",
    "setutxent": "",
    "updwtmpx": "",
    "utmpxname": "",
    "__libc_alloc_buffer_alloc_array": "",
    "__libc_alloc_buffer_allocate": "",
    "__libc_alloc_buffer_copy_bytes": "This function works on a copy of the buffer object, so that it can\n   remain non-addressable in the caller.",
    "__libc_alloc_buffer_copy_string": "This function works on a copy of the buffer object, so that it can\n   remain non-addressable in the caller.",
    "__libc_alloc_buffer_create_failure": "",
    "__libc_dynarray_at_failure": "",
    "__libc_dynarray_emplace_enlarge": "",
    "__libc_dynarray_finalize": "",
    "__libc_dynarray_resize": "",
    "__libc_dynarray_resize_clear": "",
    "malloc_usable_size": "",
    "malloc_info": "",
    "mallopt": "",
    "malloc_stats": "",
    "mallinfo2": "",
    "mallinfo": "",
    "malloc_trim": "",
    "__libc_malloc": "Check if REQ overflows when padded and aligned and if the resulting\n   value is less than PTRDIFF_T.  Returns the requested size or\n   MINSIZE in case the value is less than MINSIZE, or 0 if any of the\n   previous checks fail.Like the above, but removes from the head of the list.",
    "__libc_free": "------------------------------ free ------------------------------",
    "__libc_realloc": "------------------------- malloc_usable_size --------------------------------------------- Alternative MORECORE functions --------------------Check if REQ overflows when padded and aligned and if the resulting\n   value is less than PTRDIFF_T.  Returns the requested size or\n   MINSIZE in case the value is less than MINSIZE, or 0 if any of the\n   previous checks fail.------------------------------ realloc ------------------------------------------------------------ realloc ------------------------------------------------------------ free ------------------------------",
    "__libc_memalign": "",
    "aligned_alloc": "",
    "__libc_valloc": "",
    "__libc_pvalloc": "",
    "__libc_calloc": "",
    "__libc_mallinfo": "",
    "__libc_mallopt": "------------------------- malloc_consolidate -------------------------\n\n  malloc_consolidate is a specialized version of free() that tears\n  down chunks held in fastbins.  Free itself cannot be used for this\n  purpose since, among other things, it might place chunks back onto\n  fastbins.  So, instead, we need to use a minor variant of the same\n  code.------------------------------ mallopt ------------------------------",
    "mcheck_check_all": "",
    "mcheck": "",
    "mcheck_pedantic": "",
    "mprobe": "",
    "mmap": "`mmap' replacement.  We do not have to keep track of the size since\n   `munmap' will get it as a parameter.",
    "mmap64": "`mmap64' replacement.  We do not have to keep track of the size since\n   `munmap' will get it as a parameter.",
    "mremap": "`mremap' replacement.  We do not have to keep track of the size since\n   `munmap' will get it as a parameter.",
    "munmap": "`munmap' replacement.",
    "tr_break": "",
    "mtrace": "",
    "muntrace": "",
    "_obstack_begin": "Initialize an obstack H for use.  Specify chunk size SIZE (0 means default).\n   Objects start on multiples of ALIGNMENT (0 means use default).\n   CHUNKFUN is the function to use to allocate chunks,\n   and FREEFUN the function to free them.\n\n   Return nonzero if successful, calls obstack_alloc_failed_handler if\n   allocation fails.",
    "_obstack_begin_1": "",
    "_obstack_newchunk": "Allocate a new current chunk for the obstack *H\n   on the assumption that LENGTH bytes need to be added\n   to the current object, or a new object of length LENGTH allocated.\n   Copies any partial object from the end of the old chunk\n   to the beginning of the new one.",
    "_obstack_allocated_p": "",
    "_obstack_memory_used": "Older versions of libc used a function _obstack_free intended to be\n   called by non-GCC compilers.",
    "__libc_reallocarray": "",
    "__libc_scratch_buffer_grow": "",
    "__libc_scratch_buffer_grow_preserve": "",
    "__libc_scratch_buffer_set_array_size": "",
    "__libc_freeres": "",
    "twalk": "",
    "fedisableexcept": "",
    "feenableexcept": "",
    "fegetexcept": "",
    "fegetmode": "",
    "fesetexcept": "",
    "fesetmode": "",
    "fetestexceptflag": "",
    "fetestexcept": "",
    "matherr": "",
    "acct": "Turn accounting on if NAME is an existing file.  The system will then write\n   a record for each process as it terminates, to this file.  If NAME is NULL,\n   turn accounting off.  This call is restricted to the super-user.",
    "__libc_allocate_once_slow": "",
    "chflags": "XXX shouldn't this be __chflags?",
    "chroot": "Make PATH be the root directory (the starting point for absolute\n   paths).  Note that while on traditional UNIX systems this call is\n   restricted to the super-user, it isn't on the Hurd.",
    "daemon": "",
    "dirname": "",
    "vwarn": "",
    "vwarnx": "",
    "warn": "",
    "warnx": "",
    "verr": "",
    "verrx": "",
    "err": "",
    "errx": "",
    "error": "",
    "error_at_line": "",
    "fchflags": "XXX should be __fchflags?",
    "fdatasync": "Synchronize at least the data part of a file with the underlying\n   media.",
    "fgetxattr": "",
    "flistxattr": "",
    "fremovexattr": "",
    "fsetxattr": "",
    "setfsent": "",
    "getfsent": "",
    "getfsspec": "",
    "getfsfile": "",
    "endfsent": "",
    "fsync": "Make all changes done to FD actually appear on disk.",
    "futimesat": "Change the access time of FILE relative to FD to TVP[0] and\n   the modification time of FILE to TVP[1].",
    "__getauxval": "",
    "getdomainname": "Put the name of the current NIS domain in no more than LEN bytes of NAME.\n   The result is null-terminated if LEN is large enough for the full\n   name and the terminator.",
    "gethostid": "",
    "getloadavg": "",
    "__getpagesize": "Return the system page size.",
    "getpass": "",
    "getusershell": "* Get a list of shells from _PATH_SHELLS, if it exists.",
    "endusershell": "",
    "setusershell": "",
    "getxattr": "",
    "gtty": "Fill in *PARAMS with terminal parameters associated with FD.",
    "hsearch": "Define the non-reentrant function using the reentrant counterparts.",
    "hcreate": "",
    "insque": "Insert ELEM into a doubly-linked list, after PREV.",
    "remque": "Unlink ELEM from the doubly-linked list that it is in.",
    "lgetxattr": "",
    "listxattr": "",
    "llistxattr": "",
    "lremovexattr": "",
    "lsearch": "",
    "lfind": "",
    "lsetxattr": "",
    "__madvise": "Advise the system about particular usage patterns the program follows\n   for the region starting at ADDR and extending LEN bytes.",
    "mincore": "",
    "mkdtemp": "Generate a unique temporary directory from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   The directory is created, mode 700, and its name is returned.\n   (This function comes from OpenBSD.)",
    "mkostemp": "Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Then open the file and return a fd.",
    "mkostemp64": "Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Then open the file and return a fd.",
    "mkostemps": "Generate a unique temporary file name from TEMPLATE.  The last six\n   characters before a suffix of length SUFFIXLEN of TEMPLATE must be\n   \"XXXXXX\"; they are replaced with a string that makes the filename\n   unique.  Then open the file and return a fd.",
    "mkostemps64": "Generate a unique temporary file name from TEMPLATE.  The last six\n   characters before a suffix of length SUFFIXLEN of TEMPLATE must be\n   \"XXXXXX\"; they are replaced with a string that makes the filename\n   unique.  Then open the file and return a fd.",
    "mkstemp": "Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Then open the file and return a fd.",
    "mkstemp64": "Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.\n   Then open the file and return a fd.",
    "mkstemps": "Generate a unique temporary file name from TEMPLATE.  The last six\n   characters before a suffix of length SUFFIXLEN of TEMPLATE must be\n   \"XXXXXX\"; they are replaced with a string that makes the filename\n   unique.  Then open the file and return a fd.",
    "mkstemps64": "Generate a unique temporary file name from TEMPLATE.  The last six\n   characters before a suffix of length SUFFIXLEN of TEMPLATE must be\n   \"XXXXXX\"; they are replaced with a string that makes the filename\n   unique.  Then open the file and return a fd.",
    "__mktemp": "Generate a unique temporary file name from TEMPLATE.\n   The last six characters of TEMPLATE must be \"XXXXXX\";\n   they are replaced with a string that makes the filename unique.",
    "mlock": "Guarantee all whole pages mapped by the range [ADDR,ADDR+LEN) to\n   be memory resident.",
    "mlockall": "Cause all currently mapped pages of the process to be memory resident\n   until unlocked by a call to the `munlockall', until the process exits,\n   or until the process calls `execve'.",
    "__mmap": "",
    "getmntent": "",
    "__setmntent": "Prepare to begin reading and/or writing mount table entries from the\n   beginning of FILE.  MODE is as for `fopen'.",
    "__getmntent_r": "Read one mount table entry from STREAM.  Returns a pointer to storage\n   reused on the next call, or null for EOF or error (use feof/ferror to\n   check).",
    "__mprotect": "Change the memory protection of the region starting at ADDR and\n   extending LEN bytes to PROT.  Returns 0 if successful, -1 for errors\n   (and sets errno).",
    "msync": "",
    "munlock": "Undo the effects on these whole pages of any prior mlock calls.",
    "munlockall": "Undo the effects of all prior mlock calls in this process.",
    "__munmap": "Deallocate any mapping for the region starting at ADDR and extending LEN\n   bytes.  Returns 0 if successful, -1 for errors (and sets errno).",
    "preadv": "",
    "preadv2": "",
    "preadv64": "",
    "preadv64v2": "",
    "ptrace": "",
    "pwritev": "",
    "pwritev2": "",
    "pwritev64": "",
    "pwritev64v2": "",
    "reboot": "Call kernel with additional two arguments the syscall requires.",
    "step": "",
    "advance": "",
    "removexattr": "",
    "__sbrk": "Extend the process's data space by INCREMENT.\n   If INCREMENT is negative, shrink data space by - INCREMENT.\n   Return the address of the start of the new data space, or -1 for errors.",
    "__select": "Check the first NFDS descriptors each in READFDS (if not NULL) for read\n   readiness, in WRITEFDS (if not NULL) for write readiness, and in EXCEPTFDS\n   (if not NULL) for exceptional conditions.  If TIMEOUT is not NULL, time out\n   after waiting the interval specified therein.  Returns the number of ready\n   descriptors, or -1 for errors.",
    "setdomainname": "Set the name of the current YP domain to NAME, which is LEN bytes long.\n   This call is restricted to the super-user.",
    "setegid": "",
    "seteuid": "",
    "sethostid": "",
    "sethostname": "XXX should be __sethostname ?",
    "setxattr": "",
    "sstk": "",
    "stty": "Set the terminal parameters associated with FD to *PARAMS.",
    "swapoff": "Stop using block special device PATH for swapping.",
    "swapon": "Make the block special device PATH available to the system for swapping.\n   This call is restricted to the super-user.",
    "sync": "Make all changes done to all files actually appear on disk.",
    "syncfs": "",
    "syscall": "",
    "__vsyslog_chk": "",
    "openlog": "",
    "closelog": "",
    "setlogmask": "setlogmask -- set the log mask level",
    "truncate64": "Truncate PATH to LENGTH bytes.",
    "__tsearch": "Find or insert datum into search tree.\n   KEY is the key to be located, ROOTP is the address of tree root,\n   COMPAR the ordering function.",
    "__tfind": "",
    "__tdelete": "",
    "__twalk": "Walk the nodes of a tree.\n   ROOT is the root of the tree to be walked, ACTION the function to be\n   called at each node.",
    "__twalk_r": "",
    "ttyslot": "",
    "ualarm": "Set an alarm to go off (generating a SIGALRM signal) in VALUE microseconds.\n   If INTERVAL is nonzero, when the alarm goes off, the timer is reset to go\n   off every INTERVAL microseconds thereafter.\n\n   Returns the number of microseconds remaining before the alarm.",
    "__libc_unwind_link_get": "",
    "usleep": "",
    "vhangup": "Revoke access permissions to all processes currently communicating\n   with the control terminal, and then send a SIGHUP signal to the process\n   group of the control terminal.",
    "_pthread_cleanup_push_defer": "",
    "_pthread_cleanup_pop_restore": "",
    "__nptl_create_event": "",
    "__nptl_death_event": "",
    "__lll_lock_wait_private": "",
    "__lll_lock_wake_private": "",
    "__pthread_get_minstack": "",
    "clock_getcpuclockid": "",
    "clock_gettime": "Get current value of CLOCK and store it in TP.",
    "pthread_attr_setsigmask_np": "",
    "thrd_current": "",
    "thrd_yield": "",
    "__nss_passwd_lookup": "On i386, the function calling convention changed from the standard\n   ABI calling convention to three register parameters in glibc 2.8.\n   The following error-returning stub happens to be compatible with\n   glibc 2.7 and earlier and glibc 2.8 and later, even on i386.",
    "__nss_next": "These functions were exported under a non-GLIBC_PRIVATE version,\n   even though it is not usable externally due to the service_user\n   (now nss_action_list) type dependency.",
    "__nss_database_lookup": "",
    "__nss_hostname_digits_dots": "",
    "ether_hostton": "",
    "ether_ntohost": "",
    "fgetgrent": "Read one entry from the given stream.",
    "fgetpwent": "Read one entry from the given stream.",
    "fgetsgent": "Read one shadow entry from the given stream.",
    "fgetspent": "Read one shadow entry from the given stream.",
    "getaddrinfo": "",
    "freeaddrinfo": "",
    "getnameinfo": "Convert the host part of an AF_LOCAK socket address.Convert service to string, dispatching to the implementations\n   above.",
    "getnetgrent": "",
    "__internal_setnetgrent": "Free used memory.",
    "setnetgrent": "",
    "__internal_endnetgrent": "Free used memory.",
    "endnetgrent": "",
    "__internal_getnetgrent_r": "",
    "innetgr": "Test whether given (host,user,domain) triple is in NETGROUP.",
    "__copy_grp": "",
    "__merge_grp": "",
    "getgrouplist": "Store at most *NGROUPS members of the group set for USER into\n   *GROUPS.  Also include GROUP.  The actual number of groups found is\n   returned in *NGROUPS.  Return -1 if the if *NGROUPS is too small.",
    "initgroups": "",
    "__nss_configure_lookup": "Return pointer to global NSS database state, allocating as\n   required, or returning NULL on failure.",
    "__nss_database_get": "Return pointer to global NSS database state, allocating as\n   required, or returning NULL on failure.",
    "__nss_files_data_open": "Like __nss_files_data_open, but does not perform the open call.Helper function for opening the backing file at PATH.",
    "__nss_files_data_put": "",
    "__nss_files_data_setent": "Like __nss_files_data_open, but does not perform the open call.Helper function for opening the backing file at PATH.",
    "__nss_files_data_endent": "",
    "__nss_files_fopen": "",
    "__nss_hash": "* This is INCREDIBLY ugly, but fast.  We break the string up into 4 byte\n * units.  On the first time through the loop we get the \"leftover bytes\"\n * (len % 4).  On every other iteration, we perform a 4x unrolled version\n * HASHC. Further unrolling does not appear to help.\n *\n * OZ's original sdbm hash",
    "__nss_disable_nscd": "Called by nscd and nscd alone.",
    "__nss_parse_line_result": "",
    "__nss_readline": "",
    "__nss_lookup": "-1 == not found\n    0 == function found\n    1 == finished",
    "__nss_next2": "",
    "__nss_lookup_function": "",
    "putgrent": "Write an entry to the given stream.\n   This must know the format of the group file.",
    "putpwent": "Write an entry to the given stream.  This must know the format of\n   the password file.  If the input contains invalid characters,\n   return EINVAL, or replace them with spaces (if they are contained\n   in the GECOS field).",
    "putsgent": "Write an entry to the given stream.\n   This must know the format of the group file.",
    "putspent": "Write an entry to the given stream.\n   This must know the format of the password file.",
    "sgetsgent": "Read one shadow entry from the given stream.",
    "sgetspent": "Read one shadow entry from the given stream.",
    "_nss_files_setaliasent": "Thread-safe, exported version of that.",
    "_nss_files_endaliasent": "",
    "_nss_files_getaliasent_r": "Parsing the database file into `struct aliasent' data structures.",
    "_nss_files_getaliasbyname_r": "Maintenance of the stream open on the database file.  For getXXent\n   operations the stream needs to be held open across calls, the other\n   getXXbyYY operations all use their own stream.Parsing the database file into `struct aliasent' data structures.",
    "_nss_files_gethostbyname3_r": "",
    "_nss_files_gethostbyname_r": "",
    "_nss_files_gethostbyname2_r": "",
    "_nss_files_gethostbyname4_r": "",
    "_nss_files_init": "",
    "_nss_files_initgroups_dyn": "",
    "_nss_files_setnetgrent": "",
    "_nss_files_endnetgrent": "",
    "_nss_netgroup_parseline": "",
    "_nss_files_getnetgrent_r": "",
    "_Fork": "",
    "_exit": "",
    "alarm": "Schedule an alarm.  In SECONDS seconds, the process will get a SIGALRM.\n   If SECONDS is zero, any currently scheduled alarm will be cancelled.\n   The function returns the number of seconds remaining until the last\n   alarm scheduled would have signaled, or zero if there wasn't one.\n   There is no return value to indicate an error, but you can set `errno'\n   to 0 and check its value after calling `alarm', and this might tell you.\n   The signal may come late due to processor scheduling.",
    "__bsd_getpgrp": "",
    "execl": "Execute PATH with all arguments after PATH until\n   a NULL pointer and environment from `environ'.",
    "execle": "Execute PATH with all arguments after PATH until a NULL pointer,\n   and the argument after that for environment.",
    "execlp": "Execute FILE, searching in the `PATH' environment variable if\n   it contains no slashes, with all arguments after FILE until a\n   NULL pointer and environment from `environ'.",
    "execv": "Execute PATH with arguments ARGV and environment from `environ'.",
    "execvp": "Execute FILE, searching in the `PATH' environment variable if it contains\n   no slashes, with arguments ARGV and environment from `environ'.",
    "fexecve": "Execute the file FD refers to, overlaying the running program image.\n   ARGV and ENVP are passed to the new program, as for `execve'.",
    "fnmatch": "",
    "__libc_fork": "",
    "gai_strerror": "",
    "getopt_long": "",
    "getopt_long_only": "Like getopt_long, but '-' as well as '--' can indicate a long option.\n   If an option that starts with '-' (not '--') doesn't match a long option,\n   but does match a short option, it is parsed as a short option\n   instead.",
    "__getpgid": "Get the process group ID of process PID.",
    "getpgrp": "Get the process group ID of the calling process.",
    "__getpid": "Get the process ID of the calling process.",
    "getsid": "",
    "glob64": "Do glob searching for PATTERN, placing results in PGLOB.\n   The bits defined above may be set in FLAGS.\n   If a directory cannot be opened or read and ERRFUNC is not nil,\n   it is called with the pathname that caused the error, and the\n   `errno' value from the failing call; if it returns non-zero\n   `glob' returns GLOB_ABORTED; if it returns zero, the error is ignored.\n   If memory cannot be allocated for PGLOB, GLOB_NOSPACE is returned.\n   Otherwise, `glob' returns zero.",
    "globfree": "Free storage allocated in PGLOB by a previous `glob' call.",
    "globfree64": "Free storage allocated in PGLOB by a previous `glob' call.",
    "__nanosleep": "",
    "pause": "Suspend the process until a signal arrives.\n   This is supposed to always return -1 and set errno to EINTR,\n   but rules were meant to be broken.",
    "posix_madvise": "",
    "__libc_pread": "",
    "__libc_pwrite": "",
    "re_compile_pattern": "re_compile_pattern is the GNU regular expression compiler: it\n   compiles PATTERN (of length LENGTH) and puts the result in BUFP.\n   Returns 0 if the pattern was valid, otherwise an error string.\n\n   Assumes the 'allocated' (and perhaps 'buffer') and 'translate' fields\n   are set in BUFP on entry.",
    "re_set_syntax": "Specify the precise syntax of regexps for compilation.  This provides\n   for compatibility for various utilities which historically have\n   different, incompatible syntaxes.\n\n   The argument SYNTAX is a bit mask comprised of the various bits\n   defined in regex.h.  We return the old syntax.",
    "re_compile_fastmap": "Helper function for re_compile_fastmap.\n   Compile fastmap for the initial_state INIT_STATE.Helper function for re_compile_fastmap.\n   Compile fastmap for the initial_state INIT_STATE.Helper function for re_compile_fastmap.\n   Compile fastmap for the initial_state INIT_STATE.Helper function for re_compile_fastmap.\n   Compile fastmap for the initial_state INIT_STATE.",
    "regcomp": "regcomp takes a regular expression as a string and compiles it.\n\n   PREG is a regex_t *.  We do not expect any fields to be initialized,\n   since POSIX says we shouldn't.  Thus, we set\n\n     'buffer' to the compiled pattern;\n     'used' to the length of the compiled pattern;\n     'syntax' to RE_SYNTAX_POSIX_EXTENDED if the\n       REG_EXTENDED bit in CFLAGS is set; otherwise, to\n       RE_SYNTAX_POSIX_BASIC;\n     'newline_anchor' to REG_NEWLINE being set in CFLAGS;\n     'fastmap' to an allocated space for the fastmap;\n     'fastmap_accurate' to zero;\n     're_nsub' to the number of subexpressions in PATTERN.\n\n   PATTERN is the address of the pattern string.\n\n   CFLAGS is a series of bits which affect compilation.\n\n     If REG_EXTENDED is set, we use POSIX extended syntax; otherwise, we\n     use POSIX basic syntax.\n\n     If REG_NEWLINE is set, then . and [^...] don't match newline.\n     Also, regexec will try a match beginning after every newline.\n\n     If REG_ICASE is set, then we considers upper- and lowercase\n     versions of letters to be equivalent when matching.\n\n     If REG_NOSUB is set, then when PREG is passed to regexec, that\n     routine will report only success or failure, and nothing about the\n     registers.\n\n   It returns 0 if it succeeds, nonzero if it doesn't.  (See regex.h for\n   the return codes and their meanings.)",
    "regerror": "",
    "regfree": "Free dynamically allocated space used by PREG.",
    "re_comp": "Make these definitions weak in libc, so POSIX programs can redefine\n   these names if they don't use our functions, and still use\n   regcomp/regexec above without link errors.",
    "regexec": "regexec searches for a given pattern, specified by PREG, in the\n   string STRING.\n\n   If NMATCH is zero or REG_NOSUB was set in the cflags argument to\n   'regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at\n   least NMATCH elements, and we set them to the offsets of the\n   corresponding matched substrings.\n\n   EFLAGS specifies \"execution flags\" which affect matching: if\n   REG_NOTBOL is set, then ^ does not match at the beginning of the\n   string; if REG_NOTEOL is set, then $ does not match at the end.\n\n   Return 0 if a match is found, REG_NOMATCH if not, REG_BADPAT if\n   EFLAGS is invalid.",
    "re_match": "re_match, re_search, re_match_2, re_search_2\n\n   The former two functions operate on STRING with length LENGTH,\n   while the later two operate on concatenation of STRING1 and STRING2\n   with lengths LENGTH1 and LENGTH2, respectively.\n\n   re_match() matches the compiled pattern in BUFP against the string,\n   starting at index START.\n\n   re_search() first tries matching at index START, then it tries to match\n   starting from index START + 1, and so on.  The last start position tried\n   is START + RANGE.  (Thus RANGE = 0 forces re_search to operate the same\n   way as re_match().)\n\n   The parameter STOP of re_{match,search}_2 specifies that no match exceeding\n   the first STOP characters of the concatenation of the strings should be\n   concerned.\n\n   If REGS is not NULL, and BUFP->no_sub is not set, the offsets of the match\n   and all groups is stored in REGS.  (For the \"_2\" variants, the offsets are\n   computed relative to the concatenation, not relative to the individual\n   strings.)\n\n   On success, re_match* functions return the length of the match, re_search*\n   return the position of the start of the match.  They return -1 on\n   match failure, -2 on error.",
    "re_search": "The parameters have the same meaning as those of re_search.\n   Additional parameters:\n   If RET_LEN is true the length of the match is returned (re_match style);\n   otherwise the position of the match is returned.",
    "re_match_2": "",
    "re_search_2": "",
    "re_set_registers": "Set REGS to hold NUM_REGS registers, storing them in STARTS and\n   ENDS.  Subsequent matches using PATTERN_BUFFER and REGS will use\n   this memory for recording register information.  STARTS and ENDS\n   must be allocated using the malloc library routine, and must each\n   be at least NUM_REGS * sizeof (regoff_t) bytes long.\n\n   If NUM_REGS == 0, then subsequent matches should allocate their own\n   register data.\n\n   Unless this function is called, the first search or match using\n   PATTERN_BUFFER will allocate its own register data, without\n   freeing the old data.",
    "re_exec": "regexec searches for a given pattern, specified by PREG, in the\n   string STRING.\n\n   If NMATCH is zero or REG_NOSUB was set in the cflags argument to\n   'regcomp', we ignore PMATCH.  Otherwise, we assume PMATCH has at\n   least NMATCH elements, and we set them to the offsets of the\n   corresponding matched substrings.\n\n   EFLAGS specifies \"execution flags\" which affect matching: if\n   REG_NOTBOL is set, then ^ does not match at the beginning of the\n   string; if REG_NOTEOL is set, then $ does not match at the end.\n\n   Return 0 if a match is found, REG_NOMATCH if not, REG_BADPAT if\n   EFLAGS is invalid.",
    "__register_atfork": "",
    "__sched_cpualloc": "",
    "__sched_cpucount": "Counting bits set, Brian Kernighan's way.\n   Using a open-coded routine is slight better for architectures that\n   do not have a popcount instruction (compiler might emit a library\n   call).",
    "__sched_cpufree": "",
    "sched_getaffinity": "Retrieve the CPU affinity mask for a particular process.",
    "__sched_getparam": "Retrieve scheduling parameters for a particular process.",
    "__sched_getscheduler": "Retrieve scheduling algorithm for a particular purpose.",
    "__sched_get_priority_max": "Get maximum priority value for a scheduler.",
    "__sched_get_priority_min": "Get minimum priority value for a scheduler.",
    "sched_setaffinity": "Retrieve the CPU affinity mask for a particular process.",
    "__sched_setscheduler": "Set scheduling algorithm and/or parameters for a process.",
    "__sched_yield": "Yield the processor.",
    "setgroups": "Set the group set for the current user to GROUPS (N of them).  For\n   Linux we must convert the array of groups into the format that the\n   kernel expects.",
    "__setpgid": "Set the process group ID of the process matching PID to PGID.\n   If PID is zero, the current process's process group ID is set.\n   If PGID is zero, the process ID of the process is used.",
    "setpgrp": "",
    "__shm_get_name": "",
    "posix_spawn_file_actions_addchdir_np": "",
    "posix_spawn_file_actions_addfchdir_np": "",
    "posix_spawnattr_getsigdefault": "Store signal mask for signals with default handling from ATTR in\n   SIGDEFAULT.",
    "posix_spawnattr_getflags": "Get flag word from the attribute structure.",
    "posix_spawnattr_getpgroup": "Get process group ID from the attribute structure.",
    "posix_spawnattr_getschedparam": "Get scheduling parameters from the attribute structure.",
    "posix_spawnattr_getschedpolicy": "Get scheduling policy from the attribute structure.",
    "posix_spawnattr_getsigmask": "Store signal mask for the new process from ATTR in SIGMASK.",
    "posix_spawnattr_setpgroup": "Store process group ID in the attribute structure.",
    "posix_spawnattr_setschedparam": "Store scheduling parameters in the attribute structure.",
    "posix_spawnattr_setschedpolicy": "Store scheduling policy in the attribute structure.",
    "fattach": "",
    "fdetach": "",
    "getmsg": "",
    "getpmsg": "",
    "isastream": "",
    "putmsg": "",
    "putpmsg": "",
    "__sysconf": "Get the value of the system variable NAME.",
    "__vfork": "If we don't have vfork, fork is close enough.",
    "__wait": "Wait for a child to die.  When one does, put its status in *STAT_LOC\n   and return its process ID.  For errors, return (pid_t) -1.",
    "__waitpid": "Wait for a child matching PID to die.\n   If PID is greater than 0, match any process whose process ID is PID.\n   If PID is (pid_t) -1, match any process.\n   If PID is (pid_t) 0, match any process with the\n   same process group as the current process.\n   If PID is less than -1, match any process whose\n   process group is the absolute value of PID.\n   If the WNOHANG bit is set in OPTIONS, and that child\n   is not already dead, return (pid_t) 0.  If successful,\n   return PID and store the dead child's status in STAT_LOC.\n   Return (pid_t) -1 for errors.  If the WUNTRACED bit is set in OPTIONS,\n   return status for stopped children; otherwise don't.",
    "wordfree": "* wordfree() is to be called after pwordexp is finished with.",
    "wordexp": "Result of w_newword will be ignored if it's the last word.* wordfree() is to be called after pwordexp is finished with.The parse_*() functions should leave *offset being the offset in 'words'\n * to the last character processed.Result of w_newword will be ignored if it's the last word.* wordfree() is to be called after pwordexp is finished with.",
    "herror": "* herror --\n *\tprint the error indicated by the h_errno value.",
    "hstrerror": "* hstrerror --\n *\treturn the string associated with a given \"host\" errno value.",
    "__inet_aton_exact": "Check whether \"cp\" is a valid ASCII representation of an IPv4\n   Internet address and convert it to a binary address.  Returns 1 if\n   the address is valid, 0 if not.  This replaces inet_addr, the\n   return value from which cannot distinguish between failure and a\n   local broadcast address.  Write a pointer to the first\n   non-converted character to *endp.",
    "inet_ntop": "char *\n * inet_ntop(af, src, dst, size)\n *\tconvert a network format address to presentation format.\n * return:\n *\tpointer to presentation format address (`dst'), or NULL (see errno).\n * author:\n *\tPaul Vixie, 1996.",
    "__inet_pton_length": "Convert presentation-level IPv6 address to network order binary\n   form.  Return 1 if SRC is a valid [RFC1884 2.2] address, else 0.\n   This function does not touch DST unless it's returning 1.\n   Author: Paul Vixie, 1996.  Inspired by Mark Andrews.",
    "__libc_ns_makecanon": "Make a canonical copy of domain name SRC in DST.  Behavior:\n      foo -> foo.\n      foo. -> foo.\n      foo.. -> foo.\n      foo\\. -> foo\\..\n      foo\\\\. -> foo\\\\.",
    "__libc_ns_samename": "Determines whether domain name A is the same as domain name B.\n   Returns -1 on error, 0 if names differ, 1 if names are the\n   same.",
    "inet_nsap_addr": "",
    "inet_nsap_ntoa": "",
    "__res_iclose": "Close all open sockets.  If FREE_ADDR is true, deallocate any\n   separately allocated name server addresses.",
    "__res_state": "",
    "__res_context_hostalias": "",
    "__res_get_nsaddr": "",
    "__res_context_mkquery": "",
    "__res_nopt": "Create an OPT resource record.  Return the length of the final\n   packet, or -1 on error.\n\n   STATP must be an initialized resolver state.  N0 is the current\n   number of bytes of the packet (already written to BUF by the\n   aller).  BUF is the packet being constructed.  The array it\n   pointers to must be BUFLEN bytes long.  ANSLEN is the advertised\n   EDNS buffer size (to be included in the OPT resource record).",
    "__libc_res_nameinquery": "Author: paul vixie, 29may94.",
    "__libc_res_queriesmatch": "Author: paul vixie, 29may94.",
    "__res_context_query": "Formulate a normal query, send, and await answer.  Returned answer\n   is placed in supplied buffer ANSWER.  Perform preliminary check of\n   answer, returning success only if no error is indicated and the\n   answer count is nonzero.  Return the size of the response on\n   success, -1 on error.  Error number is left in h_errno.\n\n   Caller must parse answer and determine whether it answers the\n   question.",
    "__res_context_search": "Formulate a normal query, send, and retrieve answer in supplied\n   buffer.  Return the size of the response on success, -1 on error.\n   If enabled, implement search rules until answer or unrecoverable\n   failure is detected.  Error code, if any, is left in h_errno.",
    "__res_context_send": "Returns a shift value for the name server index.  Used to implement\n   RES_ROTATE.The send_vc function is responsible for sending a DNS query over TCP\n   to the nameserver numbered NS from the res_state STATP i.e.\n   EXT(statp).nssocks[ns].  The function supports sending both IPv4 and\n   IPv6 queries at the same serially on the same socket.\n\n   Please note that for TCP there is no way to disable sending both\n   queries, unlike UDP, which honours RES_SNGLKUP and RES_SNGLKUPREOP\n   and sends the queries serially and waits for the result after each\n   sent query.  This implementation should be corrected to honour these\n   options.\n\n   Please also note that for TCP we send both queries over the same\n   socket one after another.  This technically violates best practice\n   since the server is allowed to read the first query, respond, and\n   then close the socket (to service another client).  If the server\n   does this, then the remaining second query in the socket data buffer\n   will cause the server to send the client an RST which will arrive\n   asynchronously and the client's OS will likely tear down the socket\n   receive buffer resulting in a potentially short read and lost\n   response data.  This will force the client to retry the query again,\n   and this process may repeat until all servers and connection resets\n   are exhausted and then the query will fail.  It's not known if this\n   happens with any frequency in real DNS server implementations.  This\n   implementation should be corrected to use two sockets by default for\n   parallel queries.\n\n   The query stored in BUF of BUFLEN length is sent first followed by\n   the query stored in BUF2 of BUFLEN2 length.  Queries are sent\n   serially on the same socket.\n\n   Answers to the query are stored firstly in *ANSP up to a max of\n   *ANSSIZP bytes.  If more than *ANSSIZP bytes are needed and ANSCP\n   is non-NULL (to indicate that modifying the answer buffer is allowed)\n   then malloc is used to allocate a new response buffer and ANSCP and\n   ANSP will both point to the new buffer.  If more than *ANSSIZP bytes\n   are needed but ANSCP is NULL, then as much of the response as\n   possible is read into the buffer, but the results will be truncated.\n   When truncation happens because of a small answer buffer the DNS\n   packets header field TC will bet set to 1, indicating a truncated\n   message and the rest of the socket data will be read and discarded.\n\n   Answers to the query are stored secondly in *ANSP2 up to a max of\n   *ANSSIZP2 bytes, with the actual response length stored in\n   *RESPLEN2.  If more than *ANSSIZP bytes are needed and ANSP2\n   is non-NULL (required for a second query) then malloc is used to\n   allocate a new response buffer, *ANSSIZP2 is set to the new buffer\n   size and *ANSP2_MALLOCED is set to 1.\n\n   The ANSP2_MALLOCED argument will eventually be removed as the\n   change in buffer pointer can be used to detect the buffer has\n   changed and that the caller should use free on the new buffer.\n\n   Note that the answers may arrive in any order from the server and\n   therefore the first and second answer buffers may not correspond to\n   the first and second queries.\n\n   It is not supported to call this function with a non-NULL ANSP2\n   but a NULL ANSCP.  Put another way, you can call send_vc with a\n   single unmodifiable buffer or two modifiable buffers, but no other\n   combination is supported.\n\n   It is the caller's responsibility to free the malloc allocated\n   buffers by detecting that the pointers have changed from their\n   original values i.e. *ANSCP or *ANSP2 has changed.\n\n   If errors are encountered then *TERRNO is set to an appropriate\n   errno value and a zero result is returned for a recoverable error,\n   and a less-than zero result is returned for a non-recoverable error.\n\n   If no errors are encountered then *TERRNO is left unmodified and\n   a the length of the first response in bytes is returned.The send_dg function is responsible for sending a DNS query over UDP\n   to the nameserver numbered NS from the res_state STATP i.e.\n   EXT(statp).nssocks[ns].  The function supports IPv4 and IPv6 queries\n   along with the ability to send the query in parallel for both stacks\n   (default) or serially (RES_SINGLKUP).  It also supports serial lookup\n   with a close and reopen of the socket used to talk to the server\n   (RES_SNGLKUPREOP) to work around broken name servers.\n\n   The query stored in BUF of BUFLEN length is sent first followed by\n   the query stored in BUF2 of BUFLEN2 length.  Queries are sent\n   in parallel (default) or serially (RES_SINGLKUP or RES_SNGLKUPREOP).\n\n   Answers to the query are stored firstly in *ANSP up to a max of\n   *ANSSIZP bytes.  If more than *ANSSIZP bytes are needed and ANSCP\n   is non-NULL (to indicate that modifying the answer buffer is allowed)\n   then malloc is used to allocate a new response buffer and ANSCP and\n   ANSP will both point to the new buffer.  If more than *ANSSIZP bytes\n   are needed but ANSCP is NULL, then as much of the response as\n   possible is read into the buffer, but the results will be truncated.\n   When truncation happens because of a small answer buffer the DNS\n   packets header field TC will bet set to 1, indicating a truncated\n   message, while the rest of the UDP packet is discarded.\n\n   Answers to the query are stored secondly in *ANSP2 up to a max of\n   *ANSSIZP2 bytes, with the actual response length stored in\n   *RESPLEN2.  If more than *ANSSIZP bytes are needed and ANSP2\n   is non-NULL (required for a second query) then malloc is used to\n   allocate a new response buffer, *ANSSIZP2 is set to the new buffer\n   size and *ANSP2_MALLOCED is set to 1.\n\n   The ANSP2_MALLOCED argument will eventually be removed as the\n   change in buffer pointer can be used to detect the buffer has\n   changed and that the caller should use free on the new buffer.\n\n   Note that the answers may arrive in any order from the server and\n   therefore the first and second answer buffers may not correspond to\n   the first and second queries.\n\n   It is not supported to call this function with a non-NULL ANSP2\n   but a NULL ANSCP.  Put another way, you can call send_vc with a\n   single unmodifiable buffer or two modifiable buffers, but no other\n   combination is supported.\n\n   It is the caller's responsibility to free the malloc allocated\n   buffers by detecting that the pointers have changed from their\n   original values i.e. *ANSCP or *ANSP2 has changed.\n\n   If an answer is truncated because of UDP datagram DNS limits then\n   *V_CIRCUIT is set to 1 and the return value non-zero to indicate to\n   the caller to retry with TCP.  The value *GOTSOMEWHERE is set to 1\n   if any progress was made reading a response from the nameserver and\n   is used by the caller to distinguish between ECONNREFUSED and\n   ETIMEDOUT (the latter if *GOTSOMEWHERE is 1).\n\n   If errors are encountered then *TERRNO is set to an appropriate\n   errno value and a zero result is returned for a recoverable error,\n   and a less-than zero result is returned for a non-recoverable error.\n\n   If no errors are encountered then *TERRNO is left unmodified and\n   a the length of the first response in bytes is returned.Clear the AD bit unless the trust-ad option was specified in the\n   resolver configuration.Clear the AD bit unless the trust-ad option was specified in the\n   resolver configuration.Clear the AD bit unless the trust-ad option was specified in the\n   resolver configuration.",
    "__resolv_context_get": "Backing function for the __resolv_context_get family of\n   functions.",
    "__resolv_context_get_preinit": "Backing function for the __resolv_context_get family of\n   functions.",
    "__resolv_context_get_override": "Allocate a new context object and initialize it.  The object is put\n   on the current list.",
    "__resolv_context_put": "Deallocate the context object and all the state within.",
    "_nss_dns_getcanonname_r": "",
    "_nss_dns_gethostbyname3_r": "",
    "_nss_dns_gethostbyname2_r": "Verify that the name looks like a host name.  There is no point in\n   sending a query which will not produce a usable name in the\n   response.",
    "_nss_dns_gethostbyname_r": "Verify that the name looks like a host name.  There is no point in\n   sending a query which will not produce a usable name in the\n   response.",
    "_nss_dns_gethostbyname4_r": "Verify that the name looks like a host name.  There is no point in\n   sending a query which will not produce a usable name in the\n   response.Variant of gaih_getanswer without a second (AAAA) response.",
    "_nss_dns_gethostbyaddr2_r": "",
    "_nss_dns_gethostbyaddr_r": "",
    "_nss_dns_getnetbyname_r": "",
    "_nss_dns_getnetbyaddr_r": "",
    "__getrlimit": "Put the soft and hard limits for RESOURCE in *RLIMITS.\n   Returns 0 if successful, -1 if not (and sets errno).",
    "nice": "Increment the scheduling priority of the calling process by INCR.\n   The superuser may use a negative INCR to decrement the priority.",
    "setrlimit64": "Set the soft and hard limits for RESOURCE to *RLIMITS.\n   Only the super-user can increase hard limits.\n   Return 0 if successful, -1 if not (and sets errno).",
    "vlimit": "Set the soft limit for RESOURCE to be VALUE.\n   Returns 0 for success, -1 for failure.",
    "mq_close": "Removes the association between message queue descriptor MQDES and its\n   message queue.",
    "mq_getattr": "Query status and attributes of message queue MQDES.",
    "mq_notify": "Register notification upon message arrival to an empty message queue\n   MQDES.",
    "__mq_open_2": "Establish connection between a process and a message queue NAME and\n   return message queue descriptor or (mqd_t) -1 on error.  OFLAG determines\n   the type of access used.  If O_CREAT is on OFLAG, the third argument is\n   taken as a `mode_t', the mode of the created message queue, and the fourth\n   argument is taken as `struct mq_attr *', pointer to message queue\n   attributes.  If the fourth argument is NULL, default attributes are\n   used.",
    "mq_receive": "Receive the oldest from highest priority messages in message queue\n   MQDES.",
    "mq_send": "Add message pointed by MSG_PTR to message queue MQDES.",
    "mq_setattr": "Set attributes associated with message queue MQDES and if OMQSTAT is\n   not NULL also query its old attributes.",
    "mq_unlink": "Remove message queue named NAME.",
    "timer_create": "Create new per-process timer using CLOCK.",
    "timer_delete": "Delete timer TIMERID.",
    "timer_getoverrun": "Get expiration overrun for timer TIMERID.",
    "timer_gettime": "Get current value of timer TIMERID and store it in VALUE.",
    "timer_settime": "Set timer TIMERID to VALUE, returning old value in OVLAUE.",
    "_setjmp": "This implementation in C will not usually work, because the call\n   really needs to be a tail-call so __sigsetjmp saves the state of\n   the caller, not the state of this `setjmp' frame which then\n   immediate unwinds.",
    "setjmp": "This implementation in C will not usually work, because the call\n   really needs to be a tail-call so __sigsetjmp saves the state of\n   the caller, not the state of this `setjmp' frame which then\n   immediate unwinds.",
    "__libc_current_sigrtmin": "Return number of available real-time signal with highest priority.",
    "__libc_current_sigrtmax": "",
    "__libc_allocate_rtsig": "",
    "killpg": "Send SIG to all processes in process group PGRP.\n   If PGRP is zero, send SIG to all processes in\n   the current process's process group.",
    "__libc_sigaction": "If ACT is not NULL, change the action for SIG to *ACT.\n   If OACT is not NULL, put the old action for SIG in *OACT.",
    "raise": "Raise the signal SIG.",
    "__sigaction": "If ACT is not NULL, change the action for SIG to *ACT.\n   If OACT is not NULL, put the old action for SIG in *OACT.",
    "sigaddset": "Add SIGNO to SET.",
    "sigaltstack": "Run signals handlers on the stack specified by SS (if not NULL).\n   If OSS is not NULL, it is filled in with the old signal stack status.",
    "sigandset": "Combine sets LEFT and RIGHT by logical AND and place result in DEST.",
    "sigdelset": "Add SIGNO to SET.",
    "sigemptyset": "Clear all signals from SET.",
    "sigfillset": "Set all signals in SET.",
    "siggetmask": "",
    "sighold": "",
    "sigignore": "",
    "siginterrupt": "If INTERRUPT is nonzero, make signal SIG interrupt system calls\n   (causing them to fail with EINTR); if INTERRUPT is zero, make system\n   calls be restarted after signal SIG.",
    "sigisemptyset": "Test whether SET is empty.",
    "sigismember": "Return 1 if SIGNO is in SET, 0 if not.",
    "signal": "Set the handler for the signal SIG to HANDLER,\n   returning the old handler, or SIG_ERR on error.",
    "sigorset": "Combine sets LEFT and RIGHT by logical OR and place result in DEST.",
    "__sigpause": "",
    "sigpending": "Change the set of blocked signals to SET,\n   wait until a signal arrives, and restore the set of blocked signals.",
    "sigrelse": "",
    "sigset": "Set the disposition for SIG.",
    "sigstack": "",
    "__sigsuspend": "Change the set of blocked signals to SET,\n   wait until a signal arrives, and restore the set of blocked signals.",
    "__sigtimedwait": "",
    "__sysv_signal": "Set the handler for the signal SIG to HANDLER,\n   returning the old handler, or SIG_ERR on error.",
    "accept": "Await a connection on socket FD.\n   When a connection arrives, open a new socket to communicate with it,\n   set *ADDRARG (which is *ADDR_LEN bytes long) to the address of the connecting\n   peer and *ADDR_LEN to the address's actual length, and return the\n   new socket's descriptor, or -1 for errors.",
    "__connect": "Open a connection on socket FD to peer at ADDR (which LEN bytes long).\n   For connectionless socket types, just set the default address to send to\n   and the only address from which to accept transmissions.\n   Return 0 on success, -1 for errors.",
    "getpeername": "Put the address of the peer connected to socket FD into *ADDR\n   (which is *LEN bytes long), and its actual length into *LEN.",
    "getsockopt": "XXX should be __getsockopt ?",
    "isfdtype": "",
    "__recv": "Read N bytes into BUF from socket FD.\n   Returns the number read or -1 for errors.",
    "recvmmsg": "Receive up to VLEN messages as described by VMESSAGES from socket FD.\n   Returns the number of bytes read or -1 for errors.",
    "__libc_sa_len": "",
    "__send": "Send N bytes of BUF to socket FD.  Returns the number sent or -1.",
    "__sendmmsg": "",
    "shutdown": "XXX should be __shutdown ?",
    "sockatmark": "Determine whether socket is at a out-of-band mark.",
    "__socket": "",
    "socketpair": "Create two new sockets, of type TYPE in domain DOMAIN and using\n   protocol PROTOCOL, which are connected to each other, and put file\n   descriptors for them in FDS[0] and FDS[1].  If PROTOCOL is zero,\n   one will be chosen automatically.  Returns 0 on success, -1 for errors.",
    "ctermid": "Return the name of the controlling terminal.  If S is not NULL, the\n   name is copied into it (it should be at least L_ctermid bytes\n   long), otherwise we return a pointer to a non-const but read-only\n   string literal, that POSIX states the caller must not modify.",
    "cuserid": "Return the username of the caller.\n   If S is not NULL, it points to a buffer of at least L_cuserid bytes\n   into which the name is copied; otherwise, a static buffer is used.",
    "getw": "Read a word (int) from STREAM.",
    "__isoc23_fscanf": "",
    "__isoc23_scanf": "",
    "__isoc23_sscanf": "",
    "__isoc23_vfscanf": "",
    "__isoc23_vscanf": "",
    "__isoc23_vsscanf": "",
    "__isoc99_fscanf": "",
    "__isoc99_scanf": "",
    "__isoc99_sscanf": "",
    "__isoc99_vfscanf": "",
    "__isoc99_vscanf": "",
    "__isoc99_vsscanf": "",
    "perror": "Print a line on stderr consisting of the text in S, a colon, a space,\n   a message describing the meaning of the contents of `errno' and a newline.\n   If S is NULL or \"\", the colon and space are omitted.",
    "parse_printf_format": "",
    "printf_size_info": "This is the function used by `vfprintf' to determine number and\n   type of the arguments.",
    "psiginfo": "Print out on stderr a line consisting of the test in S, a colon, a space,\n   a message describing the meaning of the signal number PINFO and a newline.\n   If S is NULL or \"\", the colon and space are omitted.",
    "psignal": "Print out on stderr a line consisting of the test in S, a colon, a space,\n   a message describing the meaning of the signal number SIG and a newline.\n   If S is NULL or \"\", the colon and space are omitted.",
    "putw": "Write the word (int) W to STREAM.",
    "remove": "",
    "rename": "Rename the file OLD to NEW.",
    "tempnam": "Generate a unique temporary filename using up to five characters of\n   PFX if it is not NULL.  The directory to put this file in is\n   searched for as follows: First the environment variable \"TMPDIR\" is\n   checked.  If it contains the name of a directory, that directory is\n   used.  If not and if DIR is not NULL, that value is checked.  If\n   that fails, P_tmpdir is tried and finally \"/tmp\".  The storage for\n   the filename is allocated by `malloc'.",
    "tmpfile": "This returns a new stream opened on a temporary file (generated\n   by tmpnam).  The file is opened with mode \"w+b\" (binary read/write).\n   If we couldn't generate a unique filename or the file couldn't\n   be opened, NULL is returned.",
    "tmpnam": "Generate a unique filename in P_tmpdir.\n\n   This function is *not* thread safe!",
    "tmpnam_r": "Generate a unique filename in P_tmpdir.  If S is NULL return NULL.\n   This makes this function thread safe.",
    "vfprintf": "",
    "a64l": "",
    "abort": "",
    "abs": "Return the absolute value of I.",
    "atof": "Convert a string to a double.",
    "atoi": "Convert a string to an int.",
    "atol": "Convert a string to a long int.",
    "atoll": "Convert a string to a long long int.",
    "__cxa_at_quick_exit": "Register a function to be called by quick_exit.",
    "__cxa_atexit": "Register a function to be called by exit or when a shared library\n   is unloaded.  This function is only called from code generated by\n   the C++ compiler.",
    "__cxa_finalize": "If D is non-NULL, call all functions registered with `__cxa_atexit'\n   with the same dso handle.  Otherwise, if D is NULL, call all of the\n   registered handlers.",
    "__cxa_thread_atexit_impl": "Register a destructor for TLS variables declared with the 'thread_local'\n   keyword.  This function is only called from code generated by the C++\n   compiler.  FUNC is the destructor function and OBJ is the object to be\n   passed to the destructor.  DSO_SYMBOL is the __dso_handle symbol that each\n   DSO has at a unique address in its map, added from crtbegin.o during the\n   linking phase.",
    "__call_tls_dtors": "Call the destructors.  This is called either when a thread returns from the\n   initial function or when the process exits via the exit function.",
    "div": "Return the `div_t' representation of NUMER over DENOM.",
    "drand48": "",
    "drand48_r": "",
    "erand48": "",
    "exit": "Call all functions registered with `atexit' and `on_exit',\n   in the reverse of the order in which they were registered\n   perform stdio cleanup, and terminate program execution with STATUS.",
    "fmtmsg": "",
    "getcontext": "",
    "getentropy": "Write LENGTH bytes of randomness starting at BUFFER.  Return 0 on\n   success and -1 on failure.",
    "getenv": "",
    "getsubopt": "Parse comma separated suboption from *OPTIONP and match against\n   strings in TOKENS.  If found return index and set *VALUEP to\n   optional value introduced by an equal sign.  If the suboption is\n   not part of TOKENS return in *VALUEP beginning of unknown\n   suboption.  On exit *OPTIONP is set to the beginning of the next\n   token or at the terminating NUL character.",
    "jrand48": "",
    "l64a": "",
    "labs": "Return the absolute value of I.",
    "lcong48": "",
    "ldiv": "Return the `ldiv_t' representation of NUMER over DENOM.",
    "llabs": "Return the absolute value of I.",
    "lldiv": "Return the `lldiv_t' representation of NUMER over DENOM.",
    "lrand48": "",
    "lrand48_r": "",
    "makecontext": "",
    "mblen": "Return the length of the multibyte character (if there is one)\n   at S which is no longer than N characters.\n   The ISO C standard says that the `mblen' function must not change\n   the state of the `mbtowc' function.",
    "mbstowcs": "Convert the string of multibyte characters in S to `wchar_t's in\n   PWCS, writing no more than N.  Return the number written,\n   or (size_t) -1 if an invalid multibyte character is encountered.",
    "mbtowc": "Convert the multibyte character at S, which is no longer\n   than N characters, to its `wchar_t' representation, placing\n   this n *PWC and returning its length.\n\n   Attention: this function should NEVER be intentionally used.\n   The interface is completely stupid.  The state is shared between\n   all conversion functions.  You should use instead the restartable\n   version `mbrtowc'.",
    "mrand48": "",
    "mrand48_r": "",
    "nrand48": "",
    "putenv": "Put STRING, which is of the form \"NAME=VALUE\", in the environment.",
    "qsort": "Order size using quicksort.  This implementation incorporates\n   four optimizations discussed in Sedgewick:\n\n   1. Non-recursive, using an explicit stack of pointer that store the\n      next array partition to sort.  To save time, this maximum amount\n      of space required to store an array of SIZE_MAX is allocated on the\n      stack.  Assuming a 32-bit (64 bit) integer for size_t, this needs\n      only 32 * sizeof(stack_node) == 256 bytes (for 64 bit: 1024 bytes).\n      Pretty cheap, actually.\n\n   2. Chose the pivot element using a median-of-three decision tree.\n      This reduces the probability of selecting a bad pivot value and\n      eliminates certain extraneous comparisons.\n\n   3. Only quicksorts TOTAL_ELEMS / MAX_THRESH partitions, leaving\n      insertion sort to order the MAX_THRESH items within each partition.\n      This is a big win, since insertion sort is faster for small, mostly\n      sorted array segments.\n\n   4. The larger of the two sub-partitions is always pushed onto the\n      stack first, with the algorithm then concentrating on the\n      smaller partition.  This *guarantees* no more than log (total_elems)\n      stack size is needed (actually O(1) in this case)!",
    "rand": "Return a random integer between 0 and RAND_MAX.",
    "rand_r": "This algorithm is mentioned in the ISO C standard, here extended\n   for 32 bits.",
    "rpmatch": "Match against one of the response patterns, compiling the pattern\n   first if necessary.Match against one of the response patterns, compiling the pattern\n   first if necessary.",
    "__libc_secure_getenv": "Some programs and especially the libc itself have to be careful\n   what values to accept from the environment.  This special version\n   checks for SUID or SGID first before doing any work.",
    "seed48": "",
    "setcontext": "",
    "setenv": "This function is used by `setenv' and `putenv'.  The difference between\n   the two functions is that for the former must create a new string which\n   is then placed in the environment, while the argument of `putenv'\n   must be used directly.  This is all complicated by the fact that we try\n   to reuse values once generated for a `setenv' call since we can never\n   free the strings.",
    "clearenv": "The `clearenv' was planned to be added to POSIX.1 but probably\n   never made it.  Nevertheless the POSIX.9 standard (POSIX bindings\n   for Fortran 77) requires this function.",
    "srand48": "",
    "__isoc23_strtol": "",
    "__strtol_l": "Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.",
    "__isoc23_strtol_l": "Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.Convert NPTR to an `unsigned long int' or `long int' in base BASE.\n   If BASE is 0 the base is determined by the presence of a leading\n   zero, indicating octal or a leading \"0x\" or \"0X\", indicating hexadecimal.\n   If BASE is < 2 or > 36, it is reset to 10.\n   If BIN_CST is true, binary constants starting \"0b\" or \"0B\" are accepted\n   in base 0 and 2.\n   If ENDPTR is not NULL, a pointer to the character after the last\n   one converted is stored in *ENDPTR.",
    "swapcontext": "",
    "__libc_system": "Execute LINE as a shell command, returning its status.Execute LINE as a shell command, returning its status.",
    "wcstombs": "Convert the `wchar_t' string in PWCS to a multibyte character string\n   in S, writing no more than N characters.  Return the number of bytes\n   written, or (size_t) -1 if an invalid `wchar_t' was found.",
    "wctomb": "Convert WCHAR into its multibyte character representation,\n   putting this in S and returning its length.\n\n   Attention: this function should NEVER be intentionally used.\n   The interface is completely stupid.  The state is shared between\n   all conversion functions.  You should use instead the restartable\n   version `wcrtomb'.",
    "__xpg_basename": "",
    "__argz_count": "Returns the number of strings in ARGZ.",
    "argz_delete": "Delete ENTRY from ARGZ & ARGZ_LEN, if any.",
    "__argz_next": "",
    "__argz_stringify": "Make '\\0' separated arg vector ARGZ printable by converting all the '\\0's\n   except the last into the character SEP.",
    "bcopy": "",
    "__bzero": "Set N bytes of S to 0.",
    "envz_entry": "Returns a pointer to the entry in ENVZ for NAME, or 0 if there is none.\n   If NAME contains the separator character, only the portion before it is\n   used in the comparison.",
    "envz_get": "Returns a pointer to the entry in ENVZ for NAME, or 0 if there is none.\n   If NAME contains the separator character, only the portion before it is\n   used in the comparison.",
    "envz_remove": "Remove the entry for NAME from ENVZ & ENVZ_LEN, if any.",
    "envz_add": "Remove the entry for NAME from ENVZ & ENVZ_LEN, if any.",
    "envz_merge": "Adds each entry in ENVZ2 to ENVZ & ENVZ_LEN, as if with envz_add().  If\n   OVERRIDE is true, then values in ENVZ2 will supersede those with the same\n   name in ENV, otherwise not.",
    "envz_strip": "Remove null entries.",
    "explicit_bzero": "Set LEN bytes of S to 0.  The compiler will not delete a call to\n   this function, even if S is dead after the call.",
    "__ffs": "",
    "ffsll": "",
    "memfrob": "",
    "sigabbrev_np": "",
    "__strcasecmp": "Compare S1 and S2, ignoring case, returning less than, equal to or\n   greater than zero if S1 is lexicographically less than,\n   equal to or greater than S2.",
    "strchr": "Find the first occurrence of C in S.",
    "strcmp": "Compare S1 and S2, returning less than, equal to or\n   greater than zero if S1 is lexicographically less than,\n   equal to or greater than S2.",
    "__strdup": "Duplicate S, returning an identical malloc'd string.",
    "strerror": "",
    "strerrorname_np": "",
    "strfry": "",
    "__strndup": "",
    "strsignal": "Return a string describing the meaning of the signal number SIGNUM.",
    "strtok": "Parse S into tokens separated by characters in DELIM.\n   If S is NULL, the last string strtok() was called with is\n   used.  For example:\n\tchar s[] = \"-abc-=-def\";\n\tx = strtok(s, \"-\");\t\t// x = \"abc\"\n\tx = strtok(NULL, \"-=\");\t\t// x = \"def\"\n\tx = strtok(NULL, \"=\");\t\t// x = NULL\n\t\t// s = \"abc\\0=-def\\0\"",
    "__strtok_r": "Parse S into tokens separated by characters in DELIM.\n   If S is NULL, the saved pointer in SAVE_PTR is used as\n   the next starting point.  For example:\n\tchar s[] = \"-abc-=-def\";\n\tchar *sp;\n\tx = strtok_r(s, \"-\", &sp);\t// x = \"abc\", sp = \"=-def\"\n\tx = strtok_r(NULL, \"-=\", &sp);\t// x = \"def\", sp = NULL\n\tx = strtok_r(NULL, \"=\", &sp);\t// x = NULL\n\t\t// s = \"abc\\0-def\\0\"",
    "__strverscmp": "Compare S1 and S2 as strings holding indices/version numbers,\n   returning less than, equal to or greater than zero if S1 is less than,\n   equal to or greater than S2 (for more info, see the texinfo doc).",
    "swab": "",
    "__xpg_strerror_r": "Fill buf with a string describing the errno code in ERRNUM.",
    "authdes_pk_create": "4. Refresh",
    "authnone_create": "",
    "authunix_create": "* Create a unix style authenticator.\n * Returns an auth handle with the given stuff in it.",
    "authunix_create_default": "* Returns an auth handle with parameters determined by doing lots of\n * syscalls.",
    "xdr_authdes_cred": "",
    "xdr_authdes_verf": "",
    "xdr_authunix_parms": "* XDR for unix authentication parameters.\n * Unfortunately, none of these can be declared const.",
    "clnt_create": "* Generic client creation: takes (hostname, program-number, protocol) and\n * returns client handle. Default options are set, which the user can\n * change using the rpc equivalent of ioctl()'s.",
    "clnt_sperror": "* Print reply error info",
    "clnt_perror": "Print reply error info",
    "clnt_sperrno": "",
    "clnt_perrno": "",
    "clnt_spcreateerror": "",
    "clnt_pcreateerror": "",
    "clntraw_create": "* Create a client handle for memory based rpc.",
    "callrpc": "",
    "clnttcp_create": "* Create a client handle for a tcp/ip connection.\n * If *sockp<0, *sockp is set to a newly created TCP socket and it is\n * connected to raddr.  If *sockp non-negative then\n * raddr is ignored.  The rpc/tcp package does buffering\n * similar to stdio, so the client must pick send and receive buffer sizes,];\n * 0 => use the default.\n * If raddr->sin_port is 0, then a binder on the remote machine is\n * consulted for the right port number.\n * NB: *sockp is copied into a private area.\n * NB: It is the clients responsibility to close *sockp.\n * NB: The rpch->cl_auth is set null authentication.  Caller may wish to set this\n * something more useful.",
    "__libc_clntudp_bufcreate": "* Create a UDP based client handle.\n * If *sockp<0, *sockp is set to a newly created UPD socket.\n * If raddr->sin_port is 0 a binder on the remote machine\n * is consulted for the correct port number.\n * NB: It is the clients responsibility to close *sockp.\n * NB: The rpch->cl_auth is initialized to null authentication.\n *     Caller may wish to set this something more useful.\n *\n * wait is the amount of time used between retransmitting a call if\n * no response has been heard; retransmission occurs until the actual\n * rpc call times out.\n *\n * sendsz and recvsz are the maximum allowable packet sizes that can be\n * sent and received.",
    "clntudp_bufcreate": "Create a UDP based client handle.\n * If *sockp<0, *sockp is set to a newly created UPD socket.\n * If raddr->sin_port is 0 a binder on the remote machine\n * is consulted for the correct port number.\n * NB: It is the clients responsibility to close *sockp.\n * NB: The rpch->cl_auth is initialized to null authentication.\n *     Caller may wish to set this something more useful.\n *\n * wait is the amount of time used between retransmitting a call if\n * no response has been heard; retransmission occurs until the actual\n * rpc call times out.\n *\n * sendsz and recvsz are the maximum allowable packet sizes that can be\n * sent and received.",
    "clntudp_create": "Create a UDP based client handle.\n * If *sockp<0, *sockp is set to a newly created UPD socket.\n * If raddr->sin_port is 0 a binder on the remote machine\n * is consulted for the correct port number.\n * NB: It is the clients responsibility to close *sockp.\n * NB: The rpch->cl_auth is initialized to null authentication.\n *     Caller may wish to set this something more useful.\n *\n * wait is the amount of time used between retransmitting a call if\n * no response has been heard; retransmission occurs until the actual\n * rpc call times out.\n *\n * sendsz and recvsz are the maximum allowable packet sizes that can be\n * sent and received.",
    "clntunix_create": "* Create a client handle for a tcp/ip connection.\n * If *sockp<0, *sockp is set to a newly created TCP socket and it is\n * connected to raddr.  If *sockp non-negative then\n * raddr is ignored.  The rpc/tcp package does buffering\n * similar to stdio, so the client must pick send and receive buffer sizes,];\n * 0 => use the default.\n * If raddr->sin_port is 0, then a binder on the remote machine is\n * consulted for the right port number.\n * NB: *sockp is copied into a private area.\n * NB: It is the clients responsibility to close *sockp.\n * NB: The rpch->cl_auth is set null authentication.  Caller may wish to set this\n * something more useful.",
    "cbc_crypt": "* CBC mode encryption",
    "ecb_crypt": "* ECB mode encryption",
    "des_setparity": "* Add odd parity to low bit of 8 byte key",
    "get_myaddress": "* don't use gethostbyname, which would invoke yellow pages\n *\n * Avoid loopback interfaces.  We return information from a loopback\n * interface only if there are no other possible interfaces.",
    "getrpcport": "",
    "key_setsecret": "returns 0 on failure, 1 on success",
    "key_secretkey_is_set": "key_secretkey_is_set() returns 1 if the keyserver has a secret key\n * stored for the caller's effective uid; it returns 0 otherwise\n *\n * N.B.:  The KEY_NET_GET key call is undocumented.  Applications shouldn't\n * be using it, because it allows them to get the user's secret key.",
    "key_encryptsession": "returns 0 on failure, 1 on success",
    "key_decryptsession": "returns 0 on failure, 1 on success",
    "key_encryptsession_pk": "returns 0 on failure, 1 on success",
    "key_decryptsession_pk": "returns 0 on failure, 1 on success",
    "key_gendes": "",
    "key_setnet": "returns 0 on failure, 1 on success",
    "key_get_conv": "returns 0 on failure, 1 on success",
    "xdr_keystatus": "",
    "xdr_keybuf": "",
    "xdr_netnamestr": "",
    "xdr_cryptkeyarg": "",
    "xdr_cryptkeyarg2": "",
    "xdr_cryptkeyres": "",
    "xdr_unixcred": "",
    "xdr_getcredres": "",
    "xdr_key_netstarg": "",
    "xdr_key_netstres": "",
    "user2netname": "",
    "host2netname": "",
    "getnetname": "",
    "netname2user": "",
    "netname2host": "",
    "pmap_getmaps": "* Get a copy of the current port maps.\n * Calls the pmap service remotely to do get the maps.",
    "__libc_rpc_getport": "* Find the mapped port for program,version.\n * Internal version with additional parameters.\n * Calls the pmap service remotely to do the lookup.\n * Returns 0 if no map exists.",
    "pmap_getport": "Find the mapped port for program,version.\n * Internal version with additional parameters.\n * Calls the pmap service remotely to do the lookup.\n * Returns 0 if no map exists.",
    "pmap_set": "* Set a mapping between program,version and port.\n * Calls the pmap service remotely to do the mapping.",
    "pmap_unset": "* Remove the mapping between program,version and port.\n * Calls the pmap service remotely to do the un-mapping.",
    "xdr_pmap": "",
    "xdr_pmaplist": "* What is going on with linked lists? (!)\n * First recall the link list declaration from pmap_prot.h:\n *\n * struct pmaplist {\n *      struct pmap pml_map;\n *      struct pmaplist *pml_map;\n * };\n *\n * Compare that declaration with a corresponding xdr declaration that\n * is (a) pointer-less, and (b) recursive:\n *\n * typedef union switch (bool_t) {\n *\n *      case TRUE: struct {\n *              struct pmap;\n *              pmaplist_t foo;\n *      };\n *\n *      case FALSE: struct {};\n * } pmaplist_t;\n *\n * Notice that the xdr declaration has no nxt pointer while\n * the C declaration has no bool_t variable.  The bool_t can be\n * interpreted as ``more data follows me''; if FALSE then nothing\n * follows this bool_t; if TRUE then the bool_t is followed by\n * an actual struct pmap, and then (recursively) by the\n * xdr union, pamplist_t.\n *\n * This could be implemented via the xdr_union primitive, though this\n * would cause a one recursive call per element in the list.  Rather than do\n * that we can ``unwind'' the recursion\n * into a while loop and do the union arms in-place.\n *\n * The head of the list is what the C programmer wishes to past around\n * the net, yet is the data that the pointer points to which is interesting;\n * this sounds like a job for xdr_reference!",
    "pmap_rmtcall": "* pmapper remote-call-service interface.\n * This routine is used to call the pmapper remote call service\n * which will look up a service program in the port maps, and then\n * remotely call that routine with the given parameters.  This allows\n * programs to do a lookup and call in one step.",
    "xdr_rmtcall_args": "* XDR remote call arguments\n * written for XDR_ENCODE direction only",
    "xdr_rmtcallres": "* XDR remote call results\n * written for XDR_DECODE direction only",
    "clnt_broadcast": "The following is kludged-up support for simple rpc broadcasts.\n * Someday a large, complicated system will replace these trivial\n * routines which only support udp/ip .* XDR remote call arguments\n * written for XDR_ENCODE direction only",
    "getpublickey": "",
    "getsecretkey": "",
    "xdr_callmsg": "* XDR a call message",
    "_rpc_dtablesize": "* Cache the result of getdtablesize(), so we don't have to do an\n * expensive system call every time.",
    "xdr_opaque_auth": "* XDR an opaque authentication struct\n * (see auth.h)",
    "xdr_des_block": "* XDR a DES block",
    "xdr_accepted_reply": "* * * * * * * * * * * * * XDR RPC MESSAGE * * * * * * * * * * * * * * *",
    "xdr_rejected_reply": "* XDR the MSG_DENIED part of a reply message union",
    "xdr_replymsg": "* XDR a reply message",
    "xdr_callhdr": "* Serializes the \"static part\" of a call message header.\n * The fields include: rm_xid, rm_direction, rpcvers, prog, and vers.\n * The rm_xid is not really static, but the user can easily munge on the fly.",
    "_seterr_reply": "* given a reply message, fills in the error",
    "__rpc_thread_svc_fdset": "",
    "__rpc_thread_createerr": "",
    "__rpc_thread_svc_pollfd": "",
    "__rpc_thread_svc_max_pollfd": "",
    "rtime": "",
    "xprt_register": "Activate a transport handle.",
    "xprt_unregister": "De-activate a transport handle.",
    "svc_register": "Add a service program to the callout list.\n   The dispatch routine will be called when a rpc request for this\n   program number comes in.",
    "svc_unregister": "",
    "svc_sendreply": "******************* REPLY GENERATION ROUTINES  ************",
    "svcerr_noproc": "",
    "svcerr_decode": "",
    "svcerr_systemerr": "",
    "svcerr_auth": "",
    "svcerr_weakauth": "Auth too weak error reply",
    "svcerr_noprog": "Program unavailable error reply",
    "svcerr_progvers": "Program version mismatch error reply",
    "svc_getreq": "******************* SERVER INPUT STUFF *******************",
    "svc_getreqset": "",
    "svc_getreq_poll": "De-activate a transport handle.",
    "svc_getreq_common": "Program version mismatch error replyProgram unavailable error reply",
    "_authenticate": "* The call rpc message, msg has been obtained from the wire.  The msg contains\n * the raw form of credentials and verifiers.  authenticate returns AUTH_OK\n * if the msg is successfully authenticated.  If AUTH_OK then the routine also\n * does the following things:\n * set rqst->rq_xprt->verf to the appropriate response verifier;\n * sets rqst->rq_client_cred to the \"cooked\" form of the credentials.\n *\n * NB: rqst->rq_cxprt->verf must be pre-allocated;\n * its length is set appropriately.\n *\n * The caller still owns and is responsible for msg->u.cmb.cred and\n * msg->u.cmb.verf.  The authentication system retains ownership of\n * rqst->rq_client_cred, the cooked credentials.\n *\n * There is an assumption that any flavour less than AUTH_NULL is\n * invalid.",
    "svcraw_create": "",
    "svc_exit": "This function can be used as a signal handler to terminate the\n   server loop.",
    "svc_run": "",
    "svctcp_create": "* Usage:\n *      xprt = svctcp_create(sock, send_buf_size, recv_buf_size);\n *\n * Creates, registers, and returns a (rpc) tcp based transporter.\n * Once *xprt is initialized, it is registered as a transporter\n * see (svc.h, xprt_register).  This routine returns\n * a NULL if a problem occurred.\n *\n * If sock<0 then a socket is created, else sock is used.\n * If the socket, sock is not bound to a port then svctcp_create\n * binds it to an arbitrary port.  The routine then starts a tcp\n * listener on the socket's associated port.  In any (successful) case,\n * xprt->xp_sock is the registered socket number and xprt->xp_port is the\n * associated port number.\n *\n * Since tcp streams do buffered io similar to stdio, the caller can specify\n * how big the send and receive buffers are via the second and third parms;\n * 0 => use the system default.",
    "svcfd_create": "",
    "svcudp_bufcreate": "* Usage:\n *      xprt = svcudp_create(sock);\n *\n * If sock<0 then a socket is created, else sock is used.\n * If the socket, sock is not bound to a port then svcudp_create\n * binds it to an arbitrary port.  In any (successful) case,\n * xprt->xp_sock is the registered socket number and xprt->xp_port is the\n * associated port number.\n * Once *xprt is initialized, it is registered as a transporter;\n * see (svc.h, xprt_register).\n * The routines returns NULL if a problem occurred.",
    "svcudp_create": "Usage:\n *      xprt = svcudp_create(sock);\n *\n * If sock<0 then a socket is created, else sock is used.\n * If the socket, sock is not bound to a port then svcudp_create\n * binds it to an arbitrary port.  In any (successful) case,\n * xprt->xp_sock is the registered socket number and xprt->xp_port is the\n * associated port number.\n * Once *xprt is initialized, it is registered as a transporter;\n * see (svc.h, xprt_register).\n * The routines returns NULL if a problem occurred.",
    "svcudp_enablecache": "* Enable use of the cache.\n * Note: there is no disable.",
    "svcunix_create": "* Usage:\n *      xprt = svcunix_create(sock, send_buf_size, recv_buf_size);\n *\n * Creates, registers, and returns a (rpc) unix based transporter.\n * Once *xprt is initialized, it is registered as a transporter\n * see (svc.h, xprt_register).  This routine returns\n * a NULL if a problem occurred.\n *\n * If sock<0 then a socket is created, else sock is used.\n * If the socket, sock is not bound to a port then svcunix_create\n * binds it to an arbitrary port.  The routine then starts a unix\n * listener on the socket's associated port.  In any (successful) case,\n * xprt->xp_sock is the registered socket number and xprt->xp_port is the\n * associated port number.\n *\n * Since unix streams do buffered io similar to stdio, the caller can specify\n * how big the send and receive buffers are via the second and third parms;\n * 0 => use the system default.",
    "svcunixfd_create": "* Like svunix_create(), except the routine takes any *open* UNIX file\n * descriptor as its first input.",
    "authdes_getucred": "* Map a des credential into a unix cred.\n * We cache the credential here so the application does\n * not have to make an rpc call every time to interpret\n * the credential.",
    "xencrypt": "* Encrypt a secret key given passwd\n * The secret key is passed and returned in hex notation.\n * Its length must be a multiple of 16 hex digits (64 bits).",
    "xdecrypt": "* Decrypt secret key using passwd\n * The secret key is passed and returned in hex notation.\n * Once again, the length is a multiple of 16 hex digits",
    "xdr_free": "* Free a data structure using XDR\n * Not a filter, but a convenient utility nonetheless",
    "xdr_void": "",
    "xdr_int": "",
    "xdr_u_int": "",
    "xdr_long": "",
    "xdr_u_long": "",
    "xdr_hyper": "",
    "xdr_u_hyper": "",
    "xdr_longlong_t": "",
    "xdr_u_longlong_t": "",
    "xdr_short": "",
    "xdr_u_short": "",
    "xdr_char": "",
    "xdr_u_char": "",
    "xdr_bool": "",
    "xdr_enum": "",
    "xdr_opaque": "",
    "xdr_bytes": "",
    "xdr_netobj": "",
    "xdr_union": "* XDR a discriminated union\n * Support routine for discriminated unions.\n * You create an array of xdrdiscrim structures, terminated with\n * an entry with a null procedure pointer.  The routine gets\n * the discriminant value and then searches the array of xdrdiscrims\n * looking for that value.  It calls the procedure given in the xdrdiscrim\n * to handle the discriminant.  If there is no specific routine a default\n * routine may be called.\n * If there is no specific or default routine an error is returned.",
    "xdr_string": "* Non-portable xdr primitives.\n * Care should be taken when moving these routines to new architectures.",
    "xdr_wrapstring": "Non-portable xdr primitives.\n * Care should be taken when moving these routines to new architectures.",
    "xdr_array": "* XDR an array of arbitrary elements\n * *addrp is a pointer to the array, *sizep is the number of elements.\n * If addrp is NULL (*sizep * elsize) bytes are allocated.\n * elsize is the size (in bytes) of each element, and elproc is the\n * xdr procedure to call to handle each element of the array.",
    "xdr_vector": "* xdr_vector():\n *\n * XDR a fixed length array. Unlike variable-length arrays,\n * the storage of fixed length arrays is static and unfreeable.\n * > basep: base of the array\n * > size: size of the array\n * > elemsize: size of each element\n * > xdr_elem: routine to XDR each element",
    "xdr_float": "vax",
    "xdr_double": "vax",
    "xdr_int64_t": "XDR 64bit integers",
    "xdr_quad_t": "XDR 64bit integers",
    "xdr_uint64_t": "XDR 64bit unsigned integers",
    "xdr_u_quad_t": "XDR 64bit unsigned integers",
    "xdr_int32_t": "XDR 32bit integers",
    "xdr_uint32_t": "XDR 32bit unsigned integers",
    "xdr_int16_t": "",
    "xdr_uint16_t": "XDR 16bit unsigned integers",
    "xdr_int8_t": "XDR 8bit integers",
    "xdr_uint8_t": "XDR 8bit unsigned integers",
    "xdrmem_create": "* The procedure xdrmem_create initializes a stream descriptor for a\n * memory buffer.",
    "xdrrec_create": "* Create an xdr handle for xdrrec\n * xdrrec_create fills in xdrs.  Sendsize and recvsize are\n * send and recv buffer sizes (0 => use default).\n * tcp_handle is an opaque handle that is passed as the first parameter to\n * the procedures readit and writeit.  Readit and writeit are read and\n * write respectively.   They are like the system\n * calls expect that they take an opaque handle rather than an fd.",
    "xdrrec_skiprecord": "* Before reading (deserializing from the stream, one should always call\n * this procedure to guarantee proper record alignment.",
    "xdrrec_eof": "* Lookahead function.\n * Returns TRUE iff there is no more input in the buffer\n * after consuming the rest of the current record.",
    "xdrrec_endofrecord": "* The client must tell the package when an end-of-record has occurred.\n * The second parameter tells whether the record should be flushed to the\n * (output) tcp stream.  (This lets the package support batched or\n * pipelined procedure calls.)  TRUE => immediate flush to tcp connection.",
    "xdr_reference": "* XDR an indirect pointer\n * xdr_reference is for recursively translating a structure that is\n * referenced by a pointer inside the structure that is currently being\n * translated.  pp references a pointer to storage. If *pp is null\n * the  necessary storage is allocated.\n * size is the size of the referenced structure.\n * proc is the routine to handle the referenced structure.",
    "xdr_pointer": "* xdr_pointer():\n *\n * XDR a pointer to a possibly recursive data structure. This\n * differs with xdr_reference in that it can serialize/deserialize\n * trees correctly.\n *\n *  What's sent is actually a union:\n *\n *  union object_pointer switch (boolean b) {\n *  case TRUE: object_data data;\n *  case FALSE: void nothing;\n *  }\n *\n * > objpp: Pointer to the pointer to the object.\n * > obj_size: size of the object.\n * > xdr_obj: routine to XDR an object.\n *",
    "xdr_sizeof": "",
    "xdrstdio_create": "* Initialize a stdio xdr stream.\n * Sets the xdr stream handle xdrs for use on the stream file.\n * Operation flag is set to op.",
    "feclearexcept": "",
    "fegetexceptflag": "",
    "fesetexceptflag": "",
    "__libc_ifunc_impl_list": "Fill ARRAY of MAX elements with IFUNC implementations for function\n   NAME supported on target machine and return the number of valid\n   entries.  Each set of implementations for a given function is sorted in\n   descending order by ISA level.",
    "__isnan": "",
    "link": "",
    "__signbit": "",
    "pthread_attr_getguardsize": "",
    "pthread_attr_setguardsize": "",
    "pthread_barrier_destroy": "",
    "pthread_barrier_init": "",
    "pthread_barrier_wait": "",
    "pthread_barrierattr_destroy": "",
    "pthread_barrierattr_getpshared": "",
    "pthread_barrierattr_init": "",
    "pthread_barrierattr_setpshared": "",
    "pthread_condattr_getclock": "",
    "pthread_condattr_getpshared": "",
    "pthread_condattr_setclock": "",
    "pthread_condattr_setpshared": "",
    "pthread_getconcurrency": "",
    "pthread_getcpuclockid": "",
    "__pthread_getspecific": "",
    "__pthread_key_create": "",
    "__pthread_once": "",
    "__pthread_rwlock_rdlock": "Acquire RWLOCK for reading, block if we can't get it.",
    "pthread_rwlock_tryrdlock": "Try to acquire RWLOCK.",
    "pthread_rwlock_trywrlock": "Try to acquire RWLOCK for writing.",
    "__pthread_rwlock_unlock": "Unlock *RWLOCK, rescheduling a waiting writer thread or, if there\n   are no threads waiting for a write lock, rescheduling the reader\n   threads.",
    "__pthread_rwlock_wrlock": "Acquire RWLOCK for writing.",
    "pthread_rwlockattr_destroy": "",
    "pthread_rwlockattr_getpshared": "",
    "pthread_rwlockattr_init": "",
    "pthread_rwlockattr_setpshared": "",
    "pthread_setconcurrency": "",
    "pthread_setschedprio": "",
    "__pthread_setspecific": "",
    "init_module": "Initialize the global lists, and acquire global resources.  Error\n   reporting is done by storing a non-zero value to the global variable\n   timer_init_failed.",
    "strlen": "",
    "__isinfl": "",
    "__finite": "",
    "__fpclassify": "",
    "__isinf": "",
    "__issignaling": "",
    "__fpclassifyf": "",
    "__isinff": "",
    "__isnanf": "",
    "__issignalingf": "",
    "__signbitf": "",
    "__finitel": "",
    "__fpclassifyl": "",
    "__isnanl": "",
    "__issignalingl": "",
    "__signbitl": "",
    "__iscanonicall": "",
    "acosl": "",
    "acoshl": "",
    "asinl": "",
    "asinhl": "",
    "__asprintf": "",
    "__asprintf_chk": "",
    "atanl": "",
    "atan2l": "",
    "atanhl": "",
    "cabsl": "",
    "cacosl": "",
    "cacoshl": "",
    "canonicalizel": "",
    "cargl": "",
    "casinl": "",
    "casinhl": "",
    "catanl": "",
    "catanhl": "",
    "cbrtl": "",
    "ccosl": "",
    "ccoshl": "",
    "ceill": "",
    "cexpl": "",
    "cimagl": "",
    "clogl": "",
    "clog10l": "",
    "conjl": "",
    "copysignl": "",
    "cosl": "",
    "coshl": "",
    "cpowl": "",
    "cprojl": "",
    "creall": "",
    "csinl": "",
    "csinhl": "",
    "csqrtl": "",
    "ctanl": "",
    "ctanhl": "",
    "daddl": "",
    "ddivl": "",
    "dfmal": "",
    "dmull": "",
    "dprintf": "",
    "dsqrtl": "",
    "dsubl": "",
    "erfl": "",
    "erfcl": "",
    "expl": "",
    "exp10l": "",
    "exp2l": "",
    "expm1l": "",
    "fabsl": "",
    "faddl": "",
    "fdiml": "",
    "fdivl": "",
    "ffmal": "",
    "floorl": "",
    "fmal": "",
    "fmaxl": "",
    "fmaximuml": "",
    "fmaximum_magl": "",
    "fmaximum_mag_numl": "",
    "fmaximum_numl": "",
    "fmaxmagl": "",
    "fminl": "",
    "fminimuml": "",
    "fminimum_magl": "",
    "fminimum_mag_numl": "",
    "fminimum_numl": "",
    "fminmagl": "",
    "fmodl": "",
    "fmull": "",
    "fprintf": "",
    "__fprintf_chk": "",
    "frexpl": "",
    "fromfpl": "",
    "fromfpxl": "",
    "fscanf": "",
    "fsqrtl": "",
    "fsubl": "",
    "fwprintf": "",
    "fwscanf": "",
    "gammal": "",
    "getpayloadl": "",
    "hypotl": "",
    "ilogbl": "",
    "_IO_vfscanf": "",
    "__isoc23_fwscanf": "Read formatted input from STREAM according to the format string FORMAT.",
    "__isoc23_swscanf": "Read formatted input from S, according to the format string FORMAT.",
    "__isoc23_vfwscanf": "Read formatted input from STREAM according to the format string FORMAT.",
    "__isoc23_vswscanf": "",
    "__isoc23_vwscanf": "Read formatted input from STDIN according to the format string FORMAT.",
    "__isoc23_wscanf": "Read formatted input from stdin according to the format string FORMAT.",
    "__isoc99_fwscanf": "Read formatted input from STREAM according to the format string FORMAT.",
    "__isoc99_swscanf": "Read formatted input from S, according to the format string FORMAT.",
    "__isoc99_vfwscanf": "Read formatted input from STREAM according to the format string FORMAT.",
    "__isoc99_vswscanf": "",
    "__isoc99_vwscanf": "Read formatted input from STDIN according to the format string FORMAT.",
    "__isoc99_wscanf": "Read formatted input from stdin according to the format string FORMAT.",
    "j0l": "",
    "j1l": "",
    "jnl": "",
    "ldexpl": "",
    "lgammal": "",
    "lgammal_r": "",
    "llogbl": "",
    "llrintl": "",
    "llroundl": "",
    "logl": "",
    "log10l": "",
    "log1pl": "",
    "log2l": "",
    "logbl": "",
    "lrintl": "",
    "lroundl": "",
    "modfl": "",
    "nanl": "",
    "nearbyintl": "",
    "nextafterl": "",
    "nextdownl": "Return the greatest floating-point number less than X.",
    "nexttoward": "",
    "nexttowardf": "",
    "nextupl": "Return the least floating-point number greater than X.",
    "obstack_printf": "",
    "obstack_vprintf": "",
    "powl": "",
    "printf": "",
    "__printf_chk": "",
    "__printf_fp": "",
    "printf_size": "",
    "qecvt": "",
    "qecvt_r": "",
    "qfcvt": "",
    "qfcvt_r": "",
    "qgcvt": "",
    "remainderl": "",
    "remquol": "",
    "rintl": "",
    "roundl": "",
    "roundevenl": "",
    "scalbl": "",
    "scalblnl": "",
    "scalbnl": "",
    "scanf": "",
    "setpayloadl": "",
    "setpayloadsigl": "",
    "significandl": "",
    "sinl": "",
    "sincosl": "",
    "sinhl": "",
    "snprintf": "",
    "__snprintf_chk": "",
    "sprintf": "",
    "__sprintf_chk": "",
    "sqrtl": "",
    "sscanf": "",
    "strfmon": "",
    "__strfmon_l": "",
    "strfroml": "",
    "strtold": "",
    "__strtold_l": "",
    "__strtold_internal": "",
    "swprintf": "",
    "swscanf": "",
    "syslog": "",
    "__syslog_chk": "",
    "tanl": "",
    "tanhl": "",
    "tgammal": "",
    "totalorderl": "",
    "totalordermagl": "",
    "truncl": "",
    "ufromfpl": "",
    "ufromfpxl": "",
    "vasprintf": "",
    "vdprintf": "",
    "__vfprintf_chk": "",
    "__vfscanf": "",
    "vfwprintf": "",
    "vfwscanf": "",
    "vprintf": "",
    "__vprintf_chk": "",
    "vscanf": "",
    "vsnprintf": "",
    "__vsnprintf_chk": "",
    "_IO_vsprintf": "",
    "__vsprintf_chk": "",
    "__vsscanf": "",
    "vswprintf": "",
    "vswscanf": "",
    "vsyslog": "",
    "vwprintf": "",
    "vwscanf": "",
    "wcstold": "",
    "__wcstold_l": "",
    "__wcstold_internal": "",
    "wprintf": "",
    "wscanf": "",
    "y0l": "",
    "y1l": "",
    "ynl": "",
    "__finitef": "",
    "__clock_gettime": "Get current value of CLOCK and store it in TP.",
    "clock": "Return the time used by the program so far (user time + system time).",
    "__close_nocancel": "",
    "__open": "Open FILE_NAME and return a Hurd I/O for it in *PORT, or return an\n   error.  If STAT is non-zero, stat the file into that stat buffer.",
    "__pread64": "",
    "__read": "",
    "__write": "",
    "__strtoul_internal": "This is only used by hurdlookup for the /dev/fd/nnn magic.\n * We avoid pulling the whole libc implementation, and we can keep this hidden.",
    "fstatvfs": "",
    "fstatvfs64": "",
    "__fxstat": "Get information about the file NAME in BUF.",
    "__fxstat64": "Get information about the file FD in BUF.",
    "__fxstatat": "Get information about the file FD in BUF.",
    "__fxstatat64": "Get information about the file NAME in BUF.",
    "__lxstat": "Get information about the file NAME in BUF.",
    "__lxstat64": "Get information about the file NAME in BUF.",
    "__open_nocancel": "",
    "__pread64_nocancel": "",
    "ptsname": "Return the pathname of the pseudo terminal slave associated with\n   the master FD is open on, or NULL on errors.\n   The returned storage is good until the next call to this function.",
    "__read_nocancel": "",
    "statvfs": "",
    "statvfs64": "",
    "__write_nocancel": "",
    "__xmknod": "Create a device file named PATH, with permission and special bits MODE\n   and device number DEV (which can be constructed from major and minor\n   device numbers with the `makedev' macro above).",
    "__xmknodat": "Create a device file named PATH relative to FD, with permission and\n   special bits MODE and device number DEV (which can be constructed\n   from major and minor device numbers with the `makedev' macro above).",
    "__xstat": "Get information about the file NAME in BUF.",
    "__xstat64": "Get information about the file NAME in BUF.",
    "pthread_mutex_consistent": "",
    "__pthread_mutex_destroy": "",
    "pthread_mutex_getprioceiling": "",
    "__pthread_mutex_init": "",
    "__pthread_mutex_lock": "",
    "pthread_mutex_setprioceiling": "",
    "__pthread_mutex_trylock": "",
    "__pthread_mutex_unlock": "",
    "__pthread_mutexattr_destroy": "",
    "pthread_mutexattr_getprioceiling": "",
    "pthread_mutexattr_getprotocol": "",
    "pthread_mutexattr_getpshared": "",
    "pthread_mutexattr_getrobust": "",
    "pthread_mutexattr_gettype": "",
    "__pthread_mutexattr_init": "",
    "pthread_mutexattr_setprioceiling": "",
    "pthread_mutexattr_setprotocol": "",
    "pthread_mutexattr_setpshared": "",
    "pthread_mutexattr_setrobust": "",
    "__pthread_mutexattr_settype": "",
    "ioperm": "",
    "euidaccess": "Return 0 if the user has permission of type MODE on file PATH;\n   otherwise, return -1 and set `errno' to EACCESS.\n   Like access, except that it uses the effective user and group\n   id's instead of the real ones, and it does not check for read-only\n   filesystem, text busy, etc.",
    "cnd_timedwait": "",
    "mtx_timedlock": "",
    "thrd_equal": "",
    "thrd_sleep": "",
    "grantpt": "",
    "tcflow": "Suspend or restart transmission on FD.",
    "tcflush": "Flush pending data on FD.",
    "tcgetpgrp": "Return the foreground process group ID of FD.",
    "tcsendbreak": "Send zero bits on FD.",
    "tcsetattr": "Set the state of FD to *TERMIOS_P.",
    "unlockpt": "Unlock the slave pseudo terminal associated with the master pseudo\n   terminal specified by FD.",
    "accept4": "",
    "__cmsg_nxthdr": "",
    "openat64": "",
    "epoll_create": "",
    "epoll_pwait": "Wait for events on an epoll instance \"epfd\". Returns the number of\n   triggered events returned in \"events\" buffer. Or -1 in case of\n   error with the \"errno\" variable set to the specific error code. The\n   \"events\" parameter is a buffer that will contain triggered\n   events. The \"maxevents\" is the maximum number of events to be\n   returned ( usually size of \"events\" ). The \"timeout\" parameter\n   specifies the maximum wait time in milliseconds (-1 == infinite).\n   The thread's signal mask is temporarily and atomically replaced with\n   the one provided as parameter.",
    "epoll_pwait2": "",
    "epoll_wait": "",
    "eventfd_read": "",
    "eventfd_write": "",
    "execveat": "Execute the file FD refers to, overlaying the running program image.\n   ARGV and ENVP are passed to the new program, as for 'execve'.",
    "fallocate": "Reserve storage for the data of the file associated with FD.",
    "fallocate64": "Reserve storage for the data of the file associated with FD.",
    "__libc_fcntl64": "",
    "ftime": "",
    "getdirentries": "",
    "__gettimeofday": "",
    "inotify_init": "",
    "listen": "",
    "__lseek": "",
    "mlock2": "",
    "msgget": "Return descriptor for message queue associated with KEY.  The MSGFLG\n   parameter describes how to proceed with clashing of key values.",
    "__libc_msgrcv": "",
    "__libc_msgsnd": "",
    "__netlink_assert_response": "",
    "__open64_nocancel": "",
    "open_by_handle_at": "",
    "pidfd_getpid": "",
    "pidfd_spawn": "",
    "pidfd_spawnp": "",
    "pkey_get": "",
    "pkey_mprotect": "",
    "pkey_set": "",
    "prlimit": "",
    "process_vm_readv": "",
    "process_vm_writev": "",
    "sched_getcpu": "RSEQ_SIG",
    "semget": "Return identifier for array of NSEMS semaphores associated with\n   KEY.",
    "semop": "Perform user-defined atomic operation of array of semaphores.",
    "shmat": "Attach the shared memory segment associated with SHMID to the data\n   segment of the calling process.  SHMADDR and SHMFLG determine how\n   and where the segment is attached.",
    "shmdt": "Detach shared memory segment starting at address specified by SHMADDR\n   from the caller's data segment.",
    "shmget": "Return an identifier for an shared memory segment of at least size SIZE\n   which is associated with KEY.",
    "signalfd": "",
    "posix_spawnattr_getcgroup_np": "Get scheduling policy from the attribute structure.",
    "posix_spawnattr_setcgroup_np": "Store scheduling policy in the attribute structure.",
    "cfgetospeed": "Return the output baud rate stored in *TERMIOS_P.",
    "cfgetispeed": "Return the input baud rate stored in *TERMIOS_P.",
    "cfsetospeed": "Set the output baud rate stored in *TERMIOS_P to SPEED.",
    "cfsetispeed": "",
    "splice": "",
    "sync_file_range": "",
    "tee": "",
    "time": "Return the time now, and store it in *TIMER if not NULL.",
    "vmsplice": "",
    "iopl": "",
    "__clone": "The OpenRISC ABI uses the stack for varargs like those using in clone\n   but the linux syscall ABI uses registers.\n   This function moves from varargs to regs.",
    "__arch_prctl": "Since x32 arch_prctl stores 32-bit base address of segment registers\n   %fs and %gs as unsigned 64-bit value via ARCH_GET_FS and ARCH_GET_GS,\n   we use an unsigned 64-bit variable to hold the base address and copy\n   it to ADDR after the system call returns.",
    "__x86_get_cpuid_feature_leaf": "",
    "ftok": "",
    "msgctl": "Allows to control internal state and destruction of message queue\n   objects.",
    "msgrcv": "Read a message from the queue associated with the message queue\n   descriptor MSQID.  At most MSGSZ bytes of the message are placed\n   in the buffer specified by the MSGP parameter.  The MSGTYP parameter\n   describes which message is returned in MSGFLG describes the behaviour\n   in buffer overflow or queue underflow.",
    "msgsnd": "Send a message to the queue associated with the message queue\n   descriptor MSQID.  The parameter MSGP points to a structure\n   describing messages where the parameter MSGSZ gives the length\n   of the text.  The MSGFLG parameter describes the action taken\n   when the limit of the message queue length is reached.",
    "semctl": "Return identifier for array of NSEMS semaphores associated with\n   KEY.",
    "shmctl": "Provide operations to control over shared memory segments.",
    "cfmakeraw": "Set *T to indicate raw mode.",
    "cfsetspeed": "Set both the input and output baud rates stored in *TERMIOS_P to SPEED.",
    "tcgetsid": "Return the session ID of FD.",
    "asctime": "Returns a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\n   which is the representation of TP in that form.",
    "ctime": "Return a string as returned by asctime which\n   is the representation of *T in that form.",
    "ctime_r": "Return a string as returned by asctime which is the representation\n   of *T in that form.  Reentrant version.",
    "dysize": "",
    "getdate": "",
    "__gmtime_r": "Return the `struct tm' representation of *T in UTC,\n   using *TP to store the result.",
    "gmtime": "",
    "localtime": "",
    "mktime": "Convert *TP to a __time64_t value.",
    "strftime": "",
    "strptime": "",
    "localtime_r": "",
    "timegm": "",
    "timespec_get": "Set TS to calendar time based in time base BASE.",
    "timespec_getres": "Set TS to resolution of time base BASE.",
    "wcsftime": "",
    "tzset": "",
    "gmtime_r": "",
    "strdup": "",
    "c16rtomb": "",
    "c32rtomb": "",
    "c8rtomb": "",
    "__mbrlen": "",
    "mbrtoc16": "",
    "mbrtoc32": "",
    "mbrtoc8": "",
    "__mbrtowc": "",
    "wcscspn": "Return the length of the maximum initial segment\n   of WCS which contains only wide-characters not in REJECT.",
    "wcsdup": "Duplicate S, returning an identical malloc'd string.",
    "wcspbrk": "Find the first occurrence in WCS of any wide-character in ACCEPT.",
    "wcsspn": "Return the length of the maximum initial segment\n   of WCS which contains only wide-characters in ACCEPT.",
    "wcsstr": "",
    "wcstok": "Parse WCS into tokens separated by characters in DELIM.  If WCS is\n   NULL, the last string wcstok() was called with is used.",
    "wcswidth": "Determine number of column positions required for first N wide\n   characters (or fewer if S ends before this) in S.",
    "wctob": "",
    "wcwidth": "Determine number of column positions required for CH.",
    "__iswctype": "",
    "__iswctype_l": "",
    "__towctrans": "",
    "__towctrans_l": "",
    "__wctrans_l": "",
    "__wctype_l": ""
}
